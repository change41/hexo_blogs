<?xml version="1.0" encoding="UTF-8" ?>
<!-- This is a WordPress eXtended RSS file generated by WordPress as an export of your site. -->
<!-- It contains information about your site's posts, pages, comments, categories, and other content. -->
<!-- You may use this file to transfer that content from one site to another. -->
<!-- This file is not intended to serve as a complete backup of your site. -->

<!-- To import this information into a WordPress site follow these steps: -->
<!-- 1. Log in to that site as an administrator. -->
<!-- 2. Go to Tools: Import in the WordPress admin panel. -->
<!-- 3. Install the "WordPress" importer from the list. -->
<!-- 4. Activate & Run Importer. -->
<!-- 5. Upload this file using the form provided on that page. -->
<!-- 6. You will first be asked to map the authors in this export file to users -->
<!--    on the site. For each author, you may choose to map to an -->
<!--    existing user on the site or to create a new user. -->
<!-- 7. WordPress will then import each of the posts, pages, comments, categories, etc. -->
<!--    contained in this file into your site. -->

<!-- generator="WordPress/5.0.2" created="2019-01-04 04:54" -->
<rss version="2.0"
	xmlns:excerpt="http://wordpress.org/export/1.2/excerpt/"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:wp="http://wordpress.org/export/1.2/"
>

<channel>
	<title>Growing</title>
	<link>https://www.rhel.tk</link>
	<description>每天学习一点</description>
	<pubDate>Fri, 04 Jan 2019 04:54:41 +0000</pubDate>
	<language>zh-CN</language>
	<wp:wxr_version>1.2</wp:wxr_version>
	<wp:base_site_url>https://www.rhel.tk</wp:base_site_url>
	<wp:base_blog_url>https://www.rhel.tk</wp:base_blog_url>

	<wp:author><wp:author_id>1</wp:author_id><wp:author_login><![CDATA[change_lee]]></wp:author_login><wp:author_email><![CDATA[920086808@qq.com]]></wp:author_email><wp:author_display_name><![CDATA[change_lee]]></wp:author_display_name><wp:author_first_name><![CDATA[]]></wp:author_first_name><wp:author_last_name><![CDATA[]]></wp:author_last_name></wp:author>
	<wp:author><wp:author_id>2</wp:author_id><wp:author_login><![CDATA[blogs]]></wp:author_login><wp:author_email><![CDATA[blogs@rhel.tk]]></wp:author_email><wp:author_display_name><![CDATA[blogs]]></wp:author_display_name><wp:author_first_name><![CDATA[change]]></wp:author_first_name><wp:author_last_name><![CDATA[lee]]></wp:author_last_name></wp:author>


	<generator>https://wordpress.org/?v=5.0.2</generator>

<image>
	<url>https://www.rhel.tk/wp-content/uploads/2018/04/cropped-1145989-1-32x32.png</url>
	<title>Growing</title>
	<link>https://www.rhel.tk</link>
	<width>32</width>
	<height>32</height>
</image> 

	<item>
		<title>世界，您好！</title>
		<link>https://www.rhel.tk/2018/04/11/hello-world/</link>
		<pubDate>Wed, 11 Apr 2018 02:20:26 +0000</pubDate>
		<dc:creator><![CDATA[change_lee]]></dc:creator>
		<guid isPermaLink="false">https://www.rhel.tk/?p=1</guid>
		<description></description>
		<content:encoded><![CDATA[欢迎使用WordPress。这是您的第一篇文章。编辑或删除它，然后开始写作吧！]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1</wp:post_id>
		<wp:post_date><![CDATA[2018-04-11 10:20:26]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-04-11 02:20:26]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[hello-world]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="uncategorized"><![CDATA[未分类]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[hestia_layout_select]]></wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>1</wp:comment_id>
			<wp:comment_author><![CDATA[一位WordPress评论者]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[wapuu@wordpress.example]]></wp:comment_author_email>
			<wp:comment_author_url>https://wordpress.org/</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-04-11 10:20:26]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-04-11 02:20:26]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[嗨，这是一条评论。
要开始审核、编辑及删除评论，请访问仪表盘的“评论”页面。
评论者头像来自<a href="https://gravatar.com">Gravatar</a>。]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
	</item>
	<item>
		<title>Chapter 10.Analyzing and Storing Logs</title>
		<link>https://www.rhel.tk/2018/04/11/118/</link>
		<pubDate>Wed, 11 Apr 2018 06:59:33 +0000</pubDate>
		<dc:creator><![CDATA[blogs]]></dc:creator>
		<guid isPermaLink="false">https://www.rhel.tk/?p=118</guid>
		<description></description>
		<content:encoded><![CDATA[<p><img src="/wp-content/uploads/image/20180411/1523427823840955.png" title="1523427823840955.png" alt="rhel-10-1.png" /></p><table><colgroup><col style="width:54pt" span="3" width="72" /></colgroup><tbody><tr style="height:75.0pt" class="firstRow"><td class="xl65 selectTdClass" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun;font-size: 14px">*.info;mail.none;authpriv.none;cron.none</span></td><td class="xl66 selectTdClass" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun;font-size: 14px">常规日志</span></td><td class="xl66 selectTdClass" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun;font-size: 14px">messages</span></td></tr><tr style="height:15.0pt"><td class="xl65 selectTdClass" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun;font-size: 14px">authpriv.*</span></td><td class="xl66 selectTdClass" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun;font-size: 14px">认证日志</span></td><td class="xl65 selectTdClass" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun;font-size: 14px">secure</span></td></tr><tr style="height:15.0pt"><td class="xl65 selectTdClass" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun;font-size: 14px">mail.*</span></td><td class="xl66 selectTdClass" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun;font-size: 14px">邮件日志</span></td><td class="xl65 selectTdClass" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun;font-size: 14px">maillog</span></td></tr><tr style="height:15.0pt"><td class="xl65 selectTdClass" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun;font-size: 14px">cron.*</span></td><td class="xl66 selectTdClass" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun;font-size: 14px">任务计划</span></td><td class="xl65 selectTdClass" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun;font-size: 14px">cron</span></td></tr><tr style="height:15.0pt"><td class="xl65 selectTdClass" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun;font-size: 14px">local7.*</span></td><td class="xl66 selectTdClass" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun;font-size: 14px">启动信息</span></td><td class="xl65 selectTdClass" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun;font-size: 14px">boot.log</span></td></tr><tr style="height:30.0pt"><td class="xl65 selectTdClass" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun;font-size: 14px">uucp,news.crit</span></td><td class="xl66 selectTdClass" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun;font-size: 14px">新闻类错误</span></td><td class="xl65 selectTdClass" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun;font-size: 14px">spooler</span></td></tr><tr style="height:27.0pt"><td class="xl66 selectTdClass" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun;font-size: 14px">kern.*</span></td><td class="xl66 selectTdClass" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun;font-size: 14px">内核类</span></td><td class="xl66 selectTdClass" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun;font-size: 14px">/dev/console</span></td></tr></tbody></table><p style="font-family:宋体;font-size:15px"><span style="font-family: 宋体, SimSun;font-size: 14px">可以在/etc/rsyslog.conf里配置额外的日志文件，类型如下表，例如</span></p><p style="font-family:宋体;font-size:15px"><span style="font-family: 宋体, SimSun;font-size: 14px">*.debug&nbsp;&nbsp; /var/log/messages.debug</span></p><p><img src="/wp-content/uploads/image/20180411/1523429897556805.png" title="1523429897556805.png" alt="rhel-10-2.png" /></p><p><br /></p><p style="font-family:宋体;font-size:15px"><span style="font-family: 宋体, SimSun;font-size: 14px">journalctl</span></p><p style="font-family:宋体;font-size:15px"><span style="font-family: 宋体, SimSun;font-size: 14px">/run/log/journal&nbsp;&nbsp; 默认位置重启后会清除</span></p><p style="font-family:宋体;font-size:15px"><span style="font-family: 宋体, SimSun;font-size: 14px">如果/var/log/journal 存在，则journalctl 会将日志存放过来，存储大小一般不超过当前文件系统的10%，所以要保留15%的空间</span></p><p style="font-family:宋体;font-size:15px"><span style="font-family: 宋体, SimSun;font-size: 14px">/var/log/journal 文件的权限</span></p><p style="margin-left:.375in;font-family:宋体;font-size:15px"><span style="font-family: 宋体, SimSun;font-size: 14px">chown root:systtemd-journal /var/log/journal</span></p><p style="margin-left:.375in;font-family:宋体;font-size:15px"><span style="font-family: 宋体, SimSun;font-size: 14px">chmod 2755 /var/log/journal</span></p><p style="margin-left:.375in;font-family:宋体;font-size:15px;color:red"><span style="font-family: 宋体, SimSun;font-size: 14px">drwxr-sr-x. 2 root systemd-journal 6 4月&nbsp;&nbsp; 9 16:33 journal/</span></p><p style="font-family:宋体;font-size:15px"><span style="font-family: 宋体, SimSun;font-size: 14px">重启journald服务：</span></p><p style="margin-left:.375in;font-family:宋体;font-size:15px"><span style="font-family: 宋体, SimSun;font-size: 14px">killall -USR1 systemd-journald</span></p><p style="font-family:宋体;font-size:15px"><span style="font-family: 宋体, SimSun;font-size: 14px">&nbsp;&nbsp; 或&nbsp; reboot</span></p><p style="font-family:宋体;font-size:15px"><span style="font-family: 宋体, SimSun;font-size: 14px">&nbsp;==========================================================</span></p><p style="font-family:宋体;font-size:15px"><span style="font-family: 宋体, SimSun;font-size: 14px"></span></p><pre class="brush:bash;toolbar:false">journalctl&nbsp;-n&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#显示最后5条
journalctl&nbsp;-p&nbsp;err&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#指定日志的优先级类型
journalctl&nbsp;-f&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#等同于&nbsp;tail&nbsp;-f</pre><p style="font-family:宋体;font-size:15px"><span style="font-family: 宋体, SimSun;font-size: 14px"></span><br /></p><p style="font-family:宋体;font-size:15px"><span style="font-family: 宋体, SimSun;font-size: 14px">指定日志的日期：</span></p><p style="font-family:宋体;font-size:15px"><span style="font-family: 宋体, SimSun;font-size: 14px"></span></p><pre class="brush:bash;toolbar:false">journalctl&nbsp;--since&nbsp;today&nbsp;&nbsp;
journalctl&nbsp;--since&nbsp;15:30:00&nbsp;&nbsp;--until&nbsp;15:35:00
journalctl&nbsp;--since&nbsp;&quot;2018-04-09&nbsp;15:30:00&quot;&nbsp;--until&nbsp;&quot;2018-04-09&nbsp;16:00:00&quot;</pre><p style="font-family:宋体;font-size:15px"><span style="font-family: 宋体, SimSun;font-size: 14px"></span><br /></p><p style="font-family:宋体;font-size:15px"><span style="font-family: 宋体, SimSun;font-size: 14px">查看详情,可是加在其它参数后面或者前面</span></p><p style="font-family:宋体;font-size:15px"><span style="font-family: 宋体, SimSun;font-size: 14px"></span></p><pre class="brush:bash;toolbar:false">journalctl&nbsp;-o&nbsp;verbose
journalctl&nbsp;&nbsp;&nbsp;_SYSTEMD_UNIT=sshd.service&nbsp;&nbsp;&nbsp;_PID=1182&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#查看指定进程或服务的日志
journalctl&nbsp;--since&nbsp;15:00:00&nbsp;_SYSTEMD_UNIT=sshd.service</pre><p style="font-family:宋体;font-size:15px"><span style="font-family: 宋体, SimSun;font-size: 14px"></span><br /></p><p><span style="font-family: 宋体, SimSun;font-size: 14px">&nbsp;==========================================================</span></p><p style="font-family:宋体;font-size:15px"><span style="font-family: 宋体, SimSun;font-size: 14px">rsyslog</span></p><p style="margin-left:.375in;font-family:宋体;font-size:15px"><span style="font-family: 宋体, SimSun;font-size: 14px">/etc/rsyslog.conf</span></p><p style="margin-left:.375in;font-family:宋体;font-size:15px"><span style="font-family: 宋体, SimSun;font-size: 14px">/etc/rysylog.d/*.conf</span></p><p style="font-family:宋体;font-size:15px"><span style="font-family: 宋体, SimSun;font-size: 14px">man 5 rsyslog.conf</span></p><p style="font-family:宋体;font-size:15px"><span style="font-family: 宋体, SimSun;font-size: 14px">http:// /usr/share/doc/rsyslog-*/manual.html</span></p><p style="font-family:宋体;font-size:15px"><br /></p><p style="font-family:宋体;font-size:15px"><span style="font-family: 宋体, SimSun;font-size: 14px">&nbsp;==========================================================</span></p><p style="font-family:宋体;font-size:15px"><span style="font-family: 宋体, SimSun;font-size: 14px">logrotate 日志轮巡</span></p><p style="font-family:宋体;font-size:15px"><span style="font-family: 宋体, SimSun;font-size: 14px">/etc/logrotate.conf</span></p><p style="font-family:宋体;font-size:15px"><span style="font-family: 宋体, SimSun;font-size: 14px">/etc/logrotate.d/*.conf</span></p><p><span style="font-family: 宋体, SimSun;font-size: 14px">&nbsp;==========================================================</span></p><p style="font-family:宋体;font-size:15px"><span style="font-family: 宋体, SimSun;font-size: 14px">标准rsyslog格式</span></p><p><span style="font-family: 宋体, SimSun;font-size: 14px">Apr&nbsp; 9 14:59:44 client systemd: Starting Session 2 of user root.</span></p><p><span style="font-family: 宋体, SimSun;font-size: 14px">发生的日期&nbsp; 主机&nbsp; 产生日志的程序 ：日志内容</span></p><p><span style="font-family: 宋体, SimSun;font-size: 14px"><span style="font-family: 宋体, SimSun;font-size: 14px">&nbsp;==========================================================</span></span></p><p style="font-family:宋体;font-size:15px"><span style="font-family: 宋体, SimSun;font-size: 14px">logger 程序生成日志记录到文件</span></p><p style="font-family:宋体;font-size:15px"><span style="font-family: 宋体, SimSun;font-size: 14px"></span></p><pre class="brush:bash;toolbar:false">logger&nbsp;-p&nbsp;local7.notice&nbsp;&quot;Log&nbsp;entry&nbsp;created&nbsp;on&nbsp;ServerX&quot;&nbsp;生产notice&nbsp;日志
logger&nbsp;-p&nbsp;user.debug&nbsp;&quot;debug&nbsp;message&nbsp;test&quot;&nbsp;&nbsp;产生debug&nbsp;日志</pre><p style="font-family:宋体;font-size:15px"><span style="font-family: 宋体, SimSun;font-size: 14px"></span><br /></p><p><span style="font-family: 宋体, SimSun;font-size: 14px">&nbsp;==========================================================</span></p><p style="font-family:宋体;font-size:15px"><span style="font-family: 宋体, SimSun;font-size: 14px">时间的维护：</span></p><p style="font-family:宋体;font-size:15px"><span style="font-family: 宋体, SimSun;font-size: 14px"></span></p><pre class="brush:bash;toolbar:false">tzselect&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#交互式设备时区tz=timezone
timedatectl
timedatectl&nbsp;&nbsp;list-timezones
timedatectl&nbsp;&nbsp;set-timezone&nbsp;America/Phoenix
timedatectl&nbsp;&nbsp;set-timezone&nbsp;Asia/Shanghai
timedatectl&nbsp;&nbsp;set-time&nbsp;9:00:00&nbsp;&nbsp;&nbsp;#(YYYY-MM-DD&nbsp;hh:mm:ss)
timedatectl&nbsp;&nbsp;set-ntp&nbsp;true/false</pre><p style="font-family:宋体;font-size:15px"><span style="font-family: 宋体, SimSun;font-size: 14px"></span><br /></p><p style="font-family:宋体;font-size:15px"><span style="font-family: 宋体, SimSun;font-size: 14px"><span style="font-family: 宋体, SimSun;font-size: 14px">&nbsp;==========================================================</span>&nbsp;</span></p><p style="font-family:宋体;font-size:15px"><span style="font-family: 宋体, SimSun;font-size: 14px">Configuring chronyd</span></p><p style="font-family:宋体;font-size:15px"><span style="font-family: 宋体, SimSun;font-size: 14px">/etc/chrony.conf</span></p><p style="font-family:宋体;font-size:15px"><span style="font-family: 宋体, SimSun;font-size: 14px">修改文件中的服务器位置</span></p><p style="font-family:宋体;font-size:15px"><span style="font-family: 宋体, SimSun;font-size: 14px">chronyc souces -v&nbsp;&nbsp; 验证NTP服务器，并显示详情</span></p><p style="font-family:宋体;font-size:15px"><span style="font-family: 宋体, SimSun;font-size: 14px">ntpd、ntpq 在Redhat7以前使用，用来管理NTP服务器</span></p><p><br /></p>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>118</wp:post_id>
		<wp:post_date><![CDATA[2018-04-11 14:59:33]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-04-11 06:59:33]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[118]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="rhel124"><![CDATA[RHEL124]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[hestia_layout_select]]></wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_page_template]]></wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Chapter 9. Openssh</title>
		<link>https://www.rhel.tk/2018/04/11/chapter-9-openssh/</link>
		<pubDate>Wed, 11 Apr 2018 07:53:20 +0000</pubDate>
		<dc:creator><![CDATA[blogs]]></dc:creator>
		<guid isPermaLink="false">https://www.rhel.tk/?p=128</guid>
		<description></description>
		<content:encoded><![CDATA[<p><span style="font-family: 宋体,SimSun;font-size: 14px"><br /></span></p><p><span style="font-family: 宋体,SimSun"><span style="font-family: 宋体,SimSun;font-size: 14px">ssh host keys<br /><br />~/.ssh/known_hosts 保存服务器公钥<br /><br />/etc/ssh 下查看本机产生的密钥<br /><br />&nbsp;<br /><br />基于用户名和密码<br /><br />&nbsp;PasswordAuthentication yes<br /><br />基于key密钥<br /><br />client:<br /><br />ssh-keygen 产生密钥(公钥和私钥)（~/.ssh/id_rsa,id_rsa.pub 默认）<br /><br />ssh-copy-id&nbsp;&nbsp;&nbsp; root@server0&nbsp; 传输公钥到服务器<br /><br />server:<br /><br />ssh-copy-id 命令结束后，本端会产生认证文件<br /><br />&nbsp;=========================================<br /><br />&nbsp;配置ssh<br /><br />禁用root ssh登录<br /><br />/etc/ssh/sshd_config<br /><br />将#PermitRootLogin yes 改成PermitRootLogin no .去掉#，改yes为no,重启服务<br /><br />PermitRootLogin&nbsp; without-password&nbsp;&nbsp; 设置root只能使用key方式<br /><br />阻止密码认证方式<br /><br />PasswordAuthentication yes 改 no<br /><br />=========================================<br /><br />高级功能ssh-agent<br /><br />ssh-add<br /><br /><br />Administration Guide Chapter 8.2.4.2:Configuring ssh-agent<br /><br />https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/system_administrators_guide/s1-ssh-configuration<br /><br /></span>ssh servername -X 调用远程服务的桌面环境到本地使用</span></p>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>128</wp:post_id>
		<wp:post_date><![CDATA[2018-04-11 15:53:20]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-04-11 07:53:20]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[chapter-9-openssh]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="rhel124"><![CDATA[RHEL124]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[hestia_layout_select]]></wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_page_template]]></wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Chapter 8.systemctl</title>
		<link>https://www.rhel.tk/2018/04/11/chapter-8-systemctl/</link>
		<pubDate>Wed, 11 Apr 2018 07:56:50 +0000</pubDate>
		<dc:creator><![CDATA[blogs]]></dc:creator>
		<guid isPermaLink="false">https://www.rhel.tk/?p=134</guid>
		<description></description>
		<content:encoded><![CDATA[<p><br /><span style="font-family: 宋体, SimSun"></span></p><pre class="brush:bash;toolbar:false">systemctl&nbsp;is-active&nbsp;firewalld
systemctl&nbsp;is-enabled&nbsp;firewalld
systemctl&nbsp;status&nbsp;firewalld
systemctl&nbsp;stop&nbsp;firewalld
systemctl&nbsp;start&nbsp;firewalld
systemctl&nbsp;restart&nbsp;firewalld
systemctl&nbsp;reload&nbsp;firewalld
systemctl&nbsp;enable&nbsp;firewalld
systemctl&nbsp;disable&nbsp;firewalld
systemctl&nbsp;--type=service&nbsp;&nbsp;&nbsp;&nbsp;==&nbsp;systemctl&nbsp;-t&nbsp;service
systemctl&nbsp;--type=service&nbsp;--faild
systemctl&nbsp;list-units&nbsp;--type=service&nbsp;--all&nbsp;&nbsp;#显示所有服务，包括未激活的
systemctl&nbsp;list-unit-files&nbsp;--type=service&nbsp;&nbsp;#显示服务文件
systemctl&nbsp;list-dependencies&nbsp;UNIT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#查看进程依赖关系
systemctl&nbsp;list-dependencies&nbsp;cups.socket&nbsp;--reverse&nbsp;&nbsp;&nbsp;#查看需要启动的依赖
systemctl&nbsp;mask&nbsp;firewalld&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#停用/屏蔽firewalld服务
systemctl&nbsp;unmask&nbsp;firewalld&nbsp;&nbsp;&nbsp;&nbsp;#开启/显示firewalld服务</pre><p><span style="font-family: 宋体, SimSun"></span><br /></p><p><span style="font-family: 宋体, SimSun"></span><br /></p><p><br /></p><p><span style="font-family: 宋体, SimSun"><img src="/wp-content/uploads/image/20180411/1523433401385622.png" title="1523433401385622.png" alt="8-1.png" /><br />&nbsp;==============================================================================<br /><br />systemctl type 类型<br />[root@client ~]# systemctl -t help<br />Available unit types:<br />service<br />socket<br />busname<br />target<br />snapshot<br />device<br />mount<br />automount<br />swap<br />timer<br />path<br />slice<br />scope<br /><br /><br /></span></p>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>134</wp:post_id>
		<wp:post_date><![CDATA[2018-04-11 15:56:50]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-04-11 07:56:50]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[chapter-8-systemctl]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="rhel124"><![CDATA[RHEL124]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[hestia_layout_select]]></wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_page_template]]></wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Chapter 11. Manager Network</title>
		<link>https://www.rhel.tk/2018/04/11/chapter-11-manager-network/</link>
		<pubDate>Wed, 11 Apr 2018 08:05:34 +0000</pubDate>
		<dc:creator><![CDATA[blogs]]></dc:creator>
		<guid isPermaLink="false">https://www.rhel.tk/?p=140</guid>
		<description></description>
		<content:encoded><![CDATA[<p><span style="font-family: 宋体, SimSun">常见服务端口查看文件：/etc/services<br />rhel 7开始网卡的命令开头规则为：<br />以太网：en；无线网：wl；WWAN：ww；<br />后面根网卡接口类型：<br />hotplug 热插拔：s; PCI接口 :p<br />主板集成：o；x:MAC地址使用<br />最后的数字是：索引、ID或端口。<br />如：eno1,ens33,enp2s0,eth0<br />无法确认的情况下，使用ethN 传统的形式。<br /></span></p><p><span style="font-family: 宋体, SimSun">biosdevname 包用来定义udev设备的名称规则，PIC(S)网卡名pYpX ，Y代表slot number ,X 代表当前板卡的第几个口</span></p><p><span style="font-family: 宋体, SimSun"><br /></span></p><p><br /></p><p><span style="font-family: 宋体, SimSun">&nbsp;==============================================================</span></p><pre class="brush:bash;toolbar:false">
ip&nbsp;addr&nbsp;show&nbsp;ens33&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#查看信息
ip&nbsp;-s&nbsp;link&nbsp;show&nbsp;eth0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#显示统计信息tatistics（统计）
ip&nbsp;route&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#查看路由
ping&nbsp;-c3&nbsp;192.168.1.1&nbsp;&nbsp;-cN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#指定ping的次数
tracepath&nbsp;access.redhat.com&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#跟踪路由，默认使用UDP路由，然后UDP经常被封</pre><p><span style="font-family: 宋体, SimSun">traceroute 有 -I(ICMP) , -T (TCP) 选项<br />RTT&nbsp; :Round trip timging; MTU:Maximum transmission unit<br />ss&nbsp; -ta 显示tcp&nbsp; socket 统计信息 -t=tcp ,-a=all.&nbsp;&nbsp; ss类似netstat 命令<br />-n 以数字形式显示端口或地址<br />-t&nbsp; tcp <br />-u&nbsp;&nbsp;&nbsp;&nbsp; udp<br />-l&nbsp;&nbsp;&nbsp;&nbsp; 显示处于Listening状态的服务<br />-a&nbsp; 显示所有<br /></span><br /></p><p><span style="font-family: 宋体, SimSun">-p&nbsp;&nbsp; 显示进程使用的socket</span></p><p><br /></p><p><span style="font-family: 宋体, SimSun"></span></p><p><span style="font-family: 宋体, SimSun">&nbsp;==============================================================</span></p><p><span style="font-family: 宋体, SimSun"><br />配置文件位置/etc/sysconfig/network-scripts/<br />网络管理服务：NetworkManager,命令是nmcli<br /></span></p><pre class="brush:bash;toolbar:false">nmcli&nbsp;con&nbsp;show&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#显示所有连接的网卡
nmcli&nbsp;con&nbsp;show&nbsp;--active&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#显示处于激活状态的网卡
nmcli&nbsp;con&nbsp;show&nbsp;&quot;ens33&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#显示网卡的详细信息,对应的详细说明查看man&nbsp;nm-settings&nbsp;
nmcli&nbsp;dev&nbsp;status
nmcli&nbsp;dev&nbsp;show&nbsp;ens33&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#显示指定网卡
nmcli&nbsp;dev&nbsp;show&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#显示网卡
nmcli&nbsp;con&nbsp;show&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#显示连接
nmcli&nbsp;con&nbsp;up&nbsp;&nbsp;&lt;&quot;ID&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#启用网卡
nmcli&nbsp;con&nbsp;down&nbsp;&nbsp;&lt;&quot;ID&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#关闭网卡
nmcli&nbsp;dev&nbsp;dis&nbsp;&nbsp;&lt;&quot;ID&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#断开连接
nmcli&nbsp;net&nbsp;off&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#停用网卡
nmcli&nbsp;net&nbsp;on&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#启用网卡
nmcli&nbsp;con&nbsp;add&nbsp;&nbsp;….&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#添加连接
nmcli&nbsp;con&nbsp;mod&nbsp;&nbsp;&lt;&quot;ID&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#修改连接
nmcli&nbsp;con&nbsp;del&nbsp;&nbsp;&lt;&quot;ID&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#删除连接
man&nbsp;nm-connection-editor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#查看详细说明</pre><p><span style="font-family: 宋体, SimSun"> ==============================================================</span></p><pre class="brush:bash;toolbar:false">nmcli&nbsp;con&nbsp;add&nbsp;con-name&nbsp;&quot;default&quot;&nbsp;type&nbsp;ethernet&nbsp;ifname&nbsp;eth0
nmcli&nbsp;con&nbsp;add&nbsp;con-name&nbsp;&quot;static&quot;&nbsp;ifname&nbsp;eth0&nbsp;autoconnect&nbsp;no&nbsp;type&nbsp;ethernet&nbsp;ip4&nbsp;172.25.1.10/24&nbsp;gw4&nbsp;172.25.1.254&nbsp;
nmcli&nbsp;con&nbsp;up&nbsp;&quot;static&quot;
nmcli&nbsp;con&nbsp;up&nbsp;&quot;default&quot;
nmcli&nbsp;con&nbsp;mod&nbsp;&quot;static&quot;&nbsp;connection.autoconnect&nbsp;yes
nmcli&nbsp;con&nbsp;mod&nbsp;&quot;static&quot;&nbsp;ipv4.dns&nbsp;172.24.1.254
nmcli&nbsp;con&nbsp;mod&nbsp;&quot;static&quot;&nbsp;+ipv4.dns&nbsp;8.8.8.8
nmcli&nbsp;con&nbsp;mod&nbsp;&quot;static&quot;&nbsp;ipv4.address&nbsp;&quot;172.25.2.10/24&nbsp;172.25.2.254&quot;
nmcli&nbsp;con&nbsp;mod&nbsp;&quot;static&quot;&nbsp;+ipv4.address&nbsp;192.168.1.1/24</pre><p><span style="font-family: 宋体, SimSun">&nbsp;==============================================================</span></p><p><span style="font-family: 宋体, SimSun"><br />修改配置文件后使用<br />nmcli con reload&nbsp; 重新加载配置文件<br />nmcli con down;nmcli con up<br /><br /></span></p><p><span style="font-family: 宋体, SimSun">&nbsp;==============================================================</span></p><p><span style="font-family: 宋体, SimSun">hostname&nbsp; 查看主机名</span></p><pre class="brush:bash;toolbar:false">hostnamectl&nbsp;set-hostname&nbsp;deskop.example.com</pre><p><span style="font-family: 宋体, SimSun"></span></p><pre class="brush:bash;toolbar:false">hostnamectl&nbsp;status&nbsp;&nbsp;&nbsp;#查看主机信息，包括主机名、计算机类型、系统类型、版本、架构
cat&nbsp;/etc/hostname&nbsp;&nbsp;#主机名保存的文件，/etc/sysconfig/network&nbsp;(老版本)</pre><p><span style="font-family: 宋体, SimSun">/etc/hosts 文件配置静态域名解析，本地解析</span></p><p><span style="font-family: 宋体, SimSun"></span></p><pre class="brush:bash;toolbar:false">getent&nbsp;hosts&nbsp;www.baidu.com&nbsp;&nbsp;#getent&nbsp;解析域名，同nslookup，对hosts文件有支持&nbsp;
host&nbsp;classroom.example.com&nbsp;&nbsp;#解析域名，同nslookup</pre><p><span style="font-family: 宋体, SimSun">/etc/resolv.conf&nbsp; 配置 DNS 服务器地址,支持内容如下：</span></p><p><span style="font-family: 宋体, SimSun">&nbsp;&nbsp;&nbsp;&nbsp;nameserver: DNS 的IP地址，最多可以设置3个</span></p><p><span style="font-family: 宋体, SimSun">&nbsp;&nbsp;&nbsp;&nbsp;search : 一般用域名，</span></p><p><span style="font-family: 宋体, SimSun">&nbsp;&nbsp;&nbsp;&nbsp;domain :一般用域名</span></p><p><span style="font-family: 宋体, SimSun">PEERDNS=no 时，不会影响/etc/resolv.conf ，如果网卡配置PEERDNS=yes ,重启网卡时会覆盖resolv.conf<br /></span></p>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>140</wp:post_id>
		<wp:post_date><![CDATA[2018-04-11 16:05:34]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-04-11 08:05:34]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[chapter-11-manager-network]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="rhel124"><![CDATA[RHEL124]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[hestia_layout_select]]></wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Chapter 12. Archiving and copying Files</title>
		<link>https://www.rhel.tk/2018/04/12/chapter-12-archiving-and-copying-files/</link>
		<pubDate>Thu, 12 Apr 2018 13:28:25 +0000</pubDate>
		<dc:creator><![CDATA[blogs]]></dc:creator>
		<guid isPermaLink="false">https://www.rhel.tk/?p=152</guid>
		<description></description>
		<content:encoded><![CDATA[<p><span style="font-family: 宋体, SimSun">压缩命令：tar , gzip ,bzip2, xz</span></p><p><span style="font-family: 宋体, SimSun">tar 命令参数：c(create) , t (list the contents) ,x (extract)&nbsp; f (后面要跟filename），v (verbose 详细信息),</span></p><p><span style="font-family: 宋体, SimSun">使用tar 命令打包文件或者文件夹前检查是否有同名的压缩文件，tar会覆盖原文件<span style="font-family: 宋体, SimSun;color: #FF0000">不提示</span>。</span></p><p><br /></p><pre class="brush:bash;toolbar:false">tar&nbsp;cf&nbsp;archive.tar&nbsp;file1&nbsp;file2&nbsp;file3&nbsp;&nbsp;#压缩&nbsp;file1,file2,file3&nbsp;到archive.tar&nbsp;
tar&nbsp;cf&nbsp;directory.tar&nbsp;directory1/&nbsp;&nbsp;&nbsp;&nbsp;#压缩&nbsp;directory1&nbsp;目录到directory.tar
tar&nbsp;tf&nbsp;archive.tar&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#查看archive.tar&nbsp;里的内容
tar&nbsp;cf&nbsp;/root/etc.tar&nbsp;&nbsp;/etc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;指定压缩包的保存位置，&nbsp;默认情况下，被压缩的路径前导符&nbsp;“/”（/etc&nbsp;在tar包里为etc）&nbsp;在压缩时会被删除，为了以后解压时出现覆盖情况，</pre><p><span style="font-family: 宋体, SimSun"></span><br /></p><p><span style="font-family: 宋体, SimSun"><br /></span></p><p><span style="font-family: 宋体, SimSun"></span></p><p><span style="font-family: 宋体, SimSun">tar 默认会保存文件的访问权限，如果需要同时保存selinux的上下文和acl权限，需要使用 --xattrs(需要root权限执行),--selinux，--acls 查看tar --help <br /></span></p><p><span style="font-family: 宋体, SimSun"></span></p><pre class="brush:bash;toolbar:false">tar&nbsp;cf&nbsp;archive.tar&nbsp;--xattrs&nbsp;--selinux&nbsp;&nbsp;filename&nbsp;&nbsp;&nbsp;#创建
tar&nbsp;xfp&nbsp;archive.tar&nbsp;--xattrs&nbsp;--selinux&nbsp;&nbsp;&nbsp;&nbsp;#解压带权限</pre><p><span style="font-family: 宋体, SimSun"></span><br /></p><p><span style="font-family: 宋体, SimSun">默认情况下，使用root解压文件会保留文件所属权限，使用普通用户解压会修改文件所属为当前用户,在解压时一般会删除umask 权限，如果需要保留使用-p 选项</span></p><p><span style="font-family: 宋体, SimSun">z for gzip&nbsp; (filename.tar.gz or filename.tgz)</span></p><p><span style="font-family: 宋体, SimSun">j for bzip2 (filename.tar.bz2)<br /></span></p><p><span style="font-family: 宋体, SimSun">J for xz (filename.tar.xz)<br /></span></p><p><span style="font-family: 宋体, SimSun"><img src="/wp-content/uploads/image/20180413/1523583168668639.png" title="1523583168668639.png" alt="图片.png" /></span></p><p><span style="font-family: 宋体, SimSun">==========压缩</span></p><p><span style="font-family: 宋体, SimSun"></span></p><pre class="brush:bash;toolbar:false">tar&nbsp;&nbsp;&nbsp;czf&nbsp;&nbsp;&nbsp;&nbsp;filename.tar.gz
tar&nbsp;&nbsp;&nbsp;czf&nbsp;&nbsp;&nbsp;&nbsp;filename.tgz
tar&nbsp;&nbsp;&nbsp;cjf&nbsp;&nbsp;&nbsp;&nbsp;filename.bz2
tar&nbsp;&nbsp;&nbsp;cJf&nbsp;&nbsp;&nbsp;&nbsp;filename.xz</pre><p><span style="font-family: 宋体, SimSun"></span><br /></p><p><span style="font-family: 宋体, SimSun"></span></p><p><span style="font-family: 宋体, SimSun">==========解压</span></p><p><span style="font-family: 宋体, SimSun"></span></p><pre class="brush:bash;toolbar:false">tar&nbsp;&nbsp;&nbsp;xzf&nbsp;&nbsp;&nbsp;&nbsp;filename.tar.gz
tar&nbsp;&nbsp;&nbsp;xzf&nbsp;&nbsp;&nbsp;&nbsp;filename.tgz
tar&nbsp;&nbsp;&nbsp;xjf&nbsp;&nbsp;&nbsp;&nbsp;filename.bz2
tar&nbsp;&nbsp;&nbsp;xJf&nbsp;&nbsp;&nbsp;&nbsp;filename.xz</pre><p><span style="font-family: 宋体, SimSun"></span><br /></p><p><span style="font-family: 宋体, SimSun"></span><br /></p><p><span style="font-family: 宋体, SimSun">同时可以使用gzip,bzip2,xz 对tar包进行二次压缩</span></p><p><span style="font-family: 宋体, SimSun"><a></a></span></p><hr /><h3><span style="font-family: 宋体, SimSun"></span>2018-04-13</h3><p><span style="font-family: 宋体, SimSun">scp&nbsp; 基于ssh 的安全传输</span></p><p><span style="font-family: 宋体, SimSun">scp&nbsp; root@host:/path&nbsp; </span><br /></p><pre class="brush:bash;toolbar:false">scp&nbsp;server0:/etc/hostname&nbsp;/home&nbsp;student/&nbsp;&nbsp;&nbsp;&nbsp;#从远程下载
scp&nbsp;/etc/yum.conf&nbsp;/etc/hosts&nbsp;server0:/home/student/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#上传到远程
scp&nbsp;-r&nbsp;root@server0:/var/log&nbsp;/tmp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#递归复制，针对整个目录</pre><p><span style="font-family: 宋体, SimSun">sftp 互动型文件传输，同样基于ssh的FTP安全传输,</span></p><p><span style="font-family: 宋体, SimSun"></span></p><pre class="brush:bash;toolbar:false">sftp&nbsp;server0&nbsp;&nbsp;&nbsp;&nbsp;#连接后输入对应的用户密码，默认为当前同名用户
sftp&nbsp;root@server0&nbsp;&nbsp;&nbsp;&nbsp;#使用root用户登录</pre><p><span style="font-family: 宋体, SimSun">常用ftp 命令: ls ,cd ,mkdir ,rmdir ,pwd ,查看本地lcd ,lls ,lpwd 等，详细可以在ftp 模式下&quot;?&quot;查看，put 上传，get 下载，exit退出</span></p><pre class="brush:bash;toolbar:false">[student@desktop0&nbsp;~]$&nbsp;sftp&nbsp;server0
student@server0&#039;s&nbsp;password:&nbsp;
Connected&nbsp;to&nbsp;server0.
sftp&gt;&nbsp;pwd
Remote&nbsp;working&nbsp;directory:&nbsp;/home/student
sftp&gt;&nbsp;mkdir&nbsp;hostbackup&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
sftp&gt;&nbsp;cd&nbsp;hostbackup/
sftp&gt;&nbsp;put&nbsp;/etc/hosts&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#上传
Uploading&nbsp;/etc/hosts&nbsp;to&nbsp;/home/student/hostbackup/hosts
/etc/hosts&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;100%&nbsp;&nbsp;231&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.2KB/s&nbsp;&nbsp;&nbsp;00:00&nbsp;&nbsp;&nbsp;&nbsp;
sftp&gt;&nbsp;get&nbsp;/etc/yum.conf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#下载
Fetching&nbsp;/etc/yum.conf&nbsp;to&nbsp;yum.conf
/etc/yum.conf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;100%&nbsp;&nbsp;813&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.8KB/s&nbsp;&nbsp;&nbsp;00:00&nbsp;&nbsp;&nbsp;&nbsp;
sftp&gt;&nbsp;exit</pre><p><span style="font-family: 宋体, SimSun"></span></p><hr /><p><span style="font-family: 宋体, SimSun">rsync&nbsp; 远程同步</span></p><p><span style="font-family: 宋体, SimSun">-a&nbsp;&nbsp;&nbsp;&nbsp;归档模式archive mode ，支持软连接,不支持高级权限如ACL,SELINUX 上下文</span></p><p><span style="font-family: 宋体, SimSun">-A&nbsp; -a &nbsp;&nbsp;&nbsp;&nbsp;启用支持高级权限如ACL</span></p><p><span style="font-family: 宋体, SimSun">-X&nbsp; -a &nbsp;&nbsp;&nbsp;&nbsp;启用Selinux <br /></span></p><p><span style="font-family: 宋体, SimSun">-n&nbsp;&nbsp;&nbsp;&nbsp;测试模式，不做更改<br /></span></p><p><span style="font-family: 宋体, SimSun">-r&nbsp;&nbsp;&nbsp;&nbsp;递归模式</span></p><p><span style="font-family: 宋体, SimSun">-l&nbsp;&nbsp;&nbsp;&nbsp;同步符号连接，保存为连接</span></p><p><span style="font-family: 宋体, SimSun">-p&nbsp;&nbsp;&nbsp;&nbsp;保留权限</span></p><p><span style="font-family: 宋体, SimSun">-H&nbsp;&nbsp;&nbsp;&nbsp;保留硬连接</span></p><p><span style="font-family: 宋体, SimSun">本地目录及文件同步：</span><br /></p><pre class="brush:bash;toolbar:false">#命令&nbsp;&nbsp;&nbsp;&nbsp;参数&nbsp;&nbsp;&nbsp;&nbsp;源&nbsp;&nbsp;&nbsp;&nbsp;目地
rsync&nbsp;&nbsp;-av&nbsp;&nbsp;/var/log&nbsp;&nbsp;/tmp&nbsp;#同步log文件夹及其内容
rsync&nbsp;&nbsp;-av&nbsp;/var/log/&nbsp;&nbsp;/tmp&nbsp;&nbsp;&nbsp;&nbsp;#仅同步文件夹下的内容</pre><p><span style="font-family: 宋体, SimSun">远程目录及文件同步,方式和scp 类似<br /></span></p><pre class="brush:bash;toolbar:false">rsync&nbsp;&nbsp;-av&nbsp;/var/log&nbsp;&nbsp;&nbsp;server0:/tmp
rsync&nbsp;&nbsp;-av&nbsp;server0:/var/log&nbsp;&nbsp;/tmp
rsync&nbsp;-av&nbsp;&nbsp;root@server0:/var/log&nbsp;&nbsp;&nbsp;/tmp</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>152</wp:post_id>
		<wp:post_date><![CDATA[2018-04-12 21:28:25]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-04-12 13:28:25]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[chapter-12-archiving-and-copying-files]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="rhel124"><![CDATA[RHEL124]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[hestia_layout_select]]></wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Chatper 13. Installing and updating software packages</title>
		<link>https://www.rhel.tk/2018/04/17/chatper-13-installing-and-updating-software-packages/</link>
		<pubDate>Tue, 17 Apr 2018 00:49:48 +0000</pubDate>
		<dc:creator><![CDATA[blogs]]></dc:creator>
		<guid isPermaLink="false">https://www.rhel.tk/?p=173</guid>
		<description></description>
		<content:encoded><![CDATA[<p><span style="font-family: 宋体, SimSun">红帽提供软件更新服务工具（收费）需要购买服务，并利用注册工具（subscription-manager-gui）进行注册软件管理服务器.</span></p><p><span style="font-family: 宋体, SimSun">Register 用户和红帽账号绑定</span></p><p><span style="font-family: 宋体, SimSun">&nbsp;&nbsp;&nbsp;&nbsp;1.在命令行command 输入 subscription-manager-gui,或者在GNOME界面Application--&gt;Other--&gt;Red Hat Subscription Manager 进入，输入对应的root 密码就可以进入图形操作，进入图形后点击右上角的Register会进入一个新的对话窗，subsription 默认服务器地址：subscription.rhn.redhat.com.Next后会要求输入RedHat的账号密码，默认会自动检查相应的订阅，也可以自己手动检查。最后点击Register完成注册。完成后就可以检查更新了。</span></p><p><span style="font-family: 宋体, SimSun">&nbsp;&nbsp;&nbsp;&nbsp;2.使用命令行完成自动注册</span></p><p><span style="font-family: 宋体, SimSun"></span></p><pre class="brush:bash;toolbar:false">&nbsp;&nbsp;&nbsp;&nbsp;subscription-manager&nbsp;register&nbsp;--username=yourname&nbsp;--password=yourpassword&nbsp;&nbsp;#订阅
&nbsp;&nbsp;&nbsp;&nbsp;subscription-manager&nbsp;list&nbsp;--available&nbsp;|&nbsp;less&nbsp;&nbsp;&nbsp;&nbsp;#查看有效的订阅
&nbsp;&nbsp;&nbsp;&nbsp;subscription-manager&nbsp;attach&nbsp;--auto&nbsp;&nbsp;&nbsp;&nbsp;#自动检查订阅
&nbsp;&nbsp;&nbsp;&nbsp;subscription-manager&nbsp;list&nbsp;--consumed&nbsp;&nbsp;&nbsp;&nbsp;#查看consumed（消费）&nbsp;订阅
&nbsp;&nbsp;&nbsp;&nbsp;subscription-manager&nbsp;unregister&nbsp;&nbsp;&nbsp;&nbsp;#取消订阅</pre><p><span style="font-family: 宋体, SimSun"></span><br /></p><p><span style="font-family: 宋体, SimSun">Subscribe 订阅授权给指定的产品，选择/删除需要授权的产品</span></p><p><span style="font-family: 宋体, SimSun">Enable repositories 启用软件包的存储库（理解成yum 源库），每个订阅默认会开启多个存储库，可以根据需要关闭不需要的，如源代码、更新</span></p><p><span style="font-family: 宋体, SimSun">Review and track&nbsp; 查看和审查自己的订阅信息，可以在本地和红帽网站上查询</span></p><p><span style="font-family: 宋体, SimSun">订阅的授权证书存放在/etc/pki 及其子目录中</span></p><pre class="brush:bash;toolbar:false">/etc/pki/product&nbsp;&nbsp;&nbsp;&nbsp;#安装在Red&nbsp;Hat中的产品证书
/etc/pki/consumer&nbsp;&nbsp;&nbsp;&nbsp;#存储在这个系统中的RedHat的账号的证书
/etc/pki/entitlement&nbsp;&nbsp;&nbsp;&nbsp;#包含了订阅了哪个许可的证书</pre><p><span style="font-family: 宋体, SimSun">可以使用rct程序检查证书，相比下subscription-manager程序读取证书更加友好 </span><br /></p><hr /><p><span style="font-family: 宋体, SimSun">rpm and yum</span></p><p><span style="font-family: 宋体, SimSun">rpm =red hat packet manager</span></p><p><span style="font-family: 宋体, SimSun">rpm 包的文件格式：</span></p><p><span style="font-family: 宋体, SimSun">name-version-release.architectrue</span></p><p><span style="font-family: 宋体, SimSun">httpd-tools.2.4.6.7-7.e17.x86_64.rpm <br /></span></p><p><span style="font-family: 宋体, SimSun">httpd-tools=name&nbsp;&nbsp;&nbsp;&nbsp;名字</span></p><p><span style="font-family: 宋体, SimSun">2.4.6.7=version&nbsp;&nbsp;&nbsp;&nbsp;版本</span></p><p><span style="font-family: 宋体, SimSun">7.el7=release&nbsp;&nbsp;&nbsp; 基于版本的发行号</span></p><p><span style="font-family: 宋体, SimSun">x86_64=arch&nbsp;&nbsp;&nbsp;&nbsp;架构</span></p><p><span style="font-family: 宋体, SimSun">默认安装时只需要使用RPM包的名字，如果有多个版本存在默认安装版本最高的</span></p><p><span style="font-family: 宋体, SimSun">每个RPM包包含以下三个组成部份：</span></p><p><span style="font-family: 宋体, SimSun">软件安装的文件、</span></p><p><span style="font-family: 宋体, SimSun">与软件包（元数据）有关的信息，摘要，描述、是否要求安装其它软件，授权许可、更改日志、以及其它详细信息</span></p><p><span style="font-family: 宋体, SimSun">在安装、更新或删除此软件包时可能运行的脚本、或此过程中可能触发的脚本。<br /></span></p><p><span style="font-family: 宋体, SimSun">如果软件构建为不冲突的文件名，则可以安装多个版本。例如kernel 否则只能安装一个版本。</span></p><p><span style="font-family: 宋体, SimSun">yum---------软件包管理器</span></p><p><span style="font-family: 宋体, SimSun">PackageKit 和yum 等工具是rpm的前端应用，可以用于安装单个软件包或软件包集合，并解决RPM无法解决的依赖关系。</span></p><p><span style="font-family: 宋体, SimSun">yum 的主要配置文件为：/etc/yum.conf,其它存储库配置文件位于在/etc/yum.repos.d目录中。<br /></span></p><p><span style="font-family: 宋体, SimSun">存储库配置文件至少包含一个存储库ID （在方括号中）、一个名称以及软件包存储库的URL位置。URL可以指向本地目录（文件）或远程网络共享(http和ftp等)。如果将该URL粘贴到浏览器中，则显示的内容应该有RPM软件包（可能位于一个或多个子目录中）。以及包含可用软件包相关信息的repodata目录。<br /></span></p><p><span style="font-family: 宋体, SimSun"></span></p><pre class="brush:bash;toolbar:false">#yum&nbsp;命令用于列出存储库、软件包和软件包组
yum&nbsp;repolist&nbsp;
yum&nbsp;list&nbsp;yum*&nbsp;&nbsp;&nbsp;&nbsp;#显示已安装和可用的软件包
yum&nbsp;grouplist
yum&nbsp;search&nbsp;apache&nbsp;&nbsp;&nbsp;&nbsp;#在名字和摘要字段搜索关键字列出的软件包
yum&nbsp;search&nbsp;all&nbsp;&#039;web&nbsp;server&#039;&nbsp;&nbsp;&nbsp;&nbsp;#搜索名字、摘要、描述等字段中包含&#039;web&nbsp;server&#039;的软件包
yum&nbsp;info&nbsp;PACKAGENAME&nbsp;&nbsp;&nbsp;&nbsp;#提供与指定软件包相关的详细信息，包括安装所需的磁盘空间。
yum&nbsp;provides&nbsp;/var/www/html&nbsp;&nbsp;&nbsp;&nbsp;#显示与指定的路径名（通常包含通配符）匹配的软件包
yum&nbsp;install&nbsp;PACKAGENAME&nbsp;&nbsp;&nbsp;&nbsp;#获取并安装软件包，包括依赖项
yum&nbsp;update&nbsp;PACKAGENAME&nbsp;&nbsp;&nbsp;&nbsp;#获取并安装更新版本的软件包，包括所有依赖项。通常该进程尝试适当保留配置文件，但是在某些情况下，如果打包商认为旧文件在更新后将无法使用，则可能对其进行重命名，如果未指定软件包名称，它将安装所有相关更新
yum&nbsp;remove&nbsp;PACKAGENAME&nbsp;&nbsp;&nbsp;&nbsp;#删除已安装的软件包、包括所有支持软件包。有可能会导致意外删除软件包，因此删除前要仔细检查要删除的软件包列表。
yum&nbsp;help</pre><p><span style="font-family: 宋体, SimSun"></span></p><pre class="brush:bash;toolbar:false">uname&nbsp;-r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#仅显示内核&nbsp;的版本和发行版本
uname&nbsp;-a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#将显示内核发行版和其它信息</pre><p><span style="font-family: 宋体, SimSun"></span><br /></p><p><span style="font-family: 宋体, SimSun">yum 有两种类型的组：常规组是软件包集合，环境组是其他组的集全。这些组包含自己的软件包。</span></p><p><span style="font-family: 宋体, SimSun">与yum list 相似，yum group list (或 yum grouplist ) 将列出已安装和可用的组名称，有些组通过环境安装，默认为隐藏，这些隐藏组也可以通过<span style="font-family: 宋体, SimSun;color: #FF0000">yum group list hidden</span> 命令列出。如果添加ids 选项，则会显示组ID。<br /></span></p><p><span style="font-family: 宋体, SimSun"></span></p><pre class="brush:bash;toolbar:false">yum&nbsp;grout&nbsp;list&nbsp;hidden&nbsp;&nbsp;&nbsp;&nbsp;#显示隐藏组
yum&nbsp;group&nbsp;list&nbsp;=&nbsp;yum&nbsp;grouplist&nbsp;&nbsp;&nbsp;&nbsp;#显示已经安装和可选安装的软件包组。
yum&nbsp;group&nbsp;info&nbsp;=&nbsp;yum&nbsp;groupinfo&nbsp;&nbsp;&nbsp;&nbsp;#它将列出改必选、默认和可选软件包名称或组ID。</pre><p><span style="font-family: 宋体, SimSun"></span><br /></p><p><span style="font-family: 宋体, SimSun">#软件包名称或组前面可能标有标记。如下图：<br /></span></p><p><span style="font-family: 宋体, SimSun"><img src="/wp-content/uploads/image/20180416/1523863565421240.png" title="1523863565421240.png" alt="图片.png" /></span></p><p><span style="font-family: 宋体, SimSun"></span></p><pre class="brush:bash;toolbar:false">yum&nbsp;group&nbsp;install&nbsp;=&nbsp;yum&nbsp;groupinstall&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#组安装
yum&nbsp;group&nbsp;remove&nbsp;=&nbsp;yum&nbsp;groupremove&nbsp;&nbsp;&nbsp;&nbsp;#组删除
yum&nbsp;group&nbsp;mark&nbsp;install&nbsp;GROUPNAME&nbsp;&nbsp;&nbsp;&nbsp;#标记为已安装，下次更新时将安装缺少的软件包和其依赖项。RHEL7&nbsp;以后增加的命令
tail&nbsp;-5&nbsp;/var/log/yum.log&nbsp;&nbsp;&nbsp;&nbsp;#查看事务历史记录
yum&nbsp;history&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#查看安装和删除事务的摘要
yum&nbsp;history&nbsp;undo&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;#撤销事务</pre><p><br /></p><pre class="brush:bash;toolbar:false">yum&nbsp;repolist&nbsp;all&nbsp;&nbsp;&nbsp;&nbsp;#查看所有可用的存储库
yum-config-manager&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#启用和禁用存储库，这将更改/etc/yum.repos.d/redhat.repo&nbsp;文件中的enabled&nbsp;参数
yum-config-manager&nbsp;&nbsp;--enable&nbsp;rhel-7-public-bate-debug-rpms&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#案例</pre><p><span style="font-family: 宋体, SimSun">第三方存储库：网站、ftp服务器、本地文件系统。将文件放到/etc/yum.repos.d/ 目录中以启用对第三方内容库的支持。内容库配置必须以.repo 结尾。</span></p><p><span style="font-family: 宋体, SimSun">存储库定义包含存储的URL和名称、也定义是否使用GPG检查 软件包签名；如果是，则还检查URL是否指向受信任的GPG密钥。</span></p><pre class="brush:bash;toolbar:false">yum-config-manager&nbsp;--add-repo=&quot;http://dl.fedoraproject.org/pub/epel/beta/7/x86_64/&quot;&nbsp;&nbsp;&nbsp;&nbsp;#增加epel的源，</pre><p><span style="font-family: 宋体, SimSun">执行完修改/etc/yum.repos.d/下生成的配置文件，提供自定义名称和GPG密钥位置。管理员应将该密钥下载到本地文件，而不是让yum从外部来源检索该密钥。</span></p><p><span style="font-family: 宋体, SimSun">安装Red Hat Enterprise Linux 7 EPEL存储库软件包:(默认提供配置文件、GPG公钥做为软件安装包的一部分)</span></p><p><span style="font-family: 宋体, SimSun"></span></p><pre class="brush:bash;toolbar:false">rpm&nbsp;--import&nbsp;http://dl.fedoraproject.org/pub/epep/RPM-KEY-EPEL-7&nbsp;&nbsp;&nbsp;&nbsp;
#如果不先安装GPG密钥安装软件时会报错，可以通过--nogpgcheck&nbsp;忽略检查，不推荐这样操作。
yum&nbsp;install&nbsp;http://dl.fedoraproject.org/pub/epep/beta/7/x86_64/epel-release-7-0.1.noarch.rpm</pre><p><span style="font-family: 宋体, SimSun">配置文件通常在一个文件中列举多个存储库引用。每一存储库引用的开头为包含在方括号里的单一词语名称。可以通过“enabled=0 ”参数来关闭不需要使用的存储库。</span></p><p><span style="font-family: 宋体, SimSun"></span></p><pre class="brush:bash;toolbar:false">yum-config-manager&nbsp;#永久的启用或禁用存储库
yum&nbsp;--enablerepo=PATTERN&nbsp;
yum&nbsp;--disablerepo=PATTERN&nbsp;
yum-config-manager&nbsp;--disable&nbsp;content.example.com_rhel7.0_x86_64_rht&nbsp;&nbsp;&nbsp;&nbsp;
#content.example.com_rhel7.0_x86_64_rht&nbsp;通过yum&nbsp;repolist&nbsp;查看</pre><p><span style="font-size: 24px;font-family: 宋体, SimSun">rpm </span><br /></p><pre class="brush:bash;toolbar:false">rpm&nbsp;-q&nbsp;PACKAGENAME&nbsp;&nbsp;&nbsp;&nbsp;#查看指定安装的软件名称，列出软件包的名称和版本，与yum&nbsp;list&nbsp;类似
rpm&nbsp;-qa&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#查看所有安装的软件
rpm&nbsp;-q&nbsp;-p&nbsp;PACKAGENAME.rpm&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#-p&nbsp;指定安装软件包文件
rpm&nbsp;-q&nbsp;-f&nbsp;filename&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#查看哪个软件包提示了这个文件或文件夹
rpm&nbsp;-q&nbsp;-i&nbsp;:软件包信息与yum&nbsp;info&nbsp;类似
rpm&nbsp;-q&nbsp;-l&nbsp;:&nbsp;&nbsp;&nbsp;&nbsp;rpm&nbsp;-q&nbsp;-l&nbsp;yum-rhn-plugin&nbsp;&nbsp;&nbsp;&nbsp;#列出指定软件安装产生的文件
rpm&nbsp;-q&nbsp;-c：&nbsp;&nbsp;&nbsp;&nbsp;rpm&nbsp;-q&nbsp;-c&nbsp;yum-rhn-plugin&nbsp;&nbsp;&nbsp;&nbsp;#仅列出配置文件。
rpm&nbsp;-q&nbsp;-d:&nbsp;&nbsp;&nbsp;&nbsp;rpm&nbsp;-q&nbsp;-d&nbsp;yum-rhn-plugin&nbsp;&nbsp;&nbsp;&nbsp;#仅列出文档文件
rpm&nbsp;-q&nbsp;--scripts&nbsp;:&nbsp;&nbsp;&nbsp;&nbsp;rpm&nbsp;-q&nbsp;--scripts&nbsp;openssh-server&nbsp;&nbsp;&nbsp;&nbsp;#列出可能在安装或删除软件之前或之后运行的shell脚本
rpm&nbsp;-q&nbsp;--changelog&nbsp;:&nbsp;&nbsp;&nbsp;&nbsp;rpm&nbsp;-q&nbsp;--changlog&nbsp;audit&nbsp;&nbsp;&nbsp;&nbsp;#列出软件包的更改信息</pre><p><span style="font-family: 宋体, SimSun">cpio 从rpm包提示文件而不安装该软件包。rpm2cpio PACKAGERFILE.rpm 传送到cpio -id ，它会提取RPM中存储的所有文件。需要时会创建子目录树，也可以指定目录。</span></p><pre class="brush:bash;toolbar:false">rpm2cpio&nbsp;wonderwidgets-1.0-4.x86_64.rpm&nbsp;|&nbsp;cpio&nbsp;-id&nbsp;&quot;*.txt&quot;</pre><p><span style="font-family: 宋体, SimSun"></span><br /></p><p><br /></p><p><span style="font-family: 宋体, SimSun"><br /></span></p><p><span style="font-family: 宋体, SimSun"></span><br /></p>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>173</wp:post_id>
		<wp:post_date><![CDATA[2018-04-17 08:49:48]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-04-17 00:49:48]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[chatper-13-installing-and-updating-software-packages]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="rhel124"><![CDATA[RHEL124]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[hestia_layout_select]]></wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_old_date]]></wp:meta_key>
			<wp:meta_value><![CDATA[2018-04-16]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Chapter 14. Accessing Linux File System</title>
		<link>https://www.rhel.tk/2018/04/17/chapter-14-accessing-linux-file-system/</link>
		<pubDate>Tue, 17 Apr 2018 08:43:24 +0000</pubDate>
		<dc:creator><![CDATA[blogs]]></dc:creator>
		<guid isPermaLink="false">https://www.rhel.tk/?p=183</guid>
		<description></description>
		<content:encoded><![CDATA[<p><span style="font-family: 宋体, SimSun">在Red Hat Enterprise Linux 中检测到的第一个SCSI、PATA/SATA或USB硬盘驱动器是/dev/sda,第二个/dev/sdb，以此类推。</span></p><p><span style="font-family: 宋体, SimSun">/dev/sda 的第一个分区为/dev/sda1,第二个分区为/dev/sda2 ，以此类推。</span></p><p><span style="font-family: 宋体, SimSun">虚拟机中的硬盘驱动器是例外，一般显示了/dev/vd&lt;letter&gt;或/dev/xvd&lt;letter&gt;</span></p><p><span style="font-family: 宋体, SimSun">LVM(逻辑卷管理)，通过LVM一个或多个块设备可以汇集成一个存储池，称为卷组（VG），对于卷组/dev/目录中有一个名称与该卷组相同的目录。在该目录下，已经创建名称与逻辑卷相同的符号链接。例如：代表myvg卷组的myvg逻辑卷的设备文件是/dev/myvg/mylv。</span></p><p><span style="font-family: 宋体, SimSun">LVM依赖于设备映射程序(DM)内核驱动程序。以上符号链接/dev/myvg/mylv 指向/dev/dm-number 块设备节点。number 的分配是连续的。从零（0）开始<br /></span></p><p><span style="font-family: 宋体, SimSun">。每个逻辑卷在/dev/mapper 目录中有另外一个符号链接，名称为/dev/mapper/myvg-mylv。通常可能使用任一可靠且一致的符号链接名称来访问逻辑卷。因为/dev/dm-number名称在每次启动会有所不同。</span></p><p><span style="font-family: 宋体, SimSun">df #显示已经挂载的磁盘空间、已用和剩余，所占比。包括本地和远程</span></p><p><span style="font-family: 宋体, SimSun">tmpfs 和devtmpfs 设备是系统内存中的文件系统，在系统重启后，写入tmpfs或devtmpfs的文件都会消失。</span></p><p><span style="font-family: 宋体, SimSun"></span></p><pre class="brush:bash;toolbar:false">df&nbsp;-h&nbsp;&nbsp;&nbsp;&nbsp;#报告单位是KiB(210),MiB(220),GiB(230)
df&nbsp;-H&nbsp;&nbsp;&nbsp;&nbsp;#报告单位是KB(103),MB(106),GB(109)硬盘驱动器制造商在广告其产品时通常使用SI单位。
du&nbsp;-h&nbsp;dir&nbsp;&nbsp;&nbsp;&nbsp;#以递归方式查看特定目录空间详细信息，-h&nbsp;同df
du&nbsp;-H&nbsp;dir&nbsp;&nbsp;&nbsp;&nbsp;#以递归方式查看特定目录空间详细信息，-H&nbsp;同df</pre><p><span style="font-family: 宋体, SimSun">mount 挂载的两种方式:一、驻留在/dev中的设备文件。二、文件系统的通用唯一标识符：UUID。</span></p><p><span style="font-family: 宋体, SimSun">blkid 命令用来列出其上具体文件系统的现有分区和文件系统的UUID，以后用于格式化该分区的文件系统。</span><br /></p><pre class="brush:bash;toolbar:false">[root@server0&nbsp;Desktop]#&nbsp;blkid
/dev/sda1:&nbsp;UUID=&quot;9bf6b9f7-92ad-441b-848e-0257cbb883d1&quot;&nbsp;TYPE=&quot;xfs&quot;</pre><pre class="brush:bash;toolbar:false">#根据分区的设备文件
mount&nbsp;/dev/vdb1&nbsp;/mnt/mydata
#根据通用唯一标识符UUID
mount&nbsp;UUID=&quot;9bf6b9f7-92ad-441b-848e-0257cbb883d1&quot;&nbsp;/mnt/mydata</pre><p><span style="color: #FF0000;font-family: 宋体, SimSun">如果将文件挂载到现有的目录且这个目录不为空，则这个目录下的文件在挂载后不可访问</span></p><pre class="brush:bash;toolbar:false">umount&nbsp;挂载点&nbsp;&nbsp;&nbsp;&nbsp;#卸载文件系统。</pre><p><span style="font-family: 宋体, SimSun;color: #000000">1、当前处理挂载系统下无法卸载，解决办法：退出当前挂载点<br /></span></p><p><span style="font-family: 宋体, SimSun;color: #000000">2、有进程在使用当前挂载点，无法卸载。解决办法：结束进程</span></p><pre class="brush:bash;toolbar:false">lsof&nbsp;/mnt/mydata&nbsp;&nbsp;&nbsp;&nbsp;#命令列出拨给目录中所有打开的文件以及访问他们的进程。识别哪些进程在阻止文件系统被成功卸载非常有用。</pre><p><span style="font-family: 宋体, SimSun;color: #000000">图形桌面环境针对USB闪存设备和驱动器等可移动设备会自动挂载，可移动介质的挂载点是/run/media/&lt;user&gt;/&lt;label&gt;</span></p><p><span style="font-family: 宋体, SimSun;color: #000000"></span></p><hr /><p><span style="font-family: 宋体, SimSun;font-size: 36px">软链接和硬链接</span></p><p><span style="font-family: 宋体, SimSun">硬链接：硬链接是新的目录条目，其引用文件系统中的现有文件。指向同一文件内容的硬链接<span style="font-family: 宋体, SimSun;color: #FF0000">需要在相同的文件系统中</span>。硬链接具有相同的权限 、链接数、用户/组权限、时间戳、以及文件内容。在文件权限后面，所有者前面的数字为硬链接数。</span><br /></p><p><span style="font-family: 宋体, SimSun;color: #000000">ln 命令为现在文件创建新的硬链接。该命令需要一个现在文件作为第一参数，后面可以跟一个或多个额外的硬连接。新硬链接创建后无法区别哪一个是现有硬连接的原始链接。使用ls -l 查看时文件类型都是文件。<br /></span></p><pre class="brush:bash;toolbar:false">[root@server0&nbsp;newspace]#&nbsp;echo&nbsp;&quot;Hello&quot;&nbsp;&gt;file1.txt
[root@server0&nbsp;newspace]#&nbsp;ln&nbsp;file1.txt&nbsp;file2.txt
[root@server0&nbsp;newspace]#&nbsp;ll
total&nbsp;8
-rw-r--r--.&nbsp;2&nbsp;root&nbsp;root&nbsp;&nbsp;6&nbsp;Apr&nbsp;17&nbsp;15:00&nbsp;file1.txt
-rw-r--r--.&nbsp;2&nbsp;root&nbsp;root&nbsp;&nbsp;6&nbsp;Apr&nbsp;17&nbsp;15:00&nbsp;file2.txt
drwxr-xr-x.&nbsp;2&nbsp;root&nbsp;root&nbsp;20&nbsp;Apr&nbsp;17&nbsp;14:46&nbsp;newdir
[root@server0&nbsp;newspace]#&nbsp;cat&nbsp;file2.txt&nbsp;
Hello
[root@server0&nbsp;newspace]#&nbsp;echo&nbsp;&#039;World&#039;&nbsp;&gt;&gt;&nbsp;file1.txt&nbsp;
[root@server0&nbsp;newspace]#&nbsp;cat&nbsp;file2.txt&nbsp;
Hello
World
[root@server0&nbsp;newspace]#&nbsp;rm&nbsp;-rf&nbsp;file1.txt&nbsp;
[root@server0&nbsp;newspace]#&nbsp;cat&nbsp;file2.txt&nbsp;
Hello
World
[root@server0&nbsp;newspace]#&nbsp;
#创建硬连接后，只要一个文件内容改变其它的跟着改变，且删除其中一个硬链接后不会影响其它链接，内容依然可用。</pre><p><span style="font-family: 宋体, SimSun;color: #000000">ls -s 命令创建软链接，也称为符号链接。软件连接是特殊的文件类型，它指向现在的文件或目录，软链接可以指向其它文件系统中的文件或目录。</span></p><img src="/wp-content/uploads/image/20180417/1523949252627674.png" title="1523949252627674.png" alt="图片.png" /><span style="font-family: 宋体, SimSun;color: #000000"></span><p><span style="font-family: 宋体, SimSun;color: #000000">当原始文件被删除后，软链接依然会指向该文件，但目标已经消失。指向缺失的文件的软链接称为：“悬挂的软链接”，查看时会提示文件或目录不存在。</span></p><p><span style="font-family: 宋体, SimSun;color: #000000"><img src="/wp-content/uploads/image/20180417/1523949409259777.png" title="1523949409259777.png" alt="图片.png" /><br /></span></p><p><span style="font-family: 宋体, SimSun;color: #000000">软链接指向目录时，可通过cd dir 进入到newdir/目录下。</span></p><p><span style="font-family: 宋体, SimSun;color: #000000"></span></p><hr /><p><span style="font-family: 宋体, SimSun;font-size: 36px">find and locate 查找文件<br /></span></p><p><span style="font-family: 宋体, SimSun">locate 命令根据locate 数据库中的文件名和路径返回搜索结果。该数据库存储文件名和路径信息。</span></p><p><span style="font-family: 宋体, SimSun">调用locate搜索的用户必须对包含匹配元素的目录树具有读取权限才会有返回结果。</span></p><p><span style="font-family: 宋体, SimSun"></span></p><pre class="brush:bash;toolbar:false">locate&nbsp;passwd&nbsp;&nbsp;&nbsp;&nbsp;#查找文件名和路径包含passwd文件和目录
locate&nbsp;-i&nbsp;messages&nbsp;&nbsp;&nbsp;&nbsp;#不区分大小写查找包含messages的文件和目录
locate&nbsp;-n&nbsp;5&nbsp;snow.png&nbsp;&nbsp;&nbsp;&nbsp;#查找前5个匹配的文件或目录
updatedb&nbsp;&nbsp;&nbsp;&nbsp;#更新locate数据库，默认每天自动更新。root用户可以updatedb手动更新。</pre><p><span style="font-family: 宋体, SimSun">find 命令实时搜索，查找符合命令行参数条件的文件。调用find搜索的用户必须对包含匹配元素的目录树具有读取权限才会有返回结果。find 的第一个参数为目录，如果缺省则默认为当前目录，并在当前目录树下搜索。<span style="font-family: 宋体, SimSun">find 可以根据文件名、文件大小、最近修改时间戳和其他文件特性的任意组合进行搜索。</span></span></p><p><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"></span></span></p><pre class="brush:bash;toolbar:false">find&nbsp;/&nbsp;-name&nbsp;sshd_config&nbsp;&nbsp;&nbsp;&nbsp;#在/根目录和所有子目录中搜索名为sshd_config的文件
find&nbsp;/&nbsp;-name&nbsp;&#039;*.txt&#039;&nbsp;&nbsp;&nbsp;&nbsp;#在/根目录和所有子目录中搜索以‘.txt’结尾的文件
find&nbsp;/etc&nbsp;-name&nbsp;&#039;*pass*&#039;&nbsp;&nbsp;&nbsp;&nbsp;#在/etc目录和所有子目录中搜索名称中包含pass的文件
find&nbsp;/&nbsp;-iname&nbsp;&#039;*messages*&#039;&nbsp;&nbsp;&nbsp;&nbsp;#-iname&nbsp;不区分大小写，在/根目录和所有子目录中搜索名称中包含‘messages’的文件</pre><p><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"></span></span></span></span></span></span><br /></p><p><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"></span></span></span></span></span></span></p><pre class="brush:bash;toolbar:false">find&nbsp;-user&nbsp;student&nbsp;&nbsp;&nbsp;&nbsp;#在当前目录查找student用户拥有的文件
find&nbsp;-group&nbsp;student&nbsp;&nbsp;&nbsp;&nbsp;#在当前目录查找student组拥有的文件
find&nbsp;-uid&nbsp;1000&nbsp;&nbsp;&nbsp;&nbsp;#在当前目录查找uid为1000拥有的文件
find&nbsp;-gid&nbsp;1000&nbsp;&nbsp;&nbsp;&nbsp;#在当前目录查找gid为1000拥有的文件
find&nbsp;/&nbsp;-user&nbsp;root&nbsp;-group&nbsp;mail&nbsp;&nbsp;&nbsp;&nbsp;#在/根目录下搜索root用户和mail组拥有的文件（同时）</pre><p><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"></span></span></span></span></span></span></span></span></span></span></span></span><br /></p><p><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"></span></span></span></span></span></span></span></span></span></span></span></span></p><pre class="brush:bash;toolbar:false;">find&nbsp;/home&nbsp;-perm&nbsp;764&nbsp;&nbsp;&nbsp;&nbsp;#在home目录下查找文件完全匹配权限为764的文件，777不满足
find&nbsp;/home&nbsp;-perm&nbsp;-324&nbsp;&nbsp;&nbsp;&nbsp;#在home目录下查找文件对应权限至少包含324的文件，三个权限位置对应满足。
find&nbsp;/home&nbsp;-perm&nbsp;/442&nbsp;&nbsp;&nbsp;&nbsp;#在home目录下查找文件中三个权限任何一位有4或2权限的文件
find&nbsp;/home&nbsp;-perm&nbsp;-004&nbsp;&nbsp;&nbsp;&nbsp;#在home目录下查找其它人至少具有读权限的文件
find&nbsp;/home&nbsp;-perm&nbsp;-002&nbsp;&nbsp;&nbsp;&nbsp;#在home目录下查找其它人至少具有写权限的文件

#-perm&nbsp;选项用于查找具体特定权限集的文件，权限可以描述为八进制值，包含代表读取、写入和执行的4、2和1的某些组合，权限前面可以加上/或-符号。
#前面带有/的数字权限将匹配文件用户、组、其它人权限集中的至少一位。权限为r--r--r--的文件并不匹配/222，rw-r--r--的文件才匹配。即大于或等于其它中一位即为匹配。
#前面带有-的数字权限表示所有三个权限都必须存在。-222&nbsp;只有rw-rw-rw才能匹配。默认值。
#&nbsp;与&nbsp;/&nbsp;或&nbsp;-&nbsp;一起使用时&nbsp;0&nbsp;值类似于通配符。因为其表示至少无任何内容权限。</pre><p><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><br /><p><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><pre class="brush:bash;toolbar:false">find&nbsp;/home&nbsp;-size&nbsp;10M&nbsp;&nbsp;&nbsp;&nbsp;#查找文件大小等于10M的文件，单位有k(小),M,G，+10M表示大于，-10M表示小于。
find&nbsp;/home&nbsp;-size&nbsp;+10M&nbsp;&nbsp;&nbsp;&nbsp;#-size&nbsp;单位修饰符将所有内容向上取整为一个单位，find&nbsp;-size&nbsp;1M&nbsp;将显示
find&nbsp;/home&nbsp;-size&nbsp;-10M&nbsp;&nbsp;&nbsp;&nbsp;#小于1M的文件。向上取整为1M，尽量使用小单位。如查找1M文件使用或1024k</pre><pre class="brush:bash;toolbar:false">find&nbsp;/&nbsp;-mmin&nbsp;120&nbsp;&nbsp;&nbsp;&nbsp;#查找正好在前120分钟修改的所有文件
find&nbsp;/&nbsp;-mmin&nbsp;+200&nbsp;&nbsp;&nbsp;&nbsp;#查找200分钟外修改的所有文件,同时也是200分钟内没有修改过的
find&nbsp;/&nbsp;-mmin&nbsp;-150&nbsp;&nbsp;&nbsp;&nbsp;#查找在150分内修改的所有文件</pre><pre class="brush:bash;toolbar:false">find&nbsp;/&nbsp;-type&nbsp;&nbsp;&nbsp;&nbsp;#f:普通文件，d:目录，l：软链接，b:块设备
find&nbsp;/etc&nbsp;-type&nbsp;d&nbsp;&nbsp;&nbsp;&nbsp;#查找etc/目录下的文件夹
find&nbsp;/&nbsp;-type&nbsp;l&nbsp;&nbsp;&nbsp;&nbsp;#查找/根目录下的所有软链接
find&nbsp;/&nbsp;-type&nbsp;f&nbsp;-links&nbsp;+1&nbsp;&nbsp;&nbsp;&nbsp;#查找/目录下类型为文件，硬链接大于1个的文件。+：大于，-：小于</pre><p><br /></p><br /><p><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><br /></span></span></span></span></span></span></span></span></span></span></span></span></p><p><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun"><br /></span></span></p><p><br /></p><p><br /></p><p><span style="font-family: 宋体, SimSun;color: #000000"></span><br /></p>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>183</wp:post_id>
		<wp:post_date><![CDATA[2018-04-17 16:43:24]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-04-17 08:43:24]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[chapter-14-accessing-linux-file-system]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="rhel124"><![CDATA[RHEL124]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[hestia_layout_select]]></wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Chapter 15. Using virtualized system</title>
		<link>https://www.rhel.tk/2018/04/18/chapter-15-using-virtualized-system/</link>
		<pubDate>Wed, 18 Apr 2018 02:57:03 +0000</pubDate>
		<dc:creator><![CDATA[blogs]]></dc:creator>
		<guid isPermaLink="false">https://www.rhel.tk/?p=187</guid>
		<description></description>
		<content:encoded><![CDATA[<p><span style="font-family: 宋体, SimSun">KVM(基于内核的虚拟机)是标准Red Hat Enterprise Linux 内核中内置的完整虚拟化解决方案。它可以运行多款未经修改的Windows 和Linux 虚拟客户操作系统。Red Hat Enterprise Linux中的KVM系统管理程序通过libvirt API 和实用程序进行管理。如virt-manager 和virsh等。由于Red Hat Enterprise Linux 是红帽企业虚拟化和红帽OpenStack 平台的基础。因此KVM是红帽云基础架构多种产品的一致组件。</span></p><p><img src="/wp-content/uploads/image/20180418/1524011869875353.png" title="1524011869875353.png" alt="图片.png" /></p><ul style="list-style-type: disc" class=" list-paddingleft-2"><li><p><span style="font-family: 宋体, SimSun">KVM提供横跨所有红帽产品的虚拟机（VM）技术，不仅包含Red Hat Enterprise Linux 的单机物理实例，更有OpenStack 云平台。从上图的左上角起：</span></p></li><li><p><span style="font-family: 宋体, SimSun">物理（传统）系统-Red Hat Enterprise Linux 安装在传统硬件上，提供KVM虚拟化，最高可达单一系统的物理极限，并且由virt-manager 等libvirt实用程序进程管理。Red Hat Enterprise Linux 实例也可通过红帽云访问。直接托管在红帽认证云提供商处。</span></p></li><li><p><span style="font-family: 宋体, SimSun">红帽企业Linux 通常配置为胖主机，即在支持VM的同时，也提供其他本地和网络服务、应用和管理功能。</span></p></li><li><p><span style="font-family: 宋体, SimSun">红帽企业虚拟化（RHEV）--支持跨越多个红帽企业虚拟化系统管理程序 （RHEV-H）系统的KVM实例。提供由RHEV管理（RHEV-H）管理的KVM迁移、冗余和高可用性。</span></p></li><li><p><span style="font-family: 宋体, SimSun">红帽企业虚拟化系统管理程序 是瘦主机，是专门精简和调优过的Red Hat Enterprise Linux 版本，专用于满足和支持虚拟客户机VM的唯一目的。</span></p></li><li><p><span style="font-family: 宋体, SimSun">RHEL OpenStack平台——在带有KVM的Red Hat Enterprise Linux 基础上使用集成和调优的OpenStack 的红帽私有云架构，通过红帽OpenStack 仪表板（Horizon 组件）或红帽 CloudForms 进程管理。</span></p></li><li><p><span style="font-family: 宋体, SimSun">公共云中的OpenStack——在红帽认证云提供商处实施的OpenStack 公共云架构，由OpenStack Horizon 组件或红帽 CloudForms进行管理。</span></p></li><li><p><span style="font-family: 宋体, SimSun">混合云——红帽CloudForms 云管理实用程序管理和迁移红帽RHEV和OpenStack 架构之间的KVM实例，以及通过第三方OpenStack和VMware平台转换KVM实例。</span></p></li><li><p><span style="font-family: 宋体, SimSun">KVM实例配置在红帽产品之间兼容。安装要求、参数和步骤在受支持的平台上相当的。</span></p></li></ul><p><span style="font-family: 宋体, SimSun">KVM系统管理程序需要Intel 处理器（Intel VT-x 和基于X86 的系统的Intel 64扩展），或者AMD处理器（AMD-V 及AMD64扩展）。验证是否支持可能通过：</span></p><pre class="brush:bash;toolbar:false">grep&nbsp;--color&nbsp;-E&nbsp;&quot;vmx|svm&quot;&nbsp;/proc/cpuinfo</pre><p><span style="font-family: 宋体, SimSun"></span><br /></p><p><span style="font-family: 宋体, SimSun">在Red Hat Enterprise Linux 上构建主机时并不需要No eXecute (NX)功能（Intel 称之为eXecute Disable(XD),AMD则称之为Enhanced Virus Protection）,但是红帽企业虚拟化系统管理程序（RHEV-H）需要此功能。<br /></span></p><pre class="brush:bash;toolbar:false">grep&nbsp;--color&nbsp;-E&nbsp;&quot;nx&quot;&nbsp;/proc/cpuinfo</pre><p><span style="font-family: 宋体, SimSun"></span><br /></p><p><span style="font-family: 宋体, SimSun">构建RHEL虚拟化主机至少需要qemu-kvm和qemu-img软件包，以提供用户级KVM模拟器和磁盘映像管理器</span></p><pre class="brush:bash;toolbar:false">yum&nbsp;install&nbsp;qemu-kvm&nbsp;qemu-img</pre><p><span style="font-family: 宋体, SimSun"></span><br /></p><p><span style="font-family: 宋体, SimSun">建议安装的其它虚拟化管理软件包有：</span></p><ul style="list-style-type: disc" class=" list-paddingleft-2"><li><p><span style="font-family: 宋体, SimSun">python-virtinst —— 提供virt-install命令，供创建虚拟机使用</span></p></li><li><p><span style="font-family: 宋体, SimSun">libvirt —— 提供主机和服务库，以便与系统管理程序和主机系统交互<br /></span></p></li><li><p><span style="font-family: 宋体, SimSun">libvirt-python —— 包含允许Python应用使用libvirt API的模块<br /></span></p></li><li><p><span style="font-family: 宋体, SimSun">virt-manager —— 为管理VM提供虚拟机管理器图形工具，将libvirt-client库用作管理<br /></span></p></li><li><p><span style="font-family: 宋体, SimSun">libvirt-client —— 为访问libvirt服务器提供客户端API和库，以及用于管理和控制VM的virsh命令行工具。<br /></span></p></li></ul><pre class="brush:bash;toolbar:false">yum&nbsp;install&nbsp;python-virtinst&nbsp;libvirt&nbsp;libvirt-python&nbsp;virt-manager&nbsp;libvirt-client</pre><p><span style="font-family: 宋体, SimSun">RHEL7 更新版anaconda图形安装程序 ，安装程序时不再提供选择个别RPM软件的功能，而只能选择基地环境和适合于所选基础的附加程。因而消除了猜测、使用配置更加精简。在安装完成后依然可能通过rmp 、yum或GNOME PackageKit 安装其他所需的RPM软件包。 <br /></span></p><p><span style="font-family: 宋体, SimSun"><br /></span></p><p><span style="font-family: 宋体, SimSun">Red Hat Enterprise Linux 使用基于libvirt的工具，作为虚拟化管理的默认方式。其支持RHEL 5 Xen 系统管理程序，以及RHEL 5、6和7上的KVM。下列管理工具使用libvirt:</span></p><ul style="list-style-type: disc" class=" list-paddingleft-2"><li><p><span style="font-family: 宋体, SimSun">virsh —— virsh 命令行管理工具是图形版 virt-manager 应用程序的代替工具。无特权用户能以只读模式使用模式virsh，或者通过root 访问权限使用完整的管理功能。virsh命令是编写虚拟化管理脚本的理想选择。</span></p></li><li><p><span style="font-family: 宋体, SimSun">virt-manager —— virt-manager 是一款图形化桌面工具，可以访问虚拟客户机控制台，用于执行虚拟机创建、迁移、配置和管理任务。可以通过单一界面管理本地和远程系统。</span></p></li><li><p><span style="font-family: 宋体, SimSun">RHEV-M —— 红帽企业虚拟化管理器为物理和虚拟资源提供一个中央化管理平台，允许在主机之间启用、停止、构建和迁移虚拟机。RHEV-M 也可以管理数据中心的存储和网络组件，提供安全的远程图形化虚拟客户机控制台访问方式。</span></p><p><span style="font-family: 宋体, SimSun"></span></p></li></ul><p><span style="font-family: 宋体, SimSun">virsh 作为交互式shell使用:</span></p><p><span style="font-family: 宋体, SimSun">list —— 查看，--all 可查看全部<br /></span></p><p><span style="font-family: 宋体, SimSun">destroy —— 强制关闭，后面跟虚机名，与将其拔出相似<br /></span></p><p><span style="font-family: 宋体, SimSun">stop —— 暂时运行，后面<span style="font-family: 宋体, SimSun">跟虚机名</span></span></p><p><span style="font-family: 宋体, SimSun">start —— 启动虚机，后面<span style="font-family: 宋体, SimSun">跟虚机名</span></span></p><p><span style="font-family: 宋体, SimSun">edit —— <span style="font-family: 宋体, SimSun">编辑域的配置文件，这会在虚拟客户机下一次</span>启动时产生作用</span></p><p><span style="font-family: 宋体, SimSun">connect —— 使用qemu://host 语法连接本地或远程KVM主机。<br /></span></p><p><span style="font-family: 宋体, SimSun">nodeinfo —— 返回主机的基地信息，如CPU和内存等。<br /></span></p><p><span style="font-family: 宋体, SimSun">autostart —— 将KVM域配置为在主机系统启动时启动。<br /></span></p><p><span style="font-family: 宋体, SimSun">console —— 连接到虚拟客户机的虚拟串行控制台。<br /></span></p><p><span style="font-family: 宋体, SimSun">create —— 从XML 配置文件创建域，并将它启动。<br /></span></p><p><span style="font-family: 宋体, SimSun">define —— 从XML 配置谁的创建域，但不启动它。<br /></span></p><p><span style="font-family: 宋体, SimSun">undefine —— 取消定义域。如果域为不活动，则域配置将被删除。<br /></span></p><p><span style="font-family: 宋体, SimSun">reboot —— 重新启动域，就如从客户机内部运行reboot 命令一样<br /></span></p><p><span style="font-family: 宋体, SimSun">shutdown —— 正常地关闭域，就如从虚拟客户机内部运行shutdown 一样。<br /></span></p><p><span style="font-family: 宋体, SimSun">screenshot —— 为当前域控制台抓取屏幕截图，并存储在文件中。 <br /></span></p><p><span style="font-family: 宋体, SimSun"><br /></span></p><p><span style="font-family: 宋体, SimSun"></span></p><table><tbody><tr class="firstRow"><td class="selectTdClass" style="border-width: 1px;border-style: solid" valign="top">配置说明<br /></td><td class="selectTdClass" style="border-width: 1px;border-style: solid" valign="top">红帽产品<br /></td></tr><tr><td class="selectTdClass" style="border-width: 1px;border-style: solid" valign="top">提供KVM支持的单系统硬件<br /></td><td class="selectTdClass" style="border-width: 1px;border-style: solid" valign="top">红帽企业Linux<br /></td></tr><tr><td class="selectTdClass" style="border-width: 1px;border-style: solid" valign="top">提供虚拟化冗余的多系统硬件<br /></td><td class="selectTdClass" style="border-width: 1px;border-style: solid" valign="top">红帽企业虚拟化<br /></td></tr><tr><td class="selectTdClass" style="border-width: 1px;border-style: solid" valign="top">提供私有云的多系统硬件<br /></td><td class="selectTdClass" style="border-width: 1px;border-style: solid" valign="top">RHEL OpenStack平台<br /></td></tr><tr><td class="selectTdClass" style="border-width: 1px;border-style: solid" valign="top">提供公共云的云提供商<br /></td><td class="selectTdClass" style="border-width: 1px;border-style: solid" valign="top">公共云中的OpenStack<br /></td></tr><tr><td class="selectTdClass" style="border-width: 1px;border-style: solid" valign="top">用于独立KVM主机的管理实用程序<br /></td><td class="selectTdClass" style="border-width: 1px;border-style: solid" valign="top">virt-manager<br /></td></tr><tr><td class="selectTdClass" style="border-width: 1px;border-style: solid" valign="top">用于多主机虚拟化平台的管理实用程序<br /></td><td class="selectTdClass" style="border-width: 1px;border-style: solid" valign="top">RHEV-M<br /></td></tr><tr><td class="selectTdClass" style="border-width: 1px;border-style: solid" valign="top">用于所有虚拟化和云平台组合的管理实用程序<br /></td><td class="selectTdClass" style="border-width: 1px;border-style: solid" valign="top">CloudForms<br /></td></tr></tbody></table><p><span style="font-family: 宋体, SimSun"></span><br /></p><p><span style="font-family: 宋体, SimSun"><br /></span></p><p><br /></p><p><br /></p>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>187</wp:post_id>
		<wp:post_date><![CDATA[2018-04-18 10:57:03]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-04-18 02:57:03]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[chapter-15-using-virtualized-system]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="rhel124"><![CDATA[RHEL124]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[hestia_layout_select]]></wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_page_template]]></wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Chapter 7. Monitoring and Managing Linux Processes</title>
		<link>https://www.rhel.tk/2018/04/19/chapter-7-monitoring-and-managing-linux-processes/</link>
		<pubDate>Thu, 19 Apr 2018 03:24:41 +0000</pubDate>
		<dc:creator><![CDATA[blogs]]></dc:creator>
		<guid isPermaLink="false">https://www.rhel.tk/?p=195</guid>
		<description></description>
		<content:encoded><![CDATA[<p><span style="font-family: 宋体, SimSun">Linux 版本的ps命令支持三种选项格式，包括：</span></p><ul style="list-style-type: disc" class=" list-paddingleft-2"><li><p><span style="font-family: 宋体, SimSun">UNIX（POSIX）选项，可以分组但必须以连字符（-）开头；</span></p></li><li><p><span style="font-family: 宋体, SimSun">BSD 选项，可以分组但不可与连字符同用；</span></p></li><li><p><span style="font-family: 宋体, SimSun">GNU长选项，以双连字符开关。</span></p></li></ul><p><span style="font-family: 宋体, SimSun">例如：ps -aux 不同于 ps aux</span><br /></p><pre class="brush:bash;toolbar:false">ps&nbsp;&nbsp;&nbsp;aux&nbsp;&nbsp;&nbsp;&nbsp;#显示所有进程，包含用户感兴趣的列，以及没有控制终端的进程。
ps&nbsp;&nbsp;&nbsp;lax&nbsp;&nbsp;&nbsp;&nbsp;#长列表，提供更多详细信息，可以避免查询用户名来加快显示。
ps&nbsp;-ef&nbsp;&nbsp;#显示所有进程。
ps&nbsp;#默认不排序，除非指定-O&nbsp;或者&nbsp;--sort&nbsp;
ps&nbsp;j&nbsp;#显示后台作业信息</pre><pre class="brush:bash;toolbar:false">&nbsp;#&amp;符号放在尾部，放到后台执行的效果，但是如果一行有多个命令，仅将最后一个放后台，除非使用$()括起来。
jobs&nbsp;#显示后台运行的进程，同ps&nbsp;j&nbsp;类似
Ctrl&nbsp;+&nbsp;z&nbsp;#把当前执行的命令放到后台，状态为stopped
bg&nbsp;&nbsp;%id&nbsp;&nbsp;&nbsp;&nbsp;#启动后台指定进程(stopped--&gt;running)
fg&nbsp;&nbsp;&nbsp;%id&nbsp;&nbsp;&nbsp;&nbsp;#指定后台进来显示在前台</pre><pre class="brush:bash;toolbar:false">vmstat&nbsp;2&nbsp;10&nbsp;&nbsp;&nbsp;&nbsp;#2秒刷新显示10次
top
&nbsp;&nbsp;&nbsp;&nbsp;M&nbsp;&nbsp;#按内存排序
&nbsp;&nbsp;&nbsp;&nbsp;K&nbsp;&nbsp;&nbsp;&nbsp;#结束进程
free&nbsp;-m
cat&nbsp;/proc/cpuinfo
uptime
grep&nbsp;&quot;model&nbsp;name&quot;&nbsp;/proc/cpuinfo
gnome-system-monitor</pre><p><span style="font-family: 宋体, SimSun">top 各列含义：</span></p><ul style="list-style-type: disc" class=" list-paddingleft-2"><li><p><span style="font-family: 宋体, SimSun">用户名称(user)，是进程所有者<br /></span></p></li><li><p><span style="font-family: 宋体, SimSun">虚拟内存(virt)，是进程正在使用的所有内存，包括常驻集合、共享库，以及任何映射或交换的内存页。（PS命令中为VSZ）<br /></span></p></li><li><p><span style="font-family: 宋体, SimSun">常驻内存(res)，是进程所用的物理内存，包括任何驻留的共享对象。（PS命令中为rss）</span></p></li><li><p><span style="font-family: 宋体, SimSun">进程状态(s)</span></p></li></ul><p><span style="font-family: 宋体, SimSun"></span></p><p style="font-size:15px"><span style="font-family: 宋体, SimSun">&nbsp;&nbsp;&nbsp;&nbsp;D=不间断的睡眠uninterruptable sleeping</span></p><p style="font-size:15px"><span style="font-family: 宋体, SimSun"><span style="font-family: Calibri">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R=</span>运行或可运行<span style="font-family: Calibri">running or runnable</span></span></p><p style="font-size:15px"><span style="font-family: 宋体, SimSun"><span style="font-family: Calibri">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;S=</span>睡眠<span style="font-family: Calibri">sleeping</span></span></p><p style="font-size:15px"><span style="font-family: 宋体, SimSun"><span style="font-family: Calibri">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;T=</span>停止或追踪<span style="font-family: Calibri">stopped or traced</span></span></p><p style="font-size:15px"><span style="font-family: 宋体, SimSun"><span style="font-family: Calibri">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Z=</span>僵尸<span style="font-family: Calibri">zombie</span></span></p><p><span style="font-family: 宋体, SimSun"><br /></span><br /></p><p><span style="font-family: 宋体, SimSun">Ctrl-z(暂停，转后台)，Ctrl-c（中断），Ctrl-d (终止)</span><br /></p><pre class="brush:bash;toolbar:false">kill&nbsp;&nbsp;&nbsp;&nbsp;PID
kill&nbsp;&nbsp;&nbsp;&nbsp;-signal&nbsp;PID
kill&nbsp;&nbsp;&nbsp;&nbsp;-l
killall&nbsp;&nbsp;&nbsp;command_pattern
killall&nbsp;&nbsp;-signal&nbsp;command_pattern
killall&nbsp;&nbsp;&nbsp;-signal&nbsp;-u&nbsp;username&nbsp;command_pattern
pkill&nbsp;&nbsp;&nbsp;&nbsp;command_pattern
pkill&nbsp;&nbsp;&nbsp;&nbsp;-signal&nbsp;command_pattern
pkill&nbsp;&nbsp;&nbsp;-G&nbsp;GID&nbsp;command_pattern
pkill&nbsp;&nbsp;&nbsp;&nbsp;-P&nbsp;PPID&nbsp;command_pattern
pkill&nbsp;-t&nbsp;terminal_name&nbsp;-U&nbsp;UID&nbsp;command_patern
pkill&nbsp;-SIGKILL&nbsp;-u&nbsp;bob&nbsp;#向bob用户发送sigkill&nbsp;指令</pre><p style="font-size:15px"><span style="font-family: 宋体, SimSun"></span></p><pre class="brush:bash;toolbar:false">w&nbsp;-f&nbsp;&nbsp;#显示当前登录的用户，-f显示远程登录系统名称
w&nbsp;&nbsp;-h&nbsp;-u&nbsp;username
pgrep&nbsp;-l&nbsp;-u&nbsp;username
pstree&nbsp;-p&nbsp;username</pre><p style="font-size:15px"><span style="font-family: 宋体, SimSun"></span><br /></p><table><tbody><tr class="firstRow"><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">名称&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">标 志<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">内核定义的状态名称和描述<br /></span></td></tr><tr><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">运行中<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">R<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">TASK_RUNING:进程正在CPU上执行，或者正在等待运行。处于运行中（或可运行）状态时，进程可能正在执行用户作业或内核作业（系统调用），或者已排队并就绪。<br /></span></td></tr><tr><td rowspan="3" colspan="1" style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">睡眠<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">S<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">TASK_INTERRUPTIBLE:进程正在等待某一条件：硬件请求、系统资源访问或信号。当事件或信号满足条件时，该进程将返回到运行中。<br /></span></td></tr><tr><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">D<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">TASK_INTERRUPTIBLE：此进程也在睡眠，但与S状态不同，不会响应传递的信号。仅在特定的条件下使用，其中进程中断可能会导致意外的设备状态。<br /></span></td></tr><tr><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">K<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">TASK_KILLABLE:与不可中断的D状态相同，但有所修改，允许等待中的任务通过响应信号而被中断（彻底退出 ）。实用程序通常将可中断的进程显示为D状态。。<br /></span></td></tr><tr><td rowspan="2" colspan="1" style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">已停止<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">T<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">TASK_STOPPED：进程已被停止（暂停），通常是通过用户或其他进程发出的信号。进程可以通过另一信号返回到运行中状态，继续执行（恢复）<br /></span></td></tr><tr><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">T<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">TASK_TRACED:正在被调试的进程也会临时停止，并且共享同一个T状态标志。<br /></span></td></tr><tr><td rowspan="2" style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">僵停<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">Z<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">EXIT_ZOMBIE：子进程在退出时向父进程发出信号。除进程身份（PID）之外的所有资源都已释放。<br /></span></td></tr><tr><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">X<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">EXIT_DEAD:当父进程清理（获取）剩余的子进程结构时，进程现在已经彻底释放。此状态从不会在进程列出实用程序中看到。<br /></span></td></tr></tbody></table><p style="font-family:Calibri;font-size:16px"><span style="font-family: 宋体, SimSun">使用时可以通过短名称(HUP)或正确的名称（SIGHUP）指代信号<br /></span></p><table><tbody><tr class="firstRow"><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">信号编号<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">短名称<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">定义<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">用途<br /></span></td></tr><tr><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">1<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">HUP<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">挂起<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">用于报告终端控制进程的终止。也用于请求进程重新初始化（重新加载配置）而不终止<br /></span></td></tr><tr><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">2<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">INT<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">键盘中断<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">导致程序终止可以被拦截或处理。通过键盘INTR字符（Ctrl-c）发送<br /></span></td></tr><tr><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">3<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">QUIT<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">键盘退出<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">与SIGINT相似，但也在终止时生成进程转储。通过键入QUIT字符（Ctrl-\）发送。<br /></span></td></tr><tr><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">9<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">KILL<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">中断，无法拦截<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">导致立即终止程序，无法被拦截、忽略或处理；总是致命的。<br /></span></td></tr><tr><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">15（默认）<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">TERM<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">终止<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">导致程序终止。和SIGKILL不同，可以被拦截、忽略或处理。要求程序终止的友好方式；允许自我清理。<br /></span></td></tr><tr><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">18<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">CONT<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">继续<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">发送到进程使其恢复（若已停止）。无法被拦截。即使被处理，也始终恢复进程<br /></span></td></tr><tr><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">19<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">STOP<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">停止，无法拦截<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">暂停进程。无法被拦截或处理<br /></span></td></tr><tr><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">20<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">TSTP<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">键盘终止<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">和SIGSTOP不同，可以被拦截、忽略或处理。通过键入SUSP字符（Ctrl-z）发送。<br /></span></td></tr></tbody></table><p style="font-family:Calibri;font-size:16px"><br /></p><p style="font-family:Calibri;font-size:16px"><span style="font-family: 宋体, SimSun">top中的基本击键操作</span></p><table width="920"><tbody><tr class="firstRow"><td class="selectTdClass" style="border-width: 1px;border-style: solid" width="128" valign="top"><span style="font-family: 宋体, SimSun">键<br /></span></td><td class="selectTdClass" style="border-width: 1px;border-style: solid" width="791" valign="top"><span style="font-family: 宋体, SimSun">用途<br /></span></td></tr><tr><td class="selectTdClass" style="border-width: 1px;border-style: solid" width="128" valign="top"><span style="font-family: 宋体, SimSun">?或h<br /></span></td><td class="selectTdClass" style="border-width: 1px;border-style: solid" width="791" valign="top"><span style="font-family: 宋体, SimSun">交互式击键操作的帮助<br /></span></td></tr><tr><td class="selectTdClass" style="border-width: 1px;border-style: solid" width="128" valign="top"><span style="font-family: 宋体, SimSun">l、t、m<br /></span></td><td class="selectTdClass" style="border-width: 1px;border-style: solid" width="791" valign="top"><span style="font-family: 宋体, SimSun">切换到负载、线程、内存标题行<br /></span></td></tr><tr><td class="selectTdClass" style="border-width: 1px;border-style: solid" width="128" valign="top"><span style="font-family: 宋体, SimSun">1<br /></span></td><td class="selectTdClass" style="border-width: 1px;border-style: solid" width="791" valign="top"><span style="font-family: 宋体, SimSun">标题中切换显示单独CPU信息或所有CPU的汇总。<br /></span></td></tr><tr><td class="selectTdClass" style="border-width: 1px;border-style: solid" width="128" valign="top"><span style="font-family: 宋体, SimSun">s<sup>(1)</sup><br /></span></td><td class="selectTdClass" style="border-width: 1px;border-style: solid" width="791" valign="top"><span style="font-family: 宋体, SimSun">更改刷新（屏幕）率，以带小数的秒数表示（如0.5、1、5）。<br /></span></td></tr><tr><td class="selectTdClass" style="border-width: 1px;border-style: solid" width="128" valign="top"><span style="font-family: 宋体, SimSun">b<br /></span></td><td class="selectTdClass" style="border-width: 1px;border-style: solid" width="791" valign="top"><span style="font-family: 宋体, SimSun">切换反射突出显示运行中的进程；默认为粗体<br /></span></td></tr><tr><td class="selectTdClass" style="border-width: 1px;border-style: solid" width="128" valign="top"><span style="font-family: 宋体, SimSun">B<br /></span></td><td class="selectTdClass" style="border-width: 1px;border-style: solid" width="791" valign="top"><span style="font-family: 宋体, SimSun">在显示中使用粗体，用于标题以运行中的进程。<br /></span></td></tr><tr><td class="selectTdClass" style="border-width: 1px;border-style: solid" width="128" valign="top"><span style="font-family: 宋体, SimSun">H<br /></span></td><td class="selectTdClass" style="border-width: 1px;border-style: solid" width="791" valign="top"><span style="font-family: 宋体, SimSun">切换线程；显示进程摘要或单独线程。<br /></span></td></tr><tr><td class="selectTdClass" style="border-width: 1px;border-style: solid" width="128" valign="top"><span style="font-family: 宋体, SimSun">u,U<br /></span></td><td class="selectTdClass" style="border-width: 1px;border-style: solid" width="791" valign="top"><span style="font-family: 宋体, SimSun">过滤任何用户名称（有效、真实）<br /></span></td></tr><tr><td class="selectTdClass" style="border-width: 1px;border-style: solid" width="128" valign="top"><span style="font-family: 宋体, SimSun">M<br /></span></td><td class="selectTdClass" style="border-width: 1px;border-style: solid" width="791" valign="top"><span style="font-family: 宋体, SimSun">按内存使用率以降序方式对进程列表排序<br /></span></td></tr><tr><td class="selectTdClass" style="border-width: 1px;border-style: solid" width="128" valign="top"><span style="font-family: 宋体, SimSun">P<br /></span></td><td class="selectTdClass" style="border-width: 1px;border-style: solid" width="791" valign="top"><span style="font-family: 宋体, SimSun">按处理器使用率，以降序方式对进程列表排序<br /></span></td></tr><tr><td class="selectTdClass" style="border-width: 1px;border-style: solid" width="128" valign="top"><span style="font-family: 宋体, SimSun">k<span style="font-family: 宋体, SimSun"><sup>(1)</sup></span></span></td><td class="selectTdClass" style="border-width: 1px;border-style: solid" width="791" valign="top"><span style="font-family: 宋体, SimSun">中断进程。若有提示，输入PID，再输入signal<br /></span></td></tr><tr><td class="selectTdClass" style="border-width: 1px;border-style: solid" width="128" valign="top"><span style="font-family: 宋体, SimSun">r<span style="font-family: 宋体, SimSun"><sup>(1)</sup></span></span></td><td class="selectTdClass" style="border-width: 1px;border-style: solid" width="791" valign="top"><span style="font-family: 宋体, SimSun">调整进程的nice值。若有提示，输入PID，再输入nice_value<br /></span></td></tr><tr><td class="selectTdClass" style="border-width: 1px;border-style: solid" width="128" valign="top"><span style="font-family: 宋体, SimSun">W<br /></span></td><td class="selectTdClass" style="border-width: 1px;border-style: solid" width="791" valign="top"><span style="font-family: 宋体, SimSun">写入（保存）当前的显示配置，以便在下一次重新启动top时使用<br /></span></td></tr><tr><td class="selectTdClass" style="border-width: 1px;border-style: solid" width="128" valign="top"><span style="font-family: 宋体, SimSun">q<br /></span></td><td class="selectTdClass" style="border-width: 1px;border-style: solid" width="791" valign="top"><span style="font-family: 宋体, SimSun">退出<br /></span></td></tr><tr><td class="selectTdClass" style="border-width: 1px;border-style: solid" width="128" valign="top"><span style="font-family: 宋体, SimSun">注：<br /></span></td><td class="selectTdClass" style="border-width: 1px;border-style: solid" width="791" valign="top"><span style="font-family: 宋体, SimSun">安全模式中不可用<br /></span></td></tr></tbody></table><p style="font-family:Calibri;font-size:16px">&nbsp;<br /></p><p style="font-family:Calibri;font-size:16px">&nbsp;</p><p style="font-family:Calibri;font-size:16px">&nbsp;</p>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>195</wp:post_id>
		<wp:post_date><![CDATA[2018-04-19 11:24:41]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-04-19 03:24:41]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[chapter-7-monitoring-and-managing-linux-processes]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="rhel124"><![CDATA[RHEL124]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[hestia_layout_select]]></wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_page_template]]></wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Recored  零散记忆</title>
		<link>https://www.rhel.tk/2018/04/20/rh124-recored/</link>
		<pubDate>Fri, 20 Apr 2018 02:11:27 +0000</pubDate>
		<dc:creator><![CDATA[blogs]]></dc:creator>
		<guid isPermaLink="false">https://www.rhel.tk/?p=247</guid>
		<description></description>
		<content:encoded><![CDATA[<p><span style="font-family: 宋体, SimSun">LANG=zh_CN.utf8&nbsp;&nbsp;&nbsp;&nbsp;#设置语言，临时</span></p><p><span style="font-family: 宋体, SimSun">locale&nbsp;&nbsp;&nbsp;&nbsp;#检查语言</span></p><p><span style="font-family: 宋体, SimSun">localectl set-locale LANG=zh_CN.utf8&nbsp;&nbsp;&nbsp;&nbsp;#设备系统默认语言</span></p><p><span style="font-family: 宋体, SimSun">vi /etc/locale.conf&nbsp;&nbsp;&nbsp;&nbsp;#语言的配置文件<br /></span></p><p><span style="font-family: 宋体, SimSun">tty2等本地文件控制台可显示的字体比gnome-terminal和ssh会话受到的局限多。例如，本地文件控制台中的日语、韩语和中文字符显示可能会不正常。因此最好将英语或其它包含拉丁语字符的语言用于系统的文本控制台。类似的，受到的输入法也受到限制比较多。</span></p><p><span style="font-family: 宋体, SimSun">yum install yum-langpacks #先安装才能使用。<br /></span></p><p><span style="font-family: 宋体, SimSun">yum langavaliable &nbsp;&nbsp;&nbsp;&nbsp;#查看系统可用语言包<br /></span></p><p><span style="font-family: 宋体, SimSun">yum langlist</span></p><p><span style="font-family: 宋体, SimSun">yum langinstall code <br /></span></p><p><span style="font-family: 宋体, SimSun"><a href="http://fedoraproject.org/wiki/QA:Langpack_Yum_Application">http://fedoraproject.org/wiki/QA:Langpack_Yum_Application</a><br /></span></p><p><br /></p><pre class="brush:bash;toolbar:false">NCORE=$(&nbsp;grep&nbsp;-c&nbsp;&#039;^processor&#039;&nbsp;/proc/cpuinfo)&nbsp;&nbsp;&nbsp;&nbsp;#查看CPU核数
for&nbsp;I&nbsp;in&nbsp;$(&nbsp;&nbsp;seq&nbsp;$((NCORE*2-1)))&nbsp;&nbsp;&nbsp;&nbsp;#设置for&nbsp;循环，seq&nbsp;生成序列来自NCORE*2-1的值，$((NCORE*2-1))&nbsp;计算&nbsp;NCORE*2-1
do
echo&nbsp;$I
done

grep&nbsp;-c&nbsp;&#039;^processor&#039;&nbsp;/proc/cpuinfo&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#统计匹配到以/proc/cpuinfo中processor&nbsp;开头的数量</pre><p><br /></p>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>247</wp:post_id>
		<wp:post_date><![CDATA[2018-04-20 10:11:27]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-04-20 02:11:27]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[rh124-recored]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="rhel124"><![CDATA[RHEL124]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_page_template]]></wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[hestia_layout_select]]></wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Chapter 1 . Accessing The Command line</title>
		<link>https://www.rhel.tk/2018/04/20/chapter1-accessing-the-command-line/</link>
		<pubDate>Fri, 20 Apr 2018 02:10:20 +0000</pubDate>
		<dc:creator><![CDATA[blogs]]></dc:creator>
		<guid isPermaLink="false">https://www.rhel.tk/?p=250</guid>
		<description></description>
		<content:encoded><![CDATA[<p><span style="font-family: 宋体, SimSun">[root@client ~]# &nbsp;&nbsp;&nbsp;&nbsp;root管理员提示符<br /></span></p><p><span style="font-family: 宋体, SimSun">[client@client ~]$ &nbsp;&nbsp;&nbsp;&nbsp;普通用户提示符</span></p><p><span style="font-family: 宋体, SimSun">&nbsp;&nbsp;&nbsp;&nbsp;如果提供图形环境，它将在Red Hat Enterprise Linux 7 的第一个虚拟控制台中运行。而另外五个文件登录提示符在控制台（tty）二到六（如果图形环境关闭，则为控制台一到五）中可用。在图形环境运行时，通过按住Ctrl+Alt 并按功能键（F2到F6）,来访问虚拟控制台上的文本登录提示符。按Ctrl+Alt+F1返回第一个虚拟控制台和图形桌面。（RHEL5 及之前版本图形运行在第七个虚拟控制台Ctrl+Alt+F7 切换）</span></p><p><span style="font-family: 宋体, SimSun">参数提示符用法：</span></p><ul style="list-style-type: disc" class=" list-paddingleft-2"><li><p><span style="font-family: 宋体, SimSun">[]&nbsp;&nbsp;&nbsp;&nbsp;方括号[]括起来的是可选项目</span></p></li><li><p><span style="font-family: 宋体, SimSun">...&nbsp;&nbsp;&nbsp;&nbsp;前面的任何内容均表示该类型项目的任意长度列表。</span></p></li><li><p><span style="font-family: 宋体, SimSun">|&nbsp;&nbsp;&nbsp;&nbsp;以竖线分隔的多个项目表示只能指定其中一个项目<br /></span></p></li><li><p><span style="font-family: 宋体, SimSun">&lt;&gt;&nbsp;&nbsp;&nbsp;&nbsp;尖括号中的文本表示变量的数据 。如&lt;finename&gt;表示 “此处需要插入您要使用的文件名”有时会简单的写成大写字母，如FILENAME.</span></p></li></ul><p><br /></p><p><span style="font-family: 宋体, SimSun;font-size: 16px">date 命令用于显示时间</span><br /><span style="font-family: 宋体, SimSun"></span></p><pre class="brush:bash;toolbar:false">[root@client&nbsp;~]#&nbsp;date
2018年&nbsp;04月&nbsp;20日&nbsp;星期五&nbsp;09:23:02&nbsp;CST
[root@client&nbsp;~]#&nbsp;date&nbsp;+%R
09:23
[root@client&nbsp;~]#&nbsp;date&nbsp;+%x
2018年04月20日
[root@client&nbsp;~]#</pre><p><span style="font-family: 宋体, SimSun">passwd 命令用于更改用户密码：不指定用户名即修改当前用户密码，使用root 修改密码无需知道原密码。默认情况下密码策略是有要求的，需要包含小写字母、大写字母、数字和符号，并且不以字典中的单词为基础。<br /></span></p><pre class="brush:bash;toolbar:false">[root@client&nbsp;~]#&nbsp;passwd&nbsp;client
更改用户&nbsp;client&nbsp;的密码&nbsp;。
新的&nbsp;密码：
无效的密码：&nbsp;密码少于&nbsp;8&nbsp;个字符
重新输入新的&nbsp;密码：
passwd：所有的身份验证令牌已经成功更新。
[root@client&nbsp;~]#&nbsp;
[root@client&nbsp;~]#&nbsp;passwd
更改用户&nbsp;root&nbsp;的密码&nbsp;。
新的&nbsp;密码：
[client@client&nbsp;~]$&nbsp;passwd
更改用户&nbsp;client&nbsp;的密码&nbsp;。
为&nbsp;client&nbsp;更改&nbsp;STRESS&nbsp;密码。
（当前）UNIX&nbsp;密码：
新的&nbsp;密码：
重新输入新的&nbsp;密码：
passwd：所有的身份验证令牌已经成功更新。
[client@client&nbsp;~]$</pre><p><br /></p><p><span style="font-family: 宋体, SimSun">Linux 不需要文件扩展名做为依据分类文件，file 命令可以扫描文件内容的开头，显示 文件的类型。</span></p><p><span style="font-family: 宋体, SimSun">新的 密码：<br />重新输入新的 密码：<br />passwd：所有的身份验证令牌已经成功更新。<br />&nbsp;<br /></span></p><pre class="brush:bash;toolbar:false">[client@client&nbsp;~]$&nbsp;file&nbsp;/etc/passwd
/etc/passwd:&nbsp;ASCII&nbsp;text
[client@client&nbsp;~]$&nbsp;file&nbsp;/bin/passwd
/bin/passwd:&nbsp;setuid&nbsp;ELF&nbsp;64-bit&nbsp;LSB&nbsp;shared&nbsp;object,&nbsp;x86-64,&nbsp;version&nbsp;1&nbsp;(SYSV),&nbsp;dynamically&nbsp;linked&nbsp;(uses&nbsp;shared&nbsp;libs),&nbsp;for&nbsp;GNU/Linux&nbsp;2.6.32,&nbsp;BuildID[sha1]=1e5735bf7b317e60bcb907f1989951f6abd50e8d,&nbsp;stripped
[client@client&nbsp;~]$&nbsp;file&nbsp;/home
/home:&nbsp;directory</pre><p><br /><span style="font-family: 宋体, SimSun"></span></p><p><span style="font-family: 宋体, SimSun">head 和tail 命令分别显示文件的开头和结尾部分。默认情况下都是显示10行数据 。使用-n 选项可以指定需要显示的行数。</span></p><pre class="brush:bash;toolbar:false">[client@client&nbsp;~]$&nbsp;head&nbsp;/etc/passwd
[client@client&nbsp;~]$&nbsp;tail&nbsp;/etc/passwd
[client@client&nbsp;~]$&nbsp;head&nbsp;-n&nbsp;5&nbsp;/etc/passwd
[client@client&nbsp;~]$&nbsp;tail&nbsp;-n&nbsp;6&nbsp;/etc/passwd</pre><p><span style="font-family: 宋体, SimSun">wc 命令可以计算文件中行、字和字符的数量。它可以授受 -l、 -w 或 -c选项，分别用户显示行数（lines）、字数（words）和字符数（characters）</span></p><pre class="brush:bash;toolbar:false">[client@client&nbsp;~]$&nbsp;wc&nbsp;/etc/passwd
&nbsp;&nbsp;22&nbsp;&nbsp;&nbsp;42&nbsp;1051&nbsp;/etc/passwd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#行、字、字符
[client@client&nbsp;~]$&nbsp;wc&nbsp;-l&nbsp;/etc/passwd
22&nbsp;/etc/passwd
[client@client&nbsp;~]$&nbsp;wc&nbsp;-c&nbsp;/etc/passwd
1051&nbsp;/etc/passwd
[client@client&nbsp;~]$&nbsp;wc&nbsp;-w&nbsp;/etc/passwd
42&nbsp;/etc/passwd
[client@client&nbsp;~]$&nbsp;wc&nbsp;-c&nbsp;/etc/group&nbsp;/etc/hosts&nbsp;&nbsp;&nbsp;&nbsp;#指定多个文件
567&nbsp;/etc/group
181&nbsp;/etc/hosts
748&nbsp;总用量</pre><p><span style="font-family: 宋体, SimSun;font-size: 24px">Tab 补全</span></p><p><span style="font-family: 宋体, SimSun;font-size: 24px"><span style="font-family: 宋体, SimSun;font-size: 14px">tab 补全可用于命令补全和文件名补全部分命令还可以补全参数选项</span><br /></span></p><pre class="brush:bash;toolbar:false">[client@client&nbsp;~]$&nbsp;pas&lt;tab&gt;&nbsp;&nbsp;&nbsp;&nbsp;#自动列出以pas开头的不唯一命令
passwd&nbsp;&nbsp;paste&nbsp;&nbsp;&nbsp;
[client@client&nbsp;~]$&nbsp;pass&lt;tab&gt;&nbsp;&nbsp;&nbsp;&nbsp;#自动补全pass开头的唯一命令
[client@client&nbsp;~]$&nbsp;passwd</pre><p><span style="font-family: 宋体, SimSun;font-size: 14px"></span><span style="font-family: 宋体, SimSun">history 命令显示之前执行的命令的列表，带有命令编号作为前缀。感叹号 ! 是元字符，用于扩展之前的命令而不必重新键入它们。!number 扩展至与指定编号匹配的命令。 !string 扩展至最近一个以指定字符串开头的命令。方向上下键可以向上或向下查找最近使用过的命令。左右键则开始进行命令行修改。<br /></span></p><p><span style="font-family: 宋体, SimSun"></span></p><pre class="brush:bash;toolbar:false">histort
!48
!ls</pre><p><span style="font-family: 宋体, SimSun">Esc + .&nbsp; 组合键可使shell 将上一条命令的最后一个单词（参数）复制到当前命令行中的光标所处的位置。如果重复使用，它将继续转到更早的命令</span>。<span style="font-family: 宋体, SimSun"></span><br /></p><table><tbody><tr class="firstRow"><td style="border-width: 1px;border-style: solid" valign="top">快捷方式<br /></td><td style="border-width: 1px;border-style: solid" valign="top">描述<br /></td></tr><tr><td style="border-width: 1px;border-style: solid" valign="top">Ctrl + a<br /></td><td style="border-width: 1px;border-style: solid" valign="top">跳到命令行的开头<br /></td></tr><tr><td style="border-width: 1px;border-style: solid" valign="top">Ctrl + e<br /></td><td style="border-width: 1px;border-style: solid" valign="top">跳到命令行的末尾<br /></td></tr><tr><td style="border-width: 1px;border-style: solid" valign="top">Ctrl + u<br /></td><td style="border-width: 1px;border-style: solid" valign="top">将光标位置到命令行开头的内容清除<br /></td></tr><tr><td style="border-width: 1px;border-style: solid" valign="top">Ctrl + k<br /></td><td style="border-width: 1px;border-style: solid" valign="top">将光标位置到命令行末尾的内容清除</td></tr><tr><td style="border-width: 1px;border-style: solid" valign="top">Ctrl + -&gt; 方向<br /></td><td style="border-width: 1px;border-style: solid" valign="top">跳到命令行中后一字的开头<br /></td></tr><tr><td style="border-width: 1px;border-style: solid" valign="top">Ctrl + &lt;-<br /></td><td style="border-width: 1px;border-style: solid" valign="top">跳到命令行中前一字的开头<br /></td></tr><tr><td colspan="1" rowspan="1" style="border-width: 1px;border-style: solid" valign="top">Ctrl + l<br /></td><td colspan="1" rowspan="1" style="border-width: 1px;border-style: solid" valign="top">清除当前屏幕显示<br /></td></tr><tr><td style="border-width: 1px;border-style: solid" valign="top">Ctrl + r<br /></td><td style="border-width: 1px;border-style: solid" valign="top"><p>在历史记录列表中搜索某一命令</p></td></tr></tbody></table><p>&nbsp;<br /></p>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>250</wp:post_id>
		<wp:post_date><![CDATA[2018-04-20 10:10:20]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-04-20 02:10:20]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[chapter1-accessing-the-command-line]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="rhel124"><![CDATA[RHEL124]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_page_template]]></wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[hestia_layout_select]]></wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Chapter 2 . Managing Files From The Command Line</title>
		<link>https://www.rhel.tk/2018/04/20/chapter-2-managing-files-from-the-command-line/</link>
		<pubDate>Fri, 20 Apr 2018 06:25:46 +0000</pubDate>
		<dc:creator><![CDATA[blogs]]></dc:creator>
		<guid isPermaLink="false">https://www.rhel.tk/?p=254</guid>
		<description></description>
		<content:encoded><![CDATA[<p><img src="/wp-content/uploads/image/20180420/1524194156616572.png" title="1524194156616572.png" alt="图片.png" /></p><p><br /></p><table><tbody><tr class="firstRow"><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">位置<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">用途<br /></span></td></tr><tr><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">/usr<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><p><span style="font-family: 宋体, SimSun">安装的软件、共享的库，包括文件和静态只读程序数据。重要的子目录有：</span></p><p><span style="font-family: 宋体, SimSun">- /usr/bin:用户命令</span></p><p><span style="font-family: 宋体, SimSun">- /usr/sbin:系统管理命令</span></p><p><span style="font-family: 宋体, SimSun">- /usr/local:本地自定义软件<br /></span></p></td></tr><tr><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">/etc<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">特定于此系统的配置文件<br /></span></td></tr><tr><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">/var<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">特定于此系统的可变数据，在系统启动之间保持永久性。动态变化的文件（如数据库、缓存目录、日志文件、打印机后台处理文档和网站内容）可以在/var下找到<br /></span></td></tr><tr><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">/run<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">自上次系统启动以来启动的进程的运行数据。这包括进程ID文件和锁定文件等等。此目录中的内容在重启时重新创建。（此目录整合了旧版RHEL中的/var/run 和/var/lock)<br /></span></td></tr><tr><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">/home<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">普通用户存储其个人数据和配置文件的主目录<br /></span></td></tr><tr><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">/root<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">管理员超级用户root的主目录。<br /></span></td></tr><tr><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">/tmp<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">供临时文件使用的全局可写空间。10天内未访问、未更改或未修改的文件将自动从该目录中删除。还有一个临时目录/var/tmp，该目录中的文件如果在30天内未曾访问、更改或修改过，将被自动删除<br /></span></td></tr><tr><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">/boot<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">开始启动过程所需的文件<br /></span></td></tr><tr><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">/dev<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">包含特殊的设备文件，供系统用于访问硬件。<br /></span></td></tr></tbody></table><p><span style="font-family: 宋体, SimSun">在RHEL7中，/ 目录下四个较旧的目录现在与它们在/usr 中对应的目录拥有完成相同的内容：</span></p><ul style="list-style-type: square" class=" list-paddingleft-2"><li><p><span style="font-family: 宋体, SimSun">/bin 和 /usr/bin</span></p></li><li><p><span style="font-family: 宋体, SimSun">/sbin 和 /usr/sbin</span></p></li><li><p><span style="font-family: 宋体, SimSun">/lib 和/usr/lib</span></p></li><li><p><span style="font-family: 宋体, SimSun">/lib64 和/usr/lib64</span></p></li></ul><p><span style="font-family: 宋体, SimSun">在RHEL 的较早版本中，这些是不同的目录，包含几组不同的文件。在RHEL7中 / 中的目录是/usr 中对应目录的符号连接。</span></p><p><span style="font-family: 宋体, SimSun"><a href="http://www.pathname.com/fhs/">http://www.pathname.com/fhs/</a> Filesystem Hierarchy Standard</span></p><p><span style="font-family: 宋体, SimSun;color: #FF0000">创建文件夹时应尽量避免出现空格</span></p><p><span style="font-family: 宋体, SimSun">绝对路径是完全限定名称，自根目录（/）开始，指定到达且唯一代表单个文件所遍历的每个子目录。文件系统中的每个文件都有一个绝对路径。第一个字符是正斜杠（/）的路径名是绝对路径名。例/var/log/message</span></p><p><span style="font-family: 宋体, SimSun">相对路径与绝对路径一样，相对路径也标识唯一文件，仅指定从工作目录到达该文件所需的路径。第一人字符是正斜杠（/）<span style="font-family: 宋体, SimSun;color: #FF0000">之外</span>的其它字符路径名的是相对路径。例在/var目录下访问log/message<br /></span></p><p><span style="font-family: 宋体, SimSun">对于标准的linux文件系统，文件名路径总长度（包括/）不可超过4095字节。路径中通过/隔开的第一部分不可超过255字节。文件名中不允许出现‘/’和&#039;NUL字符&#039;。</span></p><p><span style="font-family: 宋体, SimSun">Linux 文件系统，包含但不限于ext4,XFS,BIRFS,GFS2和GlusterFS都是区分大小写的。VFAT和NTFS及Apple的HFS+虽然不区分大小写，但它们具体大小写保留行为，他们使用创建时的大小写显示文件名。</span></p><p><span style="font-family: 宋体, SimSun">pwd 命令显示当前位置的完成路径名。</span></p><p><span style="font-family: 宋体, SimSun">ls 命令列出指定目录的目录内容，如未指定则显示当前目录的内容（.表示当前目录。 ..表示父目录）</span></p><p><span style="font-family: 宋体, SimSun">-l 长列表格式，-a 包含隐藏文件（.开头的文件）的所有文件，-R 递归方式，包含所有子目录。<br /></span></p><p><span style="font-family: 宋体, SimSun">cd 命令可更改目录，未指定目录则回到家目录。（~）表示家目录。<br /></span></p><p><span style="font-family: 宋体, SimSun">&nbsp;- 回到上次的目录，cd ..回到上级目录<br /></span></p><p><span style="font-family: 宋体, SimSun">touch 命令通常将文件的时间戳更新为当前日期和时间，而不做其它修改，如果文件名不存在则创建一个空文件。<br /></span></p><p><span style="font-family: 宋体, SimSun"></span></p><table width="920"><tbody><tr class="firstRow"><td style="border-width: 1px;border-style: solid" width="161" valign="top"><span style="font-family: 宋体, SimSun">活动<br /></span></td><td style="border-width: 1px;border-style: solid" width="305" valign="top"><span style="font-family: 宋体, SimSun">单一来源<br /></span></td><td style="border-width: 1px;border-style: solid" width="452" valign="top"><span style="font-family: 宋体, SimSun">多来源<br /></span></td></tr><tr><td style="border-width: 1px;border-style: solid" width="161" valign="top"><span style="font-family: 宋体, SimSun">复制文件<br /></span></td><td style="border-width: 1px;border-style: solid" width="305" valign="top"><span style="font-family: 宋体, SimSun">cp file1 file2<br /></span></td><td style="border-width: 1px;border-style: solid" width="452" valign="top"><span style="font-family: 宋体, SimSun">cp file1 file2 file3 dir<sup>(4)</sup><br /></span></td></tr><tr><td style="border-width: 1px;border-style: solid" width="161" valign="top"><span style="font-family: 宋体, SimSun">移动文件<br /></span></td><td style="border-width: 1px;border-style: solid" width="305" valign="top"><span style="font-family: 宋体, SimSun">mv file1 file2<sup>(1)</sup><br /></span></td><td style="border-width: 1px;border-style: solid" width="452" valign="top"><span style="font-family: 宋体, SimSun">mv file1 file2 file3 dir<sup>(4)</sup><br /></span></td></tr><tr><td style="border-width: 1px;border-style: solid" width="161" valign="top"><span style="font-family: 宋体, SimSun">删除文件<br /></span></td><td style="border-width: 1px;border-style: solid" width="305" valign="top"><span style="font-family: 宋体, SimSun">rm file1<br /></span></td><td style="border-width: 1px;border-style: solid" width="452" valign="top"><span style="font-family: 宋体, SimSun">rm -rf file1 file2 file3<sup>(5)</sup><br /></span></td></tr><tr><td style="border-width: 1px;border-style: solid" width="161" valign="top"><span style="font-family: 宋体, SimSun">创建目录<br /></span></td><td style="border-width: 1px;border-style: solid" width="305" valign="top"><span style="font-family: 宋体, SimSun">mkdir dir<br /></span></td><td style="border-width: 1px;border-style: solid" width="452" valign="top"><span style="font-family: 宋体, SimSun">mkdir -p par1/par2/dir<sup>(6)</sup><br /></span></td></tr><tr><td style="border-width: 1px;border-style: solid" width="161" valign="top"><span style="font-family: 宋体, SimSun">移动目录<br /></span></td><td style="border-width: 1px;border-style: solid" width="305" valign="top"><span style="font-family: 宋体, SimSun">mv dir1 dir2<sup>(3)</sup><br /></span></td><td style="border-width: 1px;border-style: solid" width="452" valign="top"><span style="font-family: 宋体, SimSun">mv dir1 dir2 dir3 dir4<sup>(4)</sup><br /></span></td></tr><tr><td style="border-width: 1px;border-style: solid" width="161" valign="top"><span style="font-family: 宋体, SimSun">删除目录<br /></span></td><td style="border-width: 1px;border-style: solid" width="305" valign="top"><span style="font-family: 宋体, SimSun">rm -r dir1<sup>(2)</sup><br /></span></td><td style="border-width: 1px;border-style: solid" width="452" valign="top"><span style="font-family: 宋体, SimSun">rm -rf dir1 dir2 dir3<sup>(4)</sup><br /></span></td></tr><tr><td style="border-width: 1px;border-style: solid" width="161" valign="top"><span style="font-family: 宋体, SimSun">复制目录<br /></span></td><td style="border-width: 1px;border-style: solid" width="305" valign="top"><span style="font-family: 宋体, SimSun">cp -r dir1 dir2<sup>(2)</sup><br /></span></td><td style="border-width: 1px;border-style: solid" width="452" valign="top"><span style="font-family: 宋体, SimSun">cp -rf dir1 dir2 dir3<sup>(5)</sup><br /></span></td></tr><tr><td style="border-width: 1px;border-style: solid" width="161" valign="middle" align="center"><span style="font-family: 宋体, SimSun">注</span><br /></td><td rowspan="1" colspan="2" style="border-width: 1px;border-style: solid" valign="top"><p><span style="font-family: 宋体, SimSun">(1)结果为重命名</span></p><p><span style="font-family: 宋体, SimSun">(2)需要使用“递归”选项处理来源目录</span></p><p><span style="font-family: 宋体, SimSun">(3)如果dir2存在，则结果为移动。如果dir2不存在则为重命名</span></p><p><span style="font-family: 宋体, SimSun">(4)最后一个参数必须是目录</span></p><p><span style="font-family: 宋体, SimSun">(5)请谨慎使用“force”选项，系统将不会提示您操作</span></p><p><span style="font-family: 宋体, SimSun">(6)使用“创建父级”选项时应小心，无法捕获键入错误。<br /></span></p></td></tr></tbody></table><p><span style="font-family: 宋体, SimSun"> </span><br /></p><p>模式匹配，通配符<br /></p><table><tbody><tr class="firstRow"><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">模式<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">匹配项<br /></span></td></tr><tr><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">*<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">由0个或以上字符组成的任何字符串<br /></span></td></tr><tr><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">?<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">任何一个字符 <br /></span></td></tr><tr><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">~<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">当前用户的主目录<br /></span></td></tr><tr><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">~username<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">username用户的主目录<br /></span></td></tr><tr><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">~+<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">当前工作目录<br /></span></td></tr><tr><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">~-<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">上一工作目录<br /></span></td></tr><tr><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">[abc...]<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">括起的类中的任何一个字符。<br /></span></td></tr><tr><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">[!abc...]<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">不在括起的类中的任何一个字符<br /></span></td></tr><tr><td colspan="1" rowspan="1" style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">[^abc...]<br /></span></td><td colspan="1" rowspan="1" style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">不在括起的类中的任何一个字符</span></td></tr><tr><td colspan="1" rowspan="1" style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">[[:alpha:]]<br /></span></td><td colspan="1" rowspan="1" style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">任何字母字符<sup>（1）</sup></span></td></tr><tr><td colspan="1" rowspan="1" style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">[[:lower:]]<br /></span></td><td colspan="1" rowspan="1" style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">任何小写字符<sup>（1）</sup></span></td></tr><tr><td colspan="1" rowspan="1" style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">[[:upper:]]<br /></span></td><td colspan="1" rowspan="1" style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">任何大写字符 <sup>（1）</sup></span></td></tr><tr><td colspan="1" rowspan="1" style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">[[:alnum:]]<br /></span></td><td colspan="1" rowspan="1" style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">任何字母字符或数字<sup>（1）</sup></span></td></tr><tr><td colspan="1" rowspan="1" style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">[[:punct:]]<br /></span></td><td colspan="1" rowspan="1" style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">除空格和字母数字以外的任何可打印的字符。<sup>（1）</sup></span></td></tr><tr><td colspan="1" rowspan="1" style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">[[:digit:]]<br /></span></td><td colspan="1" rowspan="1" style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">任何数字，即0-9<sup>（1）</sup></span></td></tr><tr><td colspan="1" rowspan="1" style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">[[:space:]]<br /></span></td><td colspan="1" rowspan="1" style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">任何一个空白字符；可能包括制表符、换行符或回车符，以及换页符和空格<sup>（1）</sup></span></td></tr><tr><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">注释<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px"><sup>（1）</sup>预设的POSIX字符类；针对当前区域而调整<br /></span></td></tr></tbody></table><p><span style="font-family: 宋体, SimSun">{}大括号扩展用于生成任意字符串。大括号包含字符串的逗号分隔列表或顺序表达式。</span></p><pre class="brush:bash;toolbar:false">[root@client&nbsp;~]#&nbsp;echo&nbsp;{sunday,Monday,Tuesday,Wednesday}.log
sunday.log&nbsp;Monday.log&nbsp;Tuesday.log&nbsp;Wednesday.log
[root@client&nbsp;~]#&nbsp;echo&nbsp;{1..5}.log
1.log&nbsp;2.log&nbsp;3.log&nbsp;4.log&nbsp;5.log
[root@client&nbsp;~]#&nbsp;echo&nbsp;file{a..d}.txt
filea.txt&nbsp;fileb.txt&nbsp;filec.txt&nbsp;filed.txt
[root@client&nbsp;~]#&nbsp;echo&nbsp;file{a,b}{1,2}.txt
filea1.txt&nbsp;filea2.txt&nbsp;fileb1.txt&nbsp;fileb2.txt
[root@client&nbsp;~]#&nbsp;echo&nbsp;file{a{1,2},b,c}.txt
filea1.txt&nbsp;filea2.txt&nbsp;fileb.txt&nbsp;filec.txt</pre><p>命令替换`` 反引号或$()</p><pre class="brush:bash;toolbar:false">[root@client&nbsp;~]#&nbsp;echo&nbsp;Today&nbsp;is&nbsp;`date&nbsp;+%A`
Today&nbsp;is&nbsp;星期五
[root@client&nbsp;~]#&nbsp;echo&nbsp;The&nbsp;time&nbsp;is&nbsp;$(date&nbsp;+%M)&nbsp;minutes&nbsp;past&nbsp;$(date&nbsp;+%l%p)
The&nbsp;time&nbsp;is&nbsp;16&nbsp;minutes&nbsp;past&nbsp;4下午</pre><p><span style="font-family: 宋体, SimSun">防止参数被扩展，为了忽略元字符的特殊含义，使用引用和转义来防止它们被shell 扩展。反斜杠（\）是bash的一个转义字符，防止其后的一个字符被特殊解释。如果要保护较长的字符串需要使用单引号和双引号括起来。</span></p><pre class="brush:bash;toolbar:false">[root@client&nbsp;~]#&nbsp;echo&nbsp;Your&nbsp;username&nbsp;varialbe&nbsp;is&nbsp;\$USER
Your&nbsp;username&nbsp;varialbe&nbsp;is&nbsp;$USER
[root@client&nbsp;~]#&nbsp;echo&nbsp;Your&nbsp;username&nbsp;varialbe&nbsp;is&nbsp;$USER&nbsp;
Your&nbsp;username&nbsp;varialbe&nbsp;is&nbsp;root
[root@client&nbsp;~]#&nbsp;host=desktop0
[root@client&nbsp;~]#&nbsp;echo&nbsp;&quot;Will&nbsp;variable&nbsp;$host&nbsp;evaluate&nbsp;to&nbsp;$(hostname)?&quot;
Will&nbsp;variable&nbsp;desktop0&nbsp;evaluate&nbsp;to&nbsp;client?
[root@client&nbsp;~]#&nbsp;echo&nbsp;&#039;Will&nbsp;variable&nbsp;$host&nbsp;evaluate&nbsp;to&nbsp;$(hostname)?&#039;&nbsp;
Will&nbsp;variable&nbsp;$host&nbsp;evaluate&nbsp;to&nbsp;$(hostname)?</pre><p><br /></p>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>254</wp:post_id>
		<wp:post_date><![CDATA[2018-04-20 14:25:46]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-04-20 06:25:46]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[chapter-2-managing-files-from-the-command-line]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="rhel124"><![CDATA[RHEL124]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_page_template]]></wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[hestia_layout_select]]></wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>iptables 端口转发</title>
		<link>https://www.rhel.tk/2018/04/24/iptables-%e7%ab%af%e5%8f%a3%e8%bd%ac%e5%8f%91/</link>
		<pubDate>Tue, 24 Apr 2018 03:26:46 +0000</pubDate>
		<dc:creator><![CDATA[blogs]]></dc:creator>
		<guid isPermaLink="false">https://www.rhel.tk/?p=269</guid>
		<description></description>
		<content:encoded><![CDATA[<p><span style="font-family: 宋体, SimSun">将firewalld切换到 iptables<br />1. 停止并禁用 firewalld<br />sudo systemctl stop firewald.service &amp;&amp; sudo systemctl disable firewald.service<br />2.安装iptables-services、iptables-devel<br />sudo yum install iptables-services iptables-devel<br />3.启用并启动iptables<br />sudo systemctl enable iptables.service &amp;&amp; sudo systemctl start iptables.service</span></p><hr /><p><strong><br /></strong><br /></p><p><strong>a.同一端口转发</strong><span style="font-family: 宋体, SimSun">(192.168.0.132上开通1521端口访问&nbsp;iptables -A RH-Firewall-1-INPUT -m state --state NEW -m tcp -p tcp --dport 1521 -j ACCEPT)</span></p><p><span style="font-family: 宋体, SimSun">iptables -t nat -I PREROUTING -p tcp --dport 1521 -j DNAT --to 192.168.0.211<br />iptables -t nat -I POSTROUTING -p tcp --dport 1521 -j MASQUERADE</span><br /><br /><strong>b.不同端口转发</strong><span style="font-family: 宋体, SimSun">(192.168.0.132上开通21521端口访问&nbsp;iptables -A RH-Firewall-1-INPUT -m state --state NEW -m tcp -p tcp --dport 21521 -j ACCEPT)</span></p><span style="font-family: 宋体, SimSun">iptables -t nat -A PREROUTING -p tcp -m tcp --dport<strong>21521</strong> -j DNAT --to-destination<strong>192.168.0.211:1521</strong><br />iptables -t nat -A POSTROUTING -s 192.168.0.0/16 -d 192.168.0.211 -p tcp -m tcp --dport 1521 -j SNAT --to-source 192.168.0.132<br /></span><br /><br /><span style="font-family: 宋体, SimSun"><strong>以上两条等价配置(更简单[指定网卡]):</strong><br />iptables -t nat -A PREROUTING -p tcp -i eth0 --dport 31521 -j DNAT --to 192.168.0.211:1521<br />iptables -t nat -A POSTROUTING -j MASQUERADE<br /><br /><br />保存iptables<br />#service iptables save<br /></span><p><span style="font-family: 宋体, SimSun">#service iptables restart</span></p><p><span style="font-family: 宋体, SimSun">二 用iptables做本机端口转发<br /><br />&nbsp; 代码如下：<br />&nbsp; iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-ports 8080<br /><br />&nbsp; 估计适当增加其它的参数也可以做不同IP的端口转发。<br />&nbsp; 如果需要本机也可以访问，则需要配置OUTPUT链(********特别注意:本机访问外网的端口会转发到本地,导致访不到外网,如访问yown.com,实际上是访问到本地,建议不做80端口的转发或者指定目的 -d localhost)：<br /><br />&nbsp; iptables -t nat -A OUTPUT -d localhost -p tcp --dport 80 -j REDIRECT --to-ports 8080<br /><br />原因：<br />外网访问需要经过PREROUTING链，但是localhost不经过该链，因此需要用OUTPUT。<br /><br />#######################################################################################<br /><br />概述：公司有一些核心MySQL服务器位于核心机房的内网段，作为运维人员，经常需要去连接这些服务器，因无法直接通过外网访问，给管理造成了不便。<br /><br />思路：虽然解决此问题的方法及思路有很多，但当下想使用IPTABLES的端口重定向功能解决此问题，比较简单易用，而且扩展性也比较好，依次类推，可以运用到其他的端口转发方面的应用。<br />网络环境：<br />公网服务器&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ：eth0:公网IP&nbsp;&nbsp;&nbsp; eth1:内网IP - 192.168.1.1<br />mysql服务器：eth1:内网IP - 192.168.1.2<br />实现方法：通过访问公网IP的63306端口来实现到内网MYSQL服务器的3306端口的访问<br />在公网服务器上：<br />配置脚本：<br />iptables -t nat -A PREROUTING -p tcp --dport 63306 -j DNAT --to-destination 192.168.1.2:3306<br />iptables -t nat -A POSTROUTING -d 192.168.1.2 -p tcp --dport 3306 -j SNAT --to 192.168.1.1<br />允许服务器的IP转发功能：<br />echo 1 &gt; /proc/sys/net/ipv4/ip_forward<br />使用方法：<br />mysql -h 公网IP -p 63306 -uroot -p<br /><br />&nbsp;###############################################################################################<br /><br />由于业务需要，服务器越来越多，内网服务器无外网环境管理甚是不便，所以折腾了一下外网到内网的端口转发以达到轻松管理的目的，贴一下心得。<br /><br />S1:<br />eth0 10.0.0.1<br />eth1 x.x.x.x<br /><br />S2:<br />eth0 10.0.0.2<br /><br />S1 8082端口转发到内网机器22端口<br />iptables规则配置如下：<br />iptables -t nat -A PREROUTING -d x.x.x.x -p tcp --dport 8082 -j DNAT --to-destination 10.0.0.2:22<br />iptables -t nat -A POSTROUTING -d 10.0.0.2 -p tcp --dport 22 -j SNAT --to-source x.x.x.x<br />说明：<br />iptables -t nat -A PREROUTING -d &quot;对外公网ip&quot; -p tcp --dport &quot;对外端口&quot; -j DNAT --to &quot;内部实际提供服务的ip&quot;:&quot;实际提供服务的端口&quot;<br />iptables -t nat -A POSTROUTING -d &quot;内部实际提供服务的ip&quot;-p tcp --dport &quot;实际提供服务的端口&quot; -j SNAT --to-source &quot;运行iptables机器的内网ip&quot;</span></p><hr /><p><br /></p>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>269</wp:post_id>
		<wp:post_date><![CDATA[2018-04-24 11:26:46]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-04-24 03:26:46]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[iptables-%e7%ab%af%e5%8f%a3%e8%bd%ac%e5%8f%91]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="uncategorized"><![CDATA[未分类]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_page_template]]></wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[hestia_layout_select]]></wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Chapter 3. Getting Help in Red Hat Enterprise Linux</title>
		<link>https://www.rhel.tk/2018/04/26/chapter-3-getting-help-in-red-hat-enterprise-linux/</link>
		<pubDate>Thu, 26 Apr 2018 03:01:18 +0000</pubDate>
		<dc:creator><![CDATA[blogs]]></dc:creator>
		<guid isPermaLink="false">https://www.rhel.tk/?p=273</guid>
		<description></description>
		<content:encoded><![CDATA[<table><tbody><tr class="firstRow"><td valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">章节<br /></span></td><td valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">内容类型<br /></span></td></tr><tr><td valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">1<br /></span></td><td valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">用户命令（可执行命令和shell程序）<br /></span></td></tr><tr><td valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">2<br /></span></td><td valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">系统调用（从用户空间调用的内核例程）<br /></span></td></tr><tr><td valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">3<br /></span></td><td valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">库函数（由程序提供）<br /></span></td></tr><tr><td valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">4<br /></span></td><td valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">特殊文件（如设备文件）<br /></span></td></tr><tr><td valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">5<br /></span></td><td valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">文件格式（用于许多配置文件和结构）<br /></span></td></tr><tr><td valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">6<br /></span></td><td valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">游戏（过去的有趣程序章节）<br /></span></td></tr><tr><td valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">7<br /></span></td><td valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">惯例，标准和其它（协议、文件系统）</span></td></tr><tr><td valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">8<br /></span></td><td valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">系统管理和特权命令（维护任务）<br /></span></td></tr><tr><td valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">9<br /></span></td><td valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">Linux 内核API（内核调用）<br /></span></td></tr></tbody></table><p><span style="font-family: 宋体, SimSun;font-size: 14px">导航 man page</span></p><table><tbody><tr class="firstRow"><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">命令<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">结果<br /></span></td></tr><tr><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">空格键<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">向前（向下）滚动一个屏幕<br /></span></td></tr><tr><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">PageDown<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">向前（向下）滚动一个屏幕<br /></span></td></tr><tr><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">PageUp<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">向后（向上）滚动一个屏幕<br /></span></td></tr><tr><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">向下箭头<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">向前（向下）滚动一行<br /></span></td></tr><tr><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">向上箭头<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">向后（向上）滚动一行<br /></span></td></tr><tr><td colspan="1" rowspan="1" style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">d<br /></span></td><td colspan="1" rowspan="1" style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">向前（向下）滚动半个屏幕<br /></span></td></tr><tr><td colspan="1" rowspan="1" style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">u<br /></span></td><td colspan="1" rowspan="1" style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">身后（向上）滚动半个屏幕<br /></span></td></tr><tr><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">/String<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">在man page 中向前（向下）搜索string<br /></span></td></tr><tr><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">n<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">在man page 中重复之前的向前（向下）搜索<br /></span></td></tr><tr><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">N<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">在man page中重复之前的向后（向上）搜索<br /></span></td></tr><tr><td colspan="1" rowspan="1" style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">g<br /></span></td><td colspan="1" rowspan="1" style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">转到man page的开头<br /></span></td></tr><tr><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">G<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">转到man page的末尾<br /></span></td></tr><tr><td colspan="1" rowspan="1" style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">q<br /></span></td><td colspan="1" rowspan="1" style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun;font-size: 14px">退出 man ,并返回到shell命令提示符<br /></span></td></tr></tbody></table><p><span style="font-family: 宋体, SimSun;font-size: 14px">man passwd 默认显示章节1,passwd(1)</span></p><p><span style="font-family: 宋体, SimSun;font-size: 14px">man 5 passwd 查看passwd 第5章节passwd(5)</span></p><p><span style="font-family: 宋体, SimSun;font-size: 14px">搜索string时允许正则表达试</span></p><p><span style="font-family: 宋体, SimSun;font-size: 14px">man -k keyword&nbsp; #执行标题和描述<br /></span></p><p><span style="font-family: 宋体, SimSun;font-size: 14px">man -K keyward #执行全文页面搜索<br /></span></p><p><span style="font-family: 宋体, SimSun;font-size: 14px">#根据关键字搜索man page ,关键字搜索依赖mandb(8)生成的索引；必须以root身份运行，该命令每天通过cron.daily 运行。或者anacrontab 在启动一小时内运行（如果过期）</span></p><p><span style="font-family: 宋体, SimSun;font-size: 14px">pinfo <br /></span></p><p><span style="font-family: 宋体, SimSun;font-size: 14px">man page 的正式格式作用于命令参考时很有用，但作用于普通文档却用处不大。对于此类文档，GNU项目发了一种不同的在线文档系统，称为GNU info。</span></p><p><span style="font-family: 宋体, SimSun;font-size: 14px">info 文档结构超链接式的info 节点组成。此格式比man page 更灵活，允许对复杂命令和概念进行彻底的说明。</span></p><p><span style="font-family: 宋体, SimSun;font-size: 14px">pinfo info 读取器比原始的info命令更加高级。它设计为与lynx文本web 浏览器击键操作相符，也添加了颜色。可以通过pinfo topic 浏览特定的主题的节点。</span></p><p><span style="font-family: 宋体, SimSun;font-size: 14px">pinfo nano #查看nano<br /></span></p><p><span style="font-family: 宋体, SimSun;font-size: 14px">pinfo 和 man page 按键对比</span></p><p><span style="font-family: 宋体, SimSun;font-size: 14px"></span></p><table><tbody><tr class="firstRow"><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">导航<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">pinfo<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">man page<br /></span></td></tr><tr><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">向前（向下）滚动一个屏幕<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">PageDown 或空格键<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">PageDown或空格键<br /></span></td></tr><tr><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">向后（向上）滚动一个屏幕<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">PageUp 或 b<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">PageUp 或b<br /></span></td></tr><tr><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">显示主题目录<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">d<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">-<br /></span></td></tr><tr><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">向前（向下）滚动半个屏幕<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">-<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">d<br /></span></td></tr><tr><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">显示主题的顶部（上部）<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">主页<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">1G<br /></span></td></tr><tr><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">向后（向上）滚动半个屏幕<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">-<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">u<br /></span></td></tr><tr><td colspan="1" rowspan="1" style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">向前（向下）滚动到下一超链接<br /></span></td><td colspan="1" rowspan="1" style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">向下箭头<br /></span></td><td colspan="1" rowspan="1" style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">-<br /></span></td></tr><tr><td colspan="1" rowspan="1" style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">打开光标处的主题<br /></span></td><td colspan="1" rowspan="1" style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">Enter<br /></span></td><td colspan="1" rowspan="1" style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">-<br /></span></td></tr><tr><td colspan="1" rowspan="1" style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">向前（向下）滚动一行<br /></span></td><td colspan="1" rowspan="1" style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">-<br /></span></td><td colspan="1" rowspan="1" style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">向下箭头键或Enter<br /></span></td></tr><tr><td colspan="1" rowspan="1" style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">向后（向上）滚动到上一超链接<br /></span></td><td colspan="1" rowspan="1" style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">向上箭头<br /></span></td><td colspan="1" rowspan="1" style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">-<br /></span></td></tr><tr><td colspan="1" rowspan="1" style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">向后（向上）滚动一行<br /></span></td><td colspan="1" rowspan="1" style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">-<br /></span></td><td colspan="1" rowspan="1" style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">向上箭头<br /></span></td></tr><tr><td colspan="1" rowspan="1" style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">搜索某种模式<br /></span></td><td colspan="1" rowspan="1" style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">/string<br /></span></td><td colspan="1" rowspan="1" style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">/string<br /></span></td></tr><tr><td colspan="1" rowspan="1" style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">显示主题中的下一个节点（章节）<br /></span></td><td colspan="1" rowspan="1" style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">n<br /></span></td><td colspan="1" rowspan="1" style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">-<br /></span></td></tr><tr><td colspan="1" rowspan="1" style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">重复之前的向前（向下）搜索<br /></span></td><td colspan="1" rowspan="1" style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">/，再按Enter<br /></span></td><td colspan="1" rowspan="1" style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">n<br /></span></td></tr><tr><td colspan="1" rowspan="1" style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">显示主题中的上一节点（章节）<br /></span></td><td colspan="1" rowspan="1" style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">p<br /></span></td><td colspan="1" rowspan="1" style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">-<br /></span></td></tr><tr><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">重复之前的向后（向上）搜索<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">-<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">N<br /></span></td></tr><tr><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">退出程序<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><span style="font-family: 宋体, SimSun">q<br /></span></td><td style="border-width: 1px;border-style: solid" valign="top"><p><span style="font-family: 宋体, SimSun">q<br /></span></p></td></tr></tbody></table><p><span style="font-family: 宋体, SimSun">读取/usr/share/doc 中的文档</span></p><p><span style="font-family: 宋体, SimSun">安装软件包时，识别为文档的文件将移到/usr/share/doc/packagename 目录中，一些软件包附带大量的示例、配置文件模板、脚本、教程或用户手册。</span></p><p><span style="font-family: 宋体, SimSun">firefox </span><a href="http://file:///usr/share/doc" style="font-family: 宋体, SimSun;text-decoration: underline"><span style="font-family: 宋体, SimSun">file:///usr/share/doc</span></a> <br /></p><p><span style="font-family: 宋体, SimSun">yum list *-doc*&nbsp; #查看所有文档做为一个单独提供的软件<br /></span></p><p><br /></p><p><span style="font-family: 宋体, SimSun">红帽官方的帮助</span></p><p><br /></p><p><br /></p><p><span style="font-family: 宋体, SimSun">man man #查看man的使用方法</span></p><p><span style="font-family: 宋体, SimSun">man -t passwd &gt; passwd.ps&nbsp;&nbsp;&nbsp;&nbsp;#为passwd man page 创建格式化输出文件</span></p><p><span style="font-family: 宋体, SimSun">file passwd.ps&nbsp;&nbsp;&nbsp;&nbsp;#查看文件类型</span></p><p><span style="font-family: 宋体, SimSun">less&nbsp;&nbsp; passwd.ps #查看文件内容</span></p><p><span style="font-family: 宋体, SimSun">man -k postscript viewer &nbsp;&nbsp;&nbsp;&nbsp;#了解用于查看或打印postscript文件命令，-k 指定关键字</span></p><p><span style="font-family: 宋体, SimSun">man lp&nbsp;&nbsp;&nbsp;&nbsp;#查看lp命令的用法<br /></span></p><p><span style="font-family: 宋体, SimSun">lp passwd.ps -P 2-3 &nbsp;&nbsp;&nbsp;&nbsp;#打印passwd.ps的2-3页</span></p><p><br /></p><p><br /></p><p><br /></p><p><br /></p>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>273</wp:post_id>
		<wp:post_date><![CDATA[2018-04-26 11:01:18]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-04-26 03:01:18]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[chapter-3-getting-help-in-red-hat-enterprise-linux]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="rhel124"><![CDATA[RHEL124]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_page_template]]></wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[hestia_layout_select]]></wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Chapter 4 Creating,Viewing,And Editing Text Files</title>
		<link>https://www.rhel.tk/2018/04/27/chapter-4-creatingviewingand-editing-text-files/</link>
		<pubDate>Fri, 27 Apr 2018 08:49:36 +0000</pubDate>
		<dc:creator><![CDATA[blogs]]></dc:creator>
		<guid isPermaLink="false">https://www.rhel.tk/?p=284</guid>
		<description></description>
		<content:encoded><![CDATA[<table><tbody><tr class="firstRow"><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">编号<br /></span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">通道名称<br /></span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">描述<br /></span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">默认连接<br /></span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">用法<br /></span></td></tr><tr><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">0<br /></span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">stdin<br /></span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">标准输入<br /></span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">键盘<br /></span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">仅读取<br /></span></td></tr><tr><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">1<br /></span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">stdout<br /></span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">标准输出<br /></span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">终端<br /></span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">仅写入<br /></span></td></tr><tr><td valign="top" style="border-width: 1px;border-style: solid" rowspan="1" colspan="1"><span style="font-family: 宋体, SimSun">2<br /></span></td><td valign="top" style="border-width: 1px;border-style: solid" rowspan="1" colspan="1"><span style="font-family: 宋体, SimSun">stderr<br /></span></td><td valign="top" style="border-width: 1px;border-style: solid" rowspan="1" colspan="1"><span style="font-family: 宋体, SimSun">标准错误<br /></span></td><td valign="top" style="border-width: 1px;border-style: solid" rowspan="1" colspan="1"><span style="font-family: 宋体, SimSun">终端<br /></span></td><td valign="top" style="border-width: 1px;border-style: solid" rowspan="1" colspan="1"><span style="font-family: 宋体, SimSun">仅写入<br /></span></td></tr><tr><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">3+<br /></span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">filename<br /></span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">其它文件<br /></span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">无<br /></span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">读取/写入<br /></span></td></tr></tbody></table><p><span style="font-family: 宋体, SimSun;font-size: 24px">重定向输出到文件</span></p><p><br /></p><table><tbody><tr class="firstRow"><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">用法<br /></span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">说明<br /></span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">视觉效果<br /></span></td></tr><tr><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">&gt;file<br /></span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">重定向stdout到文件（1）<br /></span></td><td valign="top" style="border-width: 1px;border-style: solid"><img title="1524818205308304.png" alt="图片.png" src="/wp-content/uploads/image/20180427/1524818205308304.png" /></td></tr><tr><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">&gt;&gt;file<br /></span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">重定向stdout到文件，附加到当前文件内容后面（2）<br /></span></td><td valign="top" style="border-width: 1px;border-style: solid"><img title="1524818219547743.png" alt="图片.png" src="/wp-content/uploads/image/20180427/1524818219547743.png" /></td></tr><tr><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">2&gt;file<br /></span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">重定向stderr到文件（1）<br /></span></td><td valign="top" style="border-width: 1px;border-style: solid"><img title="1524818191991552.png" alt="图片.png" src="/wp-content/uploads/image/20180427/1524818191991552.png" /></td></tr><tr><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">2&gt;/dev/null<br /></span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">将stderr错误信息重定向到/dev/null从而将它丢弃<br /></span></td><td valign="top" style="border-width: 1px;border-style: solid"><img title="1524818180473442.png" alt="图片.png" src="/wp-content/uploads/image/20180427/1524818180473442.png" /></td></tr><tr><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">&amp;&gt;file<br /></span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">将stdout和stderr合并到一个文件（1）<br /></span></td><td valign="top" style="border-width: 1px;border-style: solid"><img title="1524818174855912.png" alt="图片.png" src="/wp-content/uploads/image/20180427/1524818174855912.png" /></td></tr><tr><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">&gt;&gt;file 2&gt;&amp;1<br /></span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">合并stdout和stderr，并且附加到当前文件内容后面（2）（3）<br /></span></td><td valign="top" style="border-width: 1px;border-style: solid"><img title="1524818166553035.png" alt="图片.png" src="/wp-content/uploads/image/20180427/1524818166553035.png" /></td></tr><tr><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">注<br /></span></td><td valign="top" style="border-width: 1px;border-style: solid" rowspan="1" colspan="2"><p><span style="font-family: 宋体, SimSun">（1）覆盖现在文件，如果为新文件则创建文件</span></p><p><span style="font-family: 宋体, SimSun">（2）附加到现有文件，如果为新文件则创建文件</span></p><p><span style="font-family: 宋体, SimSun">（3）重定向顺向很重要，可避免出现意外的命令行为。2&gt;&amp;1 将stderr发送到与stdout相同的位置。要使其生效，在向stdout中添加stderr之前，需要首先重定向stdout.尽管&amp;&gt;&gt;是向文件中附加stdout和stderr的备选方法，但2&gt;&amp;1 是通过管道同时发送stdout和stderr所需要的方法。</span></p></td></tr></tbody></table><pre class="brush:bash;toolbar:false">date&nbsp;&gt;&nbsp;/tmp/saved-timestamp&nbsp;&nbsp;&nbsp;&nbsp;#保存时间到文件
tail&nbsp;-n&nbsp;100&nbsp;/var/log/dmesg&nbsp;&gt;&nbsp;/tm/last-100-boot-messages&nbsp;&nbsp;&nbsp;&nbsp;#复制文件日志的最后100行到另一个文件
cat&nbsp;file1&nbsp;file2&nbsp;file3&nbsp;file4&nbsp;&gt;&nbsp;/tmp/all-four-in-one&nbsp;&nbsp;&nbsp;&nbsp;#将四个文件连接成一个
ls&nbsp;-a&nbsp;&gt;&nbsp;/tmp/my-file-names&nbsp;&nbsp;&nbsp;&nbsp;#将当前目录的隐藏文件名和常规文件名列出到文件中
echo&nbsp;&quot;new&nbsp;line&nbsp;of&nbsp;information&quot;&nbsp;&gt;&gt;/tmp/many-lines-of-information&nbsp;&nbsp;&nbsp;&nbsp;#将输出附加到现有文件
diff&nbsp;previous-file&nbsp;current-file&nbsp;&gt;&gt;&nbsp;/tmp/tracking-changes-made&nbsp;&nbsp;&nbsp;&nbsp;#将比较内容输出附加到现有文件</pre><p><br /></p><pre class="brush:bash;toolbar:false">find&nbsp;/etc&nbsp;-name&nbsp;passwd&nbsp;2&gt;&nbsp;/tmp/errors&nbsp;&nbsp;&nbsp;&nbsp;#将错误重定向到文件
find&nbsp;/etc&nbsp;-name&nbsp;passwd&nbsp;&gt;/tmp/output&nbsp;2&gt;&nbsp;/tmperrors&nbsp;&nbsp;&nbsp;&nbsp;#将进程输出和错误消息分别保存到单独文件
find&nbsp;/etc&nbsp;-name&nbsp;passwd&nbsp;&gt;/tmp/output&nbsp;2&gt;/dev/null&nbsp;&nbsp;&nbsp;&nbsp;#忽略并丢弃错误消息
find&nbsp;/etc&nbsp;-name&nbsp;passwd&nbsp;&amp;&gt;&nbsp;/tmp/save-both&nbsp;&nbsp;&nbsp;&nbsp;#将输出和错误消息存储在一起
find&nbsp;/etc&nbsp;-name&nbsp;passwd&nbsp;&nbsp;&gt;&gt;&nbsp;/tmp/save-toth&nbsp;2&gt;&amp;1&nbsp;&nbsp;&nbsp;&nbsp;#将输出和生成的错误消息附加到现有文件</pre><p><span style="font-family: 宋体,SimSun;font-size: 24px">构建管道 “|”</span></p><p>从一个进程标准输出到另一个进程的标准输入</p><p><img title="1524823380758403.png" alt="image.png" src="/wp-content/uploads/image/20180427/1524823380758403.png" /></p><p><br /></p><pre class="brush:bash;toolbar:false">ls&nbsp;-l&nbsp;/usr/bin&nbsp;|&nbsp;less
ls&nbsp;|&nbsp;wc&nbsp;-l&nbsp;&gt;&nbsp;/tmp/how-many-files&nbsp;&nbsp;&nbsp;&nbsp;#计算输出列出中的行数并重定向到文件
ls&nbsp;-t&nbsp;|&nbsp;head&nbsp;-n&nbsp;10&nbsp;&gt;&nbsp;/tmp/ten-last-changed-files&nbsp;&nbsp;&nbsp;&nbsp;#抓取列表的前几行、或后几行，或选定的行并重定向到文件</pre><p><img title="1524823368317604.png" alt="image.png" src="/wp-content/uploads/image/20180427/1524823368317604.png" /></p><p><span style="font-family: 宋体,SimSun">使用 tee 命令传送，tee 命令显示或重定向通常因传送而被隐藏的中间结果。</span></p><pre class="brush:bash;toolbar:false">ls&nbsp;-l&nbsp;|&nbsp;tee&nbsp;/tmp/saved-output&nbsp;&nbsp;&nbsp;&nbsp;#在终端上查看&nbsp;ls&nbsp;列表同时将该列表存储到文件中</pre><p><br /></p><pre class="brush:bash;toolbar:false">#确定当前窗口的终端设备。将结果作为邮件发送，并在此窗口中查看相同的结果。
tty
ls&nbsp;-l&nbsp;|&nbsp;tee&nbsp;/dev/pts/0&nbsp;|&nbsp;mail&nbsp;-s&nbsp;subject&nbsp;student@desktop1.example.com</pre><hr /><p>vi &amp;&amp; vim</p><p><img title="1524823338808284.png" alt="image.png" src="/wp-content/uploads/image/20180427/1524823338808284.png" /></p><p><span style="font-family: 宋体,SimSun">vim 的四个模式：编辑模式，命令模式，可视模式，扩展命令模式。默认启动进行命令模式，可用于导航、剪切和粘贴，以及其他文件操作，通过单字符进行各个模式：</span></p><p><span style="font-family: 宋体,SimSun">&quot;i&quot; 进入插入模式，编辑模式，按Esc 退出到命令模式</span></p><p><span style="font-family: 宋体,SimSun">&quot;v&quot; 进入可视模式，在其中可以选择多个字符进行操作，使用&quot;V&quot;键选择多选，使用Ctrl+v 可选择文本块。v,V,Ctrl+v 同样可用于退出可视模式</span></p><p><span style="font-family: 宋体,SimSun">&quot;:&quot; 冒号,启动扩展命令模式,可以执行写入、退出、保存等</span></p><p><span style="font-family: 宋体,SimSun">命令模式：u键撤销上次的编辑操作，x键删除光标所在的字符，:w 保存 :wq 保存退出 &nbsp;:q! 强制退出放弃修改。</span></p><p><span style="font-family: 宋体,SimSun">可视模式：y ：复制，p：粘贴 ，上下左右选择字符。</span></p><p><span style="font-family: 宋体,SimSun">安装vim-enhanced软件包提供vimtutor针对每一个操作的练习。可以安装学习一下</span></p><p><span style="font-family: 宋体,SimSun">图形编辑器gedit 、nano </span></p><p><br /></p>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>284</wp:post_id>
		<wp:post_date><![CDATA[2018-04-27 16:49:36]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-04-27 08:49:36]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[chapter-4-creatingviewingand-editing-text-files]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="rhel124"><![CDATA[RHEL124]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_page_template]]></wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[hestia_layout_select]]></wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_old_date]]></wp:meta_key>
			<wp:meta_value><![CDATA[2018-04-26]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title></title>
		<link>https://www.rhel.tk/?p=459</link>
		<pubDate>Mon, 30 Nov -0001 00:00:00 +0000</pubDate>
		<dc:creator><![CDATA[change_lee]]></dc:creator>
		<guid isPermaLink="false">https://www.rhel.tk/?p=459</guid>
		<description></description>
		<content:encoded><![CDATA[<pre class="brush:bash;">
echo aaa
cat /etc/passwd
</pre>

<p>
	fdfdf
</p>

<p>
	&nbsp;
</p>

<p>
	&nbsp;
</p>

<p>
	&nbsp;
</p>

<p>
	&nbsp;
</p>

<p>
	&nbsp;
</p>

<p>
	&nbsp;
</p>

<p>
	&nbsp;
</p>
]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>459</wp:post_id>
		<wp:post_date><![CDATA[2018-10-11 15:36:28]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[0000-00-00 00:00:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[]]></wp:post_name>
		<wp:status><![CDATA[draft]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="uncategorized"><![CDATA[未分类]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[hestia_layout_select]]></wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title></title>
		<link>https://www.rhel.tk/?p=464</link>
		<pubDate>Mon, 30 Nov -0001 00:00:00 +0000</pubDate>
		<dc:creator><![CDATA[change_lee]]></dc:creator>
		<guid isPermaLink="false">https://www.rhel.tk/?p=464</guid>
		<description></description>
		<content:encoded><![CDATA[<span style="color: #222222; font-family: monospace;"><span style="background-color: #e9ebec;">echo aaa </span></span>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>464</wp:post_id>
		<wp:post_date><![CDATA[2018-10-11 15:44:42]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[0000-00-00 00:00:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[]]></wp:post_name>
		<wp:status><![CDATA[draft]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="uncategorized"><![CDATA[未分类]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[hestia_layout_select]]></wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title></title>
		<link>https://www.rhel.tk/?p=533</link>
		<pubDate>Mon, 30 Nov -0001 00:00:00 +0000</pubDate>
		<dc:creator><![CDATA[change_lee]]></dc:creator>
		<guid isPermaLink="false">https://www.rhel.tk/?p=533</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:table -->
<table class="wp-block-table"><tbody><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table>
<!-- /wp:table -->

<!-- wp:paragraph -->
<p>fdfdfdf</p>
<!-- /wp:paragraph -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>533</wp:post_id>
		<wp:post_date><![CDATA[2019-01-02 20:39:41]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[0000-00-00 00:00:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[]]></wp:post_name>
		<wp:status><![CDATA[draft]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="uncategorized"><![CDATA[未分类]]></category>
	</item>
	<item>
		<title>RH254 控制服务和守护进程</title>
		<link>https://www.rhel.tk/?p=566</link>
		<pubDate>Mon, 30 Nov -0001 00:00:00 +0000</pubDate>
		<dc:creator><![CDATA[blogs]]></dc:creator>
		<guid isPermaLink="false">https://www.rhel.tk/?p=566</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>使用systemctl 控制服务</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>系统启动和服务器进程由systemd 系统和服务管理器进行管理。此程序提供了一种方式，可以在启动时和运行中的系统上激活系统资源、服务器守护进程和其他进程。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>守护 进程是在执行我各种任务的后台等待或运行的进程。为了侦听连接，守护进程使用套接字。套接字可以由守护进程创建，或者与守护进程分离，并且可能由另一个进程创建（systemd），随后在客户端建立老婆如甲方将套接字为传递到守护进程。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>服务通常指的是一个或多个守护进程，但启动或停止一项服务可能会对系统的状态进行一次性更改（如配置网络接口），不会留下守护进程之后继续运行。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>一点历史</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>许多年来，Linux 和 unix 系统的进程ID 1 属于 init 进程。此进程负责激活系统上的其他服务。常用的守护进程在系统启动时通过System V 和 Linux Standard Base(LSB) init 脚本启动。较不常用的守护进程由其他服务根据需要启动，如 init 或 Xinetd 。这些系统存在诸多限制，但 systemd 可以解决。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>在RHEL 7 中进程ID 1 属于systemd 这一新的init ，以下是 systemd 系统提供的几项新功能：</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>并行化功能，它可提高系统的启动速度。</li><li>按需启动守护进程，而不需要单独的服务。</li><li>自动服务依赖关系管理可以防止长时间超时，例如在网络不可用时不启动网络服务。</li><li>利用 Linux 控制组一起追踪相关进程的方式。</li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>注意</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>有了 systemd ，基于 shell 的服务脚本仅用于几个传统服务.因此，带有shell 变量的配置文件将被取代，如 /etc/sysconfig 中可找到的配置文件。仍在使用中的配置文件作为systemd 环境文件被纳入，并作为 NAME=VALUE 对进行读取。它们不再以 shell 脚本的形式提供。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>systemctl 和 systemd 单元</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>systemctl 命令用于管理各种类型的systemd 对象，他们称为单元。可以通过systemctl -t help 命令显示单元类型的列表。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>重要</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>systemctl 可以缩写或“省略”单元名称、进程树条目和单元说明，除非运行时带有 -l 选项。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>常用单元类型：</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>服务单元具有.service 扩展名，代表系统服务。这种单元用于启动经常访问的守护进程，如web 服务器</li><li>套接字单元具有.socket 扩展名，代表进程间通信（IPC）套接字。套接字的控制可能在建立客户端老婆如甲方传递到守护进程或新启动的服务。套接字单元用于延迟启动时的服务启动，或者按需启动不常使用的服务，这原则上类似使用xinetd 超级服务器按需启动的服务。</li><li>路径单元具有 .path 扩展名，用于将服务的激活推迟到特定文件系统更改发生之后。这通常用于使用假脱机目录，如打印系统。</li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>服务状态</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>可能通过 systemctl status name.type 查看服务的状。如果示提供单元类型，则 systemctl 将显示服务单元的状态（如果存在）</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code class="language-bash">[root@rhel ~]# systemctl status sshd.service
● sshd.service - OpenSSH server daemon
   Loaded: loaded (/usr/lib/systemd/system/sshd.service; enabled; vendor preset: enabled)
   Active: active (running) since Thu 2019-01-03 19:26:20 CST; 49s ago
     Docs: man:sshd(8)
           man:sshd_config(5)
 Main PID: 9232 (sshd)
   CGroup: /system.slice/sshd.service
           └─9232 /usr/sbin/sshd -D

Jan 03 19:26:20 rhel.tk systemd[1]: Starting OpenSSH server daemon...
Jan 03 19:26:20 rhel.tk sshd[9232]: Server listening on 0.0.0.0 port 22.
Jan 03 19:26:20 rhel.tk sshd[9232]: Server listening on :: port 22.
Jan 03 19:26:20 rhel.tk systemd[1]: Started OpenSSH server daemon.
Jan 03 19:26:58 rhel.tk sshd[9745]: Accepted password for root from 192.168.142.1 port 63462 ssh2
[root@rhel ~]# 
</code></pre>
<!-- /wp:code -->

<!-- wp:table -->
<table class="wp-block-table"><tbody><tr><td>关键字</td><td>描述</td></tr><tr><td>loaded</td><td>单元配置文件已经处理</td></tr><tr><td>active(running)</td><td>正在通过一个或多个持续进程运行</td></tr><tr><td>active(exited)</td><td>已完成一次性配置</td></tr><tr><td>active(waiting)</td><td>运行中，但正在等待事件</td></tr><tr><td>inactive</td><td>不在运行</td></tr><tr><td>enabled</td><td>将在系统启动时启动</td></tr><tr><td>disabled</td><td>不会在系统启动时启动</td></tr><tr><td>static</td><td>无法启动，但可以由某一启用的单元自动启动</td></tr></tbody></table>
<!-- /wp:table -->

<!-- wp:paragraph -->
<p>注意</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>systemctl status NAME 命令取代了旧版的 RHEL 中使用的service NAME status </p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>使用systemctl 列出单元文件</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code class="language-bash">#查询所有单元的状态以 验证系统启动
[root@rhel ~]# systemctl
#仅查询服务单元的状态
[root@rhel ~]# systemctl --type=service
#调查处于失败或者维护状态的任何单元。可选择添加 -l 选项以显示完整的输出。
[root@rhel ~]# systemctl status rngd.service -l
#也可使用 status 参数来判断特定的单元是否活动，以及显示该单元是否已启用在系统启动时启动。其他备用命令也可以轻松显示活动和已启用状态：
[root@rhel ~]# systemctl is-active sshd
[root@rhel ~]# systemctl is-enabled sshd
#列出所有已加载单元的活动状态。也可选择限制单元类型。--all 选项可加入不活动的单元
[root@rhel ~]# systemctl list-units --type=service
[root@rhel ~]# systemctl list-units --type=service --all
#列出所有单元的已启用和已禁用设置。也可选择限制单元类型。
[root@rhel ~]# systemctl list-unit-files --type=service
#仅查看失败的服务。
[root@rhel ~]# systemctl --faild --type=service</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>启动和停止运行中系统上的系统守护进程</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">启动、停止、重新启动、重新加载和验证状态是管理服务时经常执行的操作。</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>查看sshd 服务的状态。</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code class="language-bash">[root@rhel ~]# systemctl status sshd.service
● sshd.service - OpenSSH server daemon
   Loaded: loaded (/usr/lib/systemd/system/sshd.service; enabled; vendor preset: enabled)
   Active: active (running) since Thu 2019-01-03 19:26:20 CST; 1h 46min ago
     Docs: man:sshd(8)
           man:sshd_config(5)
 Main PID: 9232 (sshd)
   CGroup: /system.slice/sshd.service
           └─9232 /usr/sbin/sshd -D

Jan 03 19:26:20 rhel.tk systemd[1]: Starting OpenSSH server daemon...
Jan 03 19:26:20 rhel.tk sshd[9232]: Server listening on 0.0.0.0 port 22.
Jan 03 19:26:20 rhel.tk sshd[9232]: Server listening on :: port 22.
Jan 03 19:26:20 rhel.tk systemd[1]: Started OpenSSH server daemon.
Jan 03 19:26:58 rhel.tk sshd[9745]: Accepted password for root from 192.168.142.1 port 63462 ssh2
[root@rhel ~]# </code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>验证进程正在运行。</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code class="language-bash">[root@rhel ~]# ps -up 9232
USER        PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root       9232  0.0  0.1 112756  4316 ?        Ss   19:26   0:00 /usr/sbin/sshd -D</code></pre>
<!-- /wp:code -->

<!-- wp:image {"id":571} -->
<figure class="wp-block-image"><img src="https://www.rhel.tk/wp-content/uploads/2019/01/QQ截图20190103131704.png" alt="" class="wp-image-571" /><figcaption> <br>停止服务并验证其状态 </figcaption></figure>
<!-- /wp:image -->

<!-- wp:image {"id":575} -->
<figure class="wp-block-image"><img src="https://www.rhel.tk/wp-content/uploads/2019/01/QQ截图20190103143253.png" alt="" class="wp-image-575" /><figcaption>启动服务并查看状态。进程ID已经改变</figcaption></figure>
<!-- /wp:image -->

<!-- wp:image {"id":576} -->
<figure class="wp-block-image"><img src="https://www.rhel.tk/wp-content/uploads/2019/01/QQ截图20190103143415.png" alt="" class="wp-image-576" /><figcaption>以单一命令停止服务，然后再启动该服务</figcaption></figure>
<!-- /wp:image -->

<!-- wp:image {"id":578} -->
<figure class="wp-block-image"><img src="https://www.rhel.tk/wp-content/uploads/2019/01/QQ截图20190103143559.png" alt="" class="wp-image-578" /><figcaption>发出指示使用服务读取和重新加载配置文件，而不完全停止和启动服务。进程ID 不会改变</figcaption></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>单元依赖项</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>服务可能会以其他服务依赖项的形式启动。如果套接字单元已启动。但名称相同的服务单元没有启动，对该网络套接字发出请求时将自动启动该服务。服务也可能会在满足文件系统条件时由路径单元触发。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>systemctl  list-dependencies UNIT 命令可用于显示必须与特定单元联会启动的其他单元的树。此命令 --reverser 选项将显示哪些单元必须要在指定单元启动后才能运行。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>屏蔽服务</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>系统可能针对某一特定功能安装了有冲突的服务，如防火墙（iptables 和 firewalld ）。为防止管理员意外启动某一服务，可以屏蔽将在配置目录中创建链接，使得启动该服务时什么也不会发生。</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":581} -->
<figure class="wp-block-image"><img src="https://www.rhel.tk/wp-content/uploads/2019/01/image-1.png" alt="" class="wp-image-581" /></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>重要</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>禁用的服务不会在系统启动时自动启动，也不会被其他单元文件启动，但可以手动启动。屏蔽的服务无法手动启动，也不会自动启动。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>使守护进程在系统启动时启动或停止</p>
<!-- /wp:paragraph -->

<!-- wp:code {"className":"bash"} -->
<pre class="wp-block-code bash"><code class="language-bash">#查看服务的状态
[root@rhel ~]# systemctl status sshd.service
#禁用服务并验证其状态。请注意禁用服务不会停止该服务
[root@rhel ~]# systemctl disable sshd.service
[root@rhel ~]# systemctl status sshd.service
#启用服务并验证其状态
[root@rhel ~]# systemctl enable sshd.service
[root@rhel ~]# systemctl is-enabled sshd.service</code></pre>
<!-- /wp:code -->

<!-- wp:table {"className":".table"} -->
<table class="wp-block-table .table"><tbody><tr><td>命令</td><td>任务</td></tr><tr><td>systemctl status UNIT</td><td>查看有关单元状态的详细信息</td></tr><tr><td>systemctl stop UNIT</td><td>在运行中的系统上停止一项服务</td></tr><tr><td>systemctl start UNIT</td><td>在运行中的系统上启动一项服务</td></tr><tr><td>systemctl restart UNIT</td><td>在运行中的系统上重启一项服务</td></tr><tr><td>systemctl reload UNIT</td><td>重新加载运行中服务的配置文件</td></tr><tr><td>systemctl mask UNIT</td><td>彻底禁用服务，使其无法手动启动或在系统启动时启动</td></tr><tr><td>systemctl umask UNIT</td><td>使屏蔽的服务变为可用</td></tr><tr><td>systemctl enable UNIT</td><td>将服务配置为在系统启动时启动</td></tr><tr><td>systemctl disable UNIT</td><td>禁止服务在系统启动时启动</td></tr><tr><td>systemctl list-dependencies UNIT</td><td>列出指定单元依赖的单元</td></tr></tbody></table>
<!-- /wp:table -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>566</wp:post_id>
		<wp:post_date><![CDATA[2019-01-03 21:35:53]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[0000-00-00 00:00:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[]]></wp:post_name>
		<wp:status><![CDATA[draft]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="rhel245"><![CDATA[RHEL245]]></category>
		<category domain="post_tag" nicename="systemctl"><![CDATA[systemctl]]></category>
		<category domain="post_tag" nicename="systemd"><![CDATA[systemd]]></category>
	</item>
	<item>
		<title>Chapter 5. Managing Local Linux Users and Groups</title>
		<link>https://www.rhel.tk/2018/04/30/chapter-5-managing-local-linux-users-and-groups/</link>
		<pubDate>Mon, 30 Apr 2018 13:59:23 +0000</pubDate>
		<dc:creator><![CDATA[blogs]]></dc:creator>
		<guid isPermaLink="false">https://www.rhel.tk/?p=295</guid>
		<description></description>
		<content:encoded><![CDATA[<p>id 命令用来显示当前已登录用户的信息</p><p>ls -l 查看文件关联的用户。第三列显示的是用户名，第四列是组</p><p>ps 显示当前shell的进程</p><p>ps a 显示所有进程</p><p>ps au 显示进程关联的用户</p><p>用户</p><p>/etc/passwd 文件格式（七个冒号分隔字段）</p><p><img title="1524823773815913.png" alt="image.png" src="/wp-content/uploads/image/20180427/1524823773815913.png" /></p><ol class=" list-paddingleft-2" style="list-style-type: decimal"><li><p>username 是UID到名称的一种映射，使用用户使用</p></li><li><p>password 以前是以加密格式保存密码的位置，现在密码存储在/etc/shadow的单独文件中</p></li><li><p>UID 是用户的ID</p></li><li><p>GID 是用户的主要组ID 编号</p></li><li><p>GECOS 字段是任意文件，通常包含用户的实际姓名，现在是描述</p></li><li><p>/home/dir 是用户的家目录</p></li><li><p>shell 是用户登录时运行的程序。对于普通用户通常是提供用户命令行的shell程序。</p></li></ol><p>组</p><p>保存在文件/etc/group 中</p><p>每个用户有且只有一个主要组，即passwd中的第三个字段。</p><p>通常用户创建的文件归主要组所有，通常用户主要组名和用户名相同，用户可以有0个或多个补充组</p><p><br /></p><p>su 切换命令<br /></p><p>su - &lt;username&gt;</p><p>su username 启动non-login shell&nbsp; &nbsp; #su 使用当前用户环境变量，不使用username的环境变量</p><p>su - username 启动login shell # - 会将用户的环境变量调用，和这个用户正常登陆一样</p><p>sudo 以root身份执行命令</p><p>sudo 命令可以使用用户根据/etc/sudoers文件中的设置，而被允许以root身份或其他用户身份运行命令，su 要求的是被切换用户的密码，而sudo 是输入自己的密码<br /></p><p>sudo usermod -L username</p><p>使用sudo执行的所用命令都会被记录到/var/log/secure 中，在RHEL7中wheel组的成员都可以使用sudo ，早期版本wheel组用户默认没有这个权限（取消wheel组运行命令前的注释就可以了）</p><p>visudo 编辑/etc/sudoers文件更方便</p><p>大多数使用GUI的应用使用policykit提示用户进行身份认证，以及管理root访问权限</p><hr /><p>管理本地用户账户<br /></p><p>useradd 创建用户<br /></p><ul class=" list-paddingleft-2" style="list-style-type: disc"><li><p>不带选项运行时，useradd username 会为/etc/passwd中的所用字段设置合理的默认值，默认情况下useradd 不设置任何有效密码，用户也必须设置密码后才可以登陆</p></li><li><p>useradd --help 将显示可用于覆盖默认值的基本选项。在大多数情况，可以将相同的选项用于usermod命令</p></li><li><p>默认值从/etc/login.defs文件中读取，如有效的UID编号的范围和默认密码过期规则。此文件中的值仅在创建用户是使用，更改文件对现有用户无任何影响 &nbsp; &nbsp;</p></li></ul><p>usermod&nbsp; &nbsp; 修改现有用户</p><p>usermod --help 将显示可用于修改账户的基本选项，常见选项如下：</p><table><tbody><tr class="firstRow"><td valign="top" style="border-width: 1px;border-style: solid">usermod 常见选项</td><td valign="top" style="border-width: 1px;border-style: solid"><br /></td></tr><tr><td valign="top" style="border-width: 1px;border-style: solid">-c, --coment COMMENT</td><td valign="top" style="border-width: 1px;border-style: solid">向GECOS字段添加值，如全名</td></tr><tr><td valign="top" style="border-width: 1px;border-style: solid">-g, --gid GROUP</td><td valign="top" style="border-width: 1px;border-style: solid">为用户账户指定主要组</td></tr><tr><td valign="top" style="border-width: 1px;border-style: solid">-G, --group GROUPS</td><td valign="top" style="border-width: 1px;border-style: solid">为用户账户指定个组补充组</td></tr><tr><td valign="top" style="border-width: 1px;border-style: solid">-a, --append</td><td valign="top" style="border-width: 1px;border-style: solid">与-G选项搭配使用，将用户附加到所给的补充组，而不将该用户从其他组删除</td></tr><tr><td valign="top" style="border-width: 1px;border-style: solid">-d, --home HOME_DIR</td><td valign="top" style="border-width: 1px;border-style: solid">为用户账户指定新的主（家）目录</td></tr><tr><td valign="top" style="border-width: 1px;border-style: solid">-m, --move-home</td><td valign="top" style="border-width: 1px;border-style: solid">将用户主目录移到新的位置，必须与-d选项搭配使用</td></tr><tr><td valign="top" style="border-width: 1px;border-style: solid">-s,--shell SHELL</td><td valign="top" style="border-width: 1px;border-style: solid">为用户账户指定新的登陆SHELL</td></tr><tr><td valign="top" style="border-width: 1px;border-style: solid">-L, --lock</td><td valign="top" style="border-width: 1px;border-style: solid">锁定用户账户</td></tr><tr><td valign="top" style="border-width: 1px;border-style: solid">-U, --unlock</td><td valign="top" style="border-width: 1px;border-style: solid">解锁用户账户</td></tr></tbody></table><p><br /></p><p>userdel&nbsp;&nbsp;&nbsp;&nbsp;删除用户</p><p>userdel username 可将用户从/etc/passwd中删除，但默认情况下保留主目录不变。</p><p><span style="color: #FF0000">老用户删除后新用户将使用老用户的UID，原文件将在下次创建同等UID的用户是被授权给新用户</span>。</p><p>userdel -r username 同时删除用户和和其主目录。</p><p>find / -nouser -o -nogroup 2&gt;/dev/null #查找没有用户或者没有组的文件或目录</p><p>id 显示用户信息<br /></p><p>id username 将显示username的用户信息，包括用户的UID编号和组成员资格</p><p>passwd 设置密码<br /></p><p>passwd username &nbsp;#如果不使用username 将代表当前用户，root可以在不需要旧密码的情况下修改其他用户密码。</p><p>root 可以将密码设置成任何值，如果密码不符合要求，系统会有提示，但仍可以设置。</p><p>普通用户必须选择长度至少为8个字符，并且不以字典词语、用户名为密码基础</p><p>UID 范围</p><p>特定的UID编号和编号范围供RHEL用于特殊目的。</p><p>UID 0 始终分配给超级用户root</p><p>UID 1-200 是一系列“系统用户”，静态分配给红帽系统进程</p><p>UID 201-999 是一系列“系统用户”，供文件系统中没有自己的文件的系统进程使用，通常在安装需要他们的软件时，从可用池中动态分配它们。程序以这些“无特权”系统用户身份运行，以便限制它们访问正常运行所需的资源。</p><p>UID 1000+ 是可供分配给普通用户的范围。</p><p>RHEL7 以前的版本是UID 1-499 为系统用户，500+ 为普通用户。默认范围可以在/etc/login.defs中修改</p><p><br /></p><pre class="brush:bash;toolbar:false">useradd&nbsp;juliet&nbsp;&nbsp;&nbsp;&nbsp;#添加新用户
tail&nbsp;-2&nbsp;/etc/passwd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#查看最后两个用户
passwd&nbsp;juliet&nbsp;&nbsp;&nbsp;&nbsp;#修改juliet的密码</pre><p>管理本地组账户<br /></p><p>groupadd 创建组</p><p>groupadd groupname 如果不带选项，则使用/etc/login.defs文件的指定范围内的下一个可用GID</p><p>-g GID 选项用来指定具体的DIG</p><pre class="brush:bash;toolbar:false">groupadd&nbsp;-g&nbsp;500&nbsp;ateam&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#创建组</pre><p>用户专用组（GID 1000以上）是系统自动创建的，因此通常预备一系列GID编号待用于补充组，较高的范围可以避免与系统中GID（0-999）冲突<br /></p><p>-r 选项将使用/etc/login.defs中系统用户的GID编号分配</p><pre class="brush:bash;toolbar:false">groupadd&nbsp;-r&nbsp;appusers</pre><p>groupmod 修改现有的组<br /></p><p>-n 选项用于指定新的名称</p><pre class="brush:bash;toolbar:false">groupmod&nbsp;-n&nbsp;javaapp&nbsp;appusers&nbsp;&nbsp;&nbsp;&nbsp;#修改javaapp组为appusers</pre><p>-g 选项用于指定新的GID<br /></p><pre class="brush:bash;toolbar:false">groupmod&nbsp;-g&nbsp;6000&nbsp;ateam&nbsp;&nbsp;&nbsp;&nbsp;#修改ateam组的GID为6000</pre><p>groupdel 删除组<br /></p><pre class="brush:bash;toolbar:false">groupdel&nbsp;javaapp</pre><p>如果该组是当前某一用户的主要组，则他不能被删除，与userdel 一样检查文件系统，确保不会遗留该组拥有的任何文件</p><p>usermod 变更组成员资格</p><pre class="brush:bash;toolbar:false;">usermod&nbsp;-g&nbsp;groupname&nbsp;&nbsp;username&nbsp;&nbsp;&nbsp;#更改用户主要组
usermod&nbsp;-aG&nbsp;wheel&nbsp;elvis&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#将用户elvis添加进wheel补充组，如果不使用-a选项，用户将删除其他补充组</pre><p>管理用户密码<br /></p><pre class="brush:bash;toolbar:false">$6$4Sme7FVt$kIMTvWnXbLGVgpVz2xHuWWAY6AxLEG4rtUm/2NvXyocJe0uT/7rIxD.52GvFJR/txTihH8VatnZ.R65YnmZzL0
#以$符为分隔，共三段
#1、1.哈希算法，数字1表示MD5哈希，数字6为SHA-512哈希算法
#2、&quot;4Sme7FVt&quot;&nbsp;用于加密哈希的salt，这原先是随机选取的，salt和未加密的密码组合并加密。创建加密的哈希值，使用salt可以防止两个或多个相同密码的用户出现相同的条目
#3、&quot;kIMTvWnXbLGVgpVz2xHuWWAY6AxLEG4rtUm/2NvXyocJe0uT/7rIxD.52GvFJR/txTihH8VatnZ.R65YnmZzL0&quot;&nbsp;以加密的哈希值</pre><p>RHEL7 支持新密码哈希算法：SHA-256(算法5)，SHA-512（算法6）,root 用户通过使用authconfig --passslgo 命令，并从md5,sha-256和sha-512中选择一个适当的参数，7默认使用sha-512</p><pre class="brush:bash;toolbar:false">[change@rhel&nbsp;~]$&nbsp;sudo&nbsp;authconfig&nbsp;--help&nbsp;|&nbsp;grep&nbsp;passalgo
&nbsp;&nbsp;--passalgo=&lt;descrypt|bigcrypt|md5|sha256|sha512&gt;</pre><p>/etc/shadow 格式（九个冒号分隔的字段）</p><p><img src="/wp-content/uploads/image/20180501/1525166687554964.png" title="1525166687554964.png" alt="blob.png" width="824" height="61" /></p><p>登陆名称。这必须是系统中的有效账户名</p><p>以加密的密码。密码开通为！时表示该密码已被锁定。</p><p>最近一次更改密码的日期，以距离1970年1月1日的天数表示</p><p>可以更改密码前的最少天数，如果0表示“无最短期限要求”</p><p>必须修改密码前的最多天数。</p><p>密码即将到期的警告期，以天数表示。0表示不警告。</p><p>账户在密码过期后保持活动的天数，在此期限内，用户依然可以登录系统并修改密码。在指定天数过后，账户被锁定，变为不活动。</p><p>账户到期日期，以距离1970年1月1日的天数表示</p><p>这一blank 字段为预留字段，供未来使用</p><p><img src="/wp-content/uploads/image/20180501/1525167668913001.png" title="1525167668913001.png" alt="blob.png" width="648" height="392" /></p><pre class="brush:bash;toolbar:false">chage&nbsp;-d&nbsp;0&nbsp;username&nbsp;&nbsp;&nbsp;&nbsp;#强制用户在下次登录是修改密码
chage&nbsp;-l&nbsp;user&nbsp;&nbsp;&nbsp;&nbsp;#列出当前用户的设置
chage&nbsp;-E&nbsp;YYYY-MM-DD&nbsp;&nbsp;&nbsp;&nbsp;#将在指定日期是账户到期
date&nbsp;-d&nbsp;&quot;+45&nbsp;days&quot;&nbsp;&nbsp;&nbsp;&nbsp;#计算未来的日期
usermod&nbsp;-L&nbsp;romeo&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#锁定用户romeo
usermod&nbsp;-U&nbsp;romeo&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#解除锁定
chage&nbsp;-M&nbsp;90&nbsp;romeo&nbsp;&nbsp;&nbsp;&nbsp;#设置用户romeo&nbsp;每90天创建新密码</pre><p><br /></p>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>295</wp:post_id>
		<wp:post_date><![CDATA[2018-04-30 21:59:23]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-04-30 13:59:23]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[chapter-5-managing-local-linux-users-and-groups]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="rhel124"><![CDATA[RHEL124]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_page_template]]></wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[hestia_layout_select]]></wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Chapter 6 . Controlling Access to Files with Linux File system Permissions</title>
		<link>https://www.rhel.tk/2018/05/03/chapter-6-controlling-access-to-files-with-linux-file-system-permissions/</link>
		<pubDate>Thu, 03 May 2018 09:15:19 +0000</pubDate>
		<dc:creator><![CDATA[blogs]]></dc:creator>
		<guid isPermaLink="false">https://www.rhel.tk/?p=303</guid>
		<description></description>
		<content:encoded><![CDATA[<p><span style="font-family: 宋体, SimSun;font-size: 24px">Linux 文件系统权限 </span><span style="font-family: 宋体, SimSun"><br /></span></p><p><span style="font-family: 宋体, SimSun">文件具体三个应用权限 的用户类别。文件归用户所有，通常是创建文件的用户。文件归单个组所有，通常是创建文件的用户的主要组，但是可以进行更改。可以为所属用户、所属组和系统上的非用户和非所属组的其它用户设置不同的权限。三种应用权限 ：r,w,x（读、写、执行）<br /></span></p><table><tbody><tr class="firstRow"><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">权限<br /></span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">对文件的影响<br /></span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">对目录的影响<br /></span></td></tr><tr><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">r<br /></span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">可以读取文件的内容<br /></span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">可以列出目录的内容（文件名）<br /></span></td></tr><tr><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">w<br /></span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">可以更改文件内容<br /></span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">可以创建或删除目录中的文件<br /></span></td></tr><tr><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">x<br /></span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">可以作为命令执行文件<br /></span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">可以访问目录的内容（取决于目录中文件的权限）<br /></span></td></tr></tbody></table><p><span style="font-family: 宋体, SimSun">用户通常对目录具有r,x 权限，因此他们可以列出目录并访问其内容。如果用户只有 r 权限那只能列出文件名，其它信息都不可用。如果用户对目录只有 x 权限。则不能列出目录中的文件名，但是可以对已知文件名并有读取权限的文件通过明确指定文件名来访问文件的内容。对文件具有 w 权限的用户可以删除目录的文件，不论文件所属是谁（特殊权限除外）。</span></p><p><span style="font-family: 宋体, SimSun"></span></p><pre class="brush:bash;toolbar:false">ls&nbsp;-l&nbsp;file1&nbsp;&nbsp;&nbsp;&nbsp;#查看文件的所有权
ls&nbsp;-ld&nbsp;dir&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#查看目录的所有权</pre><p><span style="font-family: 宋体, SimSun"></span><br /></p><p><span style="font-family: 宋体, SimSun">与NTFS权限不同，linux 权限设置适用于设置了linux 权限的目录和文件，目录中的子目录和文件不会继承目录的权限。（但是目录的权限可以会阻止用户访问文件）</span></p><p><span style="font-family: 宋体, SimSun;font-size: 24px">更改文件/目录的权限</span></p><p><span style="font-family: 宋体, SimSun;font-size: 18px">#符号法</span><span style="font-family: 宋体, SimSun"><br /></span></p><p><span style="font-family: 宋体, SimSun">chmod WhoWhatWhich file|dir</span></p><p><span style="font-family: 宋体, SimSun">Who 是指 u , g , o , a&nbsp; (代表用户、组、其它、全部)<br /></span></p><p><span style="font-family: 宋体, SimSun">What 是指 + , - , = (代表添加、删除、精确设置)<br /></span></p><p><span style="font-family: 宋体, SimSun">Which 是指 r , w , x (代表读取、写入、可执行)</span></p><p><span style="font-family: 宋体, SimSun;font-size: 18px">#数值法</span></p><p><span style="font-family: 宋体, SimSun">chmod ### file | dir <br /></span></p><p><span style="font-family: 宋体, SimSun">每个数字代表一个访问级别：用户、组、其它</span></p><p><span style="font-family: 宋体, SimSun"># 是 r = 4 , w = 2 , x = 1 的和</span></p><p><span style="font-family: 宋体, SimSun">使用数值法，权限由3位（或者设置高级权限时4位）八进制数来表示。单一数值范围0-7</span></p><p><span style="font-family: 宋体, SimSun"></span></p><pre class="brush:bash;toolbar:false">chmod&nbsp;go-rw&nbsp;file1&nbsp;&nbsp;&nbsp;&nbsp;#删除组和其它的&nbsp;r,w&nbsp;权限
chmod&nbsp;a+x&nbsp;file2&nbsp;&nbsp;&nbsp;&nbsp;#为每个人添加x&nbsp;权限
chmod&nbsp;750&nbsp;sampledir&nbsp;&nbsp;&nbsp;&nbsp;#设置用户&nbsp;rwx&nbsp;,组&nbsp;rx&nbsp;&nbsp;,其它&nbsp;-&nbsp;无权限
#目录树递归设置权限使用&nbsp;-R&nbsp;选项。当使用此选项是，务必使用&nbsp;X&nbsp;权限，而不是&nbsp;x&nbsp;权限&nbsp;。表示应对目录而不是普通文件设置执行权限。
chmod&nbsp;-R&nbsp;g+rwX&nbsp;demodir&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#对demodir&nbsp;目录及其子目录设置rwx&nbsp;权限&nbsp;，对目录中的文件设置rw&nbsp;权限</pre><p><span style="font-family: 宋体, SimSun"></span><br /></p><p><span style="font-family: 宋体, SimSun;font-size: 24px">更改文件/目录的用户或组所有权</span></p><p><span style="font-family: 宋体, SimSun"></span></p><pre class="brush:bash;toolbar:false">chown&nbsp;&nbsp;student&nbsp;foofile&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#修改文件foofile&nbsp;的所有都为student
chown&nbsp;-R&nbsp;student&nbsp;foodir&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#修改目录及其子文件、目录的所有都为student
chown&nbsp;:admins&nbsp;foodri&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#修改目录的所属组为admins
chown&nbsp;visitor:guests&nbsp;foodir&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#修改目录的所属者visitor,所属组guests&nbsp;
#只能root用户可以更改文件所有权。但是，root&nbsp;或文件的所有者可以设置组所有权。root&nbsp;用户可将所有权授予任何组，非root用户可将所有权授予他们所属的组。</pre><p><span style="font-family: 宋体, SimSun"></span><br /></p><p><span style="font-family: 宋体, SimSun;font-size: 24px">默认权限和文件访问</span></p><p><span style="font-family: 宋体, SimSun;font-size: 18px">特殊权限</span></p><p><span style="font-family: 宋体, SimSun">对可执行文件的setuid (或setgid)权限表示将以文件所属用户（或组）身份执行，而不是运行命令的用户身份。</span></p><p><span style="font-family: 宋体, SimSun">目录的粘滞位可以为文件的删除设置特殊权限：仅文件所属者或root用户可以删除。</span></p><p><span style="font-family: 宋体, SimSun">对于目录的setgid 权限表示 在该目录中创建的文件将继承目录组所属关系，而不是继承自用户。这通常用于组协作目录，将文件从默认的专有组自动更改成共享组。</span></p><table><tbody><tr class="firstRow"><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">权限<br /></span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">对文件的影响<br /></span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">对目录的影响<br /></span></td></tr><tr><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">u+s (suid)<br /></span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">以文件所属者身份运行，而非运行命令的用户身份<br /></span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">无<br /></span></td></tr><tr><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">g+s (sgid)<br /></span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">对文件所属组身份执行文件<br /></span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">在目录中最新创建的文件将其所属组设置为和目录所属组相匹配<br /></span></td></tr><tr><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">o+t (sticky)<br /></span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">无<br /></span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">对目录有写入权限的用户仅可删除自己创建的文件，无法删除或强制保存到其它用户拥有的文件<br /></span></td></tr></tbody></table><p><span style="font-family: 宋体, SimSun;font-size: 18px">设置特殊权限</span></p><p><span style="font-family: 宋体, SimSun">符号法：setuid = u+s ,setgid = g+s ，sticky = o+t <br /></span></p><p><span style="font-family: 宋体, SimSun">数值法：(4位第1位) setuid = 4, setgid = 3 ,sticky =1</span></p><p><span style="font-family: 宋体, SimSun"></span></p><pre class="brush:bash;toolbar:false">chmod&nbsp;g+s&nbsp;dir&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#在dir目录添加setgid位
chmod&nbsp;2770&nbsp;dir&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#在dir目录设置setgid，并对目录的用户和组设置&nbsp;rwx&nbsp;权限</pre><p><span style="font-family: 宋体, SimSun"></span><br /></p><p><span style="font-family: 宋体, SimSun;font-size: 18px">默认文件权限</span></p><p><span style="font-family: 宋体, SimSun">bash shell 用户的默认umask 在/etc/profile 和 /etc/bashrc 文件中定义。用户可以修改家目录下的.profile 和&nbsp; .bashrc 文件来覆盖系统值。设置umask 少于3位时，默认前导为0。</span></p><p><span style="font-family: 宋体, SimSun">0002 清除其它用户的写入权限，077 删除用户所属组和其它的所有权限。</span></p><p><br /></p><p><br /></p><p><br /></p>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>303</wp:post_id>
		<wp:post_date><![CDATA[2018-05-03 17:15:19]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-05-03 09:15:19]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[chapter-6-controlling-access-to-files-with-linux-file-system-permissions]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="rhel124"><![CDATA[RHEL124]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_page_template]]></wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[hestia_layout_select]]></wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>RH134 第一章 使用kickstart自动安装</title>
		<link>https://www.rhel.tk/2018/05/05/rh134-%e7%ac%ac%e4%b8%80%e7%ab%a0-%e4%bd%bf%e7%94%a8kickstart%e8%87%aa%e5%8a%a8%e5%ae%89%e8%a3%85/</link>
		<pubDate>Sat, 05 May 2018 05:24:56 +0000</pubDate>
		<dc:creator><![CDATA[blogs]]></dc:creator>
		<guid isPermaLink="false">https://www.rhel.tk/?p=312</guid>
		<description></description>
		<content:encoded><![CDATA[<p><span style="font-family: 宋体, SimSun">Kickstart 配置文件以一个命令列表开关，这些命令定义将如何安装目录计算机。以#字符开关的行是安装程序将会忽略的注释。其它部分开头是以%字符打头的行，结尾是包含%end指令的行。</span></p><p><span style="font-family: 宋体, SimSun">%packages 部分指定要在目标系统上安装的软件，单个软件包可以根据名称（不带版本）指定。</span></p><p><span style="font-family: 宋体, SimSun">软件包组可以根据名称或ID指定。并以@字符开关。</span></p><p><span style="font-family: 宋体, SimSun">环境组（软件包组的组）可使用@^ 指定，后面紧跟环境组名或ID。组具有必需、默认和可选组件。通常kickstart 将安装必需组件和默认组件。</span></p><p><span style="font-family: 宋体, SimSun">以 - 字符开头的软件包或组名将补排除在安装以外，除非它们为必需，或因其它软件包的RPM依赖关系而安装。</span></p><p><span style="font-family: 宋体, SimSun">还有两个部分是%pre 和%post 脚本。%post 更为常见。它在所有软件都已安装后对系统进程配置。%pre 脚本在进行任何磁盘分区之前执行。</span></p><p><span style="font-family: 宋体, SimSun">必需先指定配置命令。%pre 、 %post 和%packages 可以在配置命令之后以任何顺序出现。<br /></span></p><p><span style="font-family: 宋体, SimSun"></span></p><p><span style="font-family: 宋体, SimSun">kickstart 配置文件命令</span></p><p><span style="font-family: 宋体, SimSun">安装命令</span></p><p><span style="font-family: 宋体, SimSun">url:指定安装介质位置</span></p><pre class="brush:bash;toolbar:false">url&nbsp;--url=&quot;ftp://install&nbsp;server.example.com/pub/RHEL7/dvd&quot;</pre><p><span style="font-family: 宋体, SimSun"></span><br /></p><p><span style="font-family: 宋体, SimSun">repo : 此选项告知Anaconda 在何处查找安装软件包。此选项必须指向有效的yum 存储库。</span></p><pre class="brush:bash;toolbar:false">repo&nbsp;--name=&quot;Custom&nbsp;Packages&quot;&nbsp;--baseurl=&quot;ftp://repo.example.com/custom&quot;</pre><p><a href="http://ftp://repo.example.com/custom&quot;" style="font-family: 宋体, SimSun;text-decoration: underline"><span style="font-family: 宋体, SimSun"></span></a><br /></p><p><span style="font-family: 宋体, SimSun">text: 强制进行文本模式安装</span></p><p><span style="font-family: 宋体, SimSun">vnc:允许通过VNC远程查看图形安装。</span></p><pre class="brush:bash;toolbar:false">vnc&nbsp;--password=redhat</pre><p><span style="font-family: 宋体, SimSun"></span><br /></p><p><span style="font-family: 宋体, SimSun">askmethod:当CD-ROM 驱动器中检测到安装介质时，不自动使用CD-ROM作为软件包来源。</span></p><p><span style="font-family: 宋体, SimSun">分区命令：</span></p><p><span style="font-family: 宋体, SimSun">clearpart:在安装之前清除指定分区</span></p><pre class="brush:bash;toolbar:false">clearpart&nbsp;--all&nbsp;--drives=sda,sdb&nbsp;--initlabel</pre><p><span style="font-family: 宋体, SimSun"></span><br /></p><p><span style="font-family: 宋体, SimSun">part: 指定分区大小、格式、名称</span></p><pre class="brush:bash;toolbar:false">part&nbsp;/home&nbsp;--fstype=ext4&nbsp;--label=homes&nbsp;--size=4096&nbsp;--maxsize=8192&nbsp;--grow</pre><p><span style="font-family: 宋体, SimSun"></span><br /></p><p><span style="font-family: 宋体, SimSun">ignoredisk: 安装的时候忽略指定盘</span></p><pre class="brush:bash;toolbar:false">ignoredsk&nbsp;--drives=sdc</pre><p><span style="font-family: 宋体, SimSun"></span><br /></p><p><span style="font-family: 宋体, SimSun">bootloader :定义安装引导分区</span></p><pre class="brush:bash;toolbar:false">bootloader&nbsp;--location=mbr&nbsp;--boot-drive=sda</pre><p><span style="font-family: 宋体, SimSun"></span><br /></p><p><span style="font-family: 宋体, SimSun">volgroup,logvol: 创建LVM卷组和逻辑卷</span></p><p><span style="font-family: 宋体, SimSun"></span></p><pre class="brush:bash;toolbar:false;">part&nbsp;pv.01&nbsp;--size=8192
volgroup&nbsp;myvg&nbsp;pv.01
logvol&nbsp;/&nbsp;--vgname=myvg&nbsp;--fstype=xfs&nbsp;--size=2048&nbsp;--name=rootvol&nbsp;--grow
logvol&nbsp;/var&nbsp;--vgname=myvg&nbsp;--fstype=xfs&nbsp;--size=4096&nbsp;--name=varvol</pre><p><span style="font-family: 宋体, SimSun"></span><br /></p><p><span style="font-family: 宋体, SimSun">zerombr: 格式未被识别的磁盘将被初始化。</span></p><p><span style="font-family: 宋体, SimSun">网络命令</span></p><p><span style="font-family: 宋体, SimSun">network:配置目标系统的网络信息，并激活安装程序环境中的网络设备。</span></p><pre class="brush:bash;toolbar:false">network&nbsp;--device=eth0&nbsp;--bootproto=dhcp</pre><p><span style="font-family: 宋体, SimSun"></span><br /></p><p><span style="font-family: 宋体, SimSun">firewall : 此选项定义在目标系统上如何配置防火墙</span></p><pre class="brush:bash;toolbar:false">firewall&nbsp;--enabled&nbsp;--service=ssh,cups</pre><p><span style="font-family: 宋体, SimSun"></span><br /></p><p><span style="font-family: 宋体, SimSun">配置命令：</span></p><p><span style="font-family: 宋体, SimSun">lang : 此必需命令设置安装时需要使用的语言和已经安装系统的默认语言</span></p><pre class="brush:bash;toolbar:false">lang&nbsp;en_US.UTF-8</pre><p><span style="font-family: 宋体, SimSun"></span><br /></p><p><span style="font-family: 宋体, SimSun">keyboard: 此必需命令，设置系统键盘类型。</span></p><pre class="brush:bash;toolbar:false">keyboard&nbsp;--vckeymap=us&nbsp;--xlayouts=&#039;us&#039;,&#039;us&#039;</pre><p><span style="font-family: 宋体, SimSun"></span><br /></p><p><span style="font-family: 宋体, SimSun">timezone :定义时区、NTP server及硬件时钟是否使用UTC</span></p><pre class="brush:bash;toolbar:false">timezone&nbsp;--utc&nbsp;--ntpservers=time.example.com&nbsp;Europe/amsterdam</pre><p><span style="font-family: 宋体, SimSun"></span><br /></p><p><span style="font-family: 宋体, SimSun">auth: 此必需选项设置系统身份认证选项</span></p><pre class="brush:bash;toolbar:false">auth&nbsp;--useshadow&nbsp;--enablemd5&nbsp;--passalgo=sha512</pre><p><span style="font-family: 宋体, SimSun"></span><br /></p><p><span style="font-family: 宋体, SimSun">rootpw: 定义root初始密码</span></p><p><span style="font-family: 宋体, SimSun"></span></p><pre class="brush:bash;toolbar:false">rootpw&nbsp;--plaintext&nbsp;redhat&nbsp;&nbsp;&nbsp;&nbsp;#明文
rootpw&nbsp;--iscrypted&nbsp;$6$KUnFfrTzOBjv.PiH$YlBbOtXBkWzoMuRfb0.SpbQ....XDR1UuchoMG1&nbsp;&nbsp;&nbsp;&nbsp;#加密</pre><p><span style="font-family: 宋体, SimSun"></span><br /></p><p><span style="font-family: 宋体, SimSun">selinux : 设置安装系统后selinux状态</span></p><pre class="brush:bash;toolbar:false">selinux&nbsp;--enforcing</pre><p><span style="font-family: 宋体, SimSun"></span><br /></p><p><span style="font-family: 宋体, SimSun">services : 修改默认运行级别下将运行的默认服务集合。</span></p><pre class="brush:bash;toolbar:false">services&nbsp;--disabled=network,iptables,ip6tables&nbsp;--enabled=NetworkManager,firewalld</pre><p><span style="font-family: 宋体, SimSun"></span><br /></p><p><span style="font-family: 宋体, SimSun">group,user :在系统上创建本地用户和组</span></p><p><span style="font-family: 宋体, SimSun"></span></p><pre class="brush:bash;toolbar:false">group&nbsp;--name=admins&nbsp;--gid=1001
user&nbsp;--name=jode&nbsp;--gecos=&quot;john&nbsp;doe&quot;&nbsp;--groups=admins&nbsp;--password=changeme&nbsp;--plaintext</pre><p><span style="font-family: 宋体, SimSun"></span><br /></p><p><span style="font-family: 宋体, SimSun">杂项命令：</span></p><p><span style="font-family: 宋体, SimSun">logging :此命令定义安装期间Anaconda 将如何进行日志记录。</span></p><pre class="brush:bash;toolbar:false">logging&nbsp;--host=loghost.example.com&nbsp;--level=info</pre><p><span style="font-family: 宋体, SimSun"></span><br /></p><p><span style="font-family: 宋体, SimSun">firstboot: 确定系统首次启动时firestboot 是否启动</span></p><pre class="brush:bash;toolbar:false">firstboot&nbsp;--disabled</pre><p><span style="font-family: 宋体, SimSun"></span><br /></p><p><span style="font-family: 宋体, SimSun">reboot、poweroff 、halt ： 指定安装结束后就发生什么情况。<br /></span></p><p><span style="font-family: 宋体, SimSun;color: #92D050">pykickstart软件包中的ksverdiff 程序可以识别两个版本间kickstart文件语法中的区别，如ksverdiff -f RHEL6 -t RHEL7 ,将识别RHEL6到RHEL7 的语法更改。可用版本在/usr/lib/python2.7/sit-packages/pykickstart/version.py。yum install pykickstart 。</span><br /></p><p><br /></p><hr /><p><span style="font-size: 18px">命令部分参考：</span></p><p><img src="/wp-content/uploads/image/20180504/1525422261580488.png" title="1525422261580488.png" alt="图片.png" /></p><p><span style="font-size: 18px">安装软件部分</span></p><p><img src="/wp-content/uploads/image/20180504/1525422300234129.png" title="1525422300234129.png" alt="图片.png" /></p><p><span style="font-size: 18px">配置脚本部分</span></p><p><img src="/wp-content/uploads/image/20180504/1525422328135998.png" title="1525422328135998.png" alt="图片.png" /></p><p><img src="/wp-content/uploads/image/20180504/1525422388734744.png" title="1525422388734744.png" alt="图片.png" /></p><p><span style="font-family: 宋体, SimSun">使用system-config-kickstart 创建kickstart文件。或者使用编辑器创建kickstart文件（参考anaconda-ks.cfg 默认在root的家目录下），使用编辑的几种情况：</span></p><p><span style="font-family: 宋体, SimSun">1、GUI或system-config-kickstart 不可用</span></p><p><span style="font-family: 宋体, SimSun">2、需要高级磁盘分区配置说明。system-config-kickstart 不支持LVM和RAID</span></p><p><span style="font-family: 宋体, SimSun">3、需要包含或者忽略单个包（而不仅仅是组）</span></p><p><span style="font-family: 宋体, SimSun">4、%prc 和%post 需要更高级的脚本。<br /></span></p><p><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun">ksvalidator 检查配置语法，它将确保关键字和选项的正确使用，无法验证url路径、单个数据包或组，也无法验证%post 和%pre 脚本的任何部分</span></span></p><p><span style="font-family: 宋体, SimSun"><span style="font-family: 宋体, SimSun">通过修改系统启动项，指定配置文件。<br /></span></span></p><table><tbody><tr class="firstRow"><td style="border-width: 1px;border-style: solid" valign="top">启动方式<br /></td><td style="border-width: 1px;border-style: solid" valign="top">指定配置文件方式<br /></td></tr><tr><td style="border-width: 1px;border-style: solid" valign="top">网络服务器,FTP,HTTP,NFS<br /></td><td style="border-width: 1px;border-style: solid" valign="top"><p>ks=<a href="http://server/dir/file">http://server/dir/file</a><br /></p><p>ks=<a href="http://ftp://server/dir/file">ftp://server/dir/file</a><br /></p><p>ks=nfs:server:/dir/file</p><p><br /> </p></td></tr><tr><td style="border-width: 1px;border-style: solid" valign="top">USB磁盘或CD-ROM<br /></td><td style="border-width: 1px;border-style: solid" valign="top"><p>ks=hd:device:/dir/file</p><p>ks=cdrom:/dir/file<br /></p></td></tr></tbody></table><p><a href="https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/7/html/installation_guide/sect-kickstart-syntax" target="_blank" style="font-size: 24px;text-decoration: underline"><span style="font-size: 24px">完整参数介绍</span></a><br /></p>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>312</wp:post_id>
		<wp:post_date><![CDATA[2018-05-05 13:24:56]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-05-05 05:24:56]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[rh134-%e7%ac%ac%e4%b8%80%e7%ab%a0-%e4%bd%bf%e7%94%a8kickstart%e8%87%aa%e5%8a%a8%e5%ae%89%e8%a3%85]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="rhel134"><![CDATA[RHEL134]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_page_template]]></wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[hestia_layout_select]]></wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_old_date]]></wp:meta_key>
			<wp:meta_value><![CDATA[2018-05-04]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>RH134 第二章 通过GREP使用正则表达式</title>
		<link>https://www.rhel.tk/2018/05/06/%e7%ac%ac%e4%ba%8c%e7%ab%a0-%e9%80%9a%e8%bf%87grep%e4%bd%bf%e7%94%a8%e6%ad%a3%e5%88%99%e8%a1%a8%e8%be%be%e5%bc%8f/</link>
		<pubDate>Sun, 06 May 2018 06:15:16 +0000</pubDate>
		<dc:creator><![CDATA[blogs]]></dc:creator>
		<guid isPermaLink="false">https://www.rhel.tk/?p=323</guid>
		<description></description>
		<content:encoded><![CDATA[<p><span style="font-family: 宋体, SimSun">行定位符：行首 ^ 行尾 $<br /></span></p><p><span style="font-family: 宋体, SimSun">^cat 匹配cat 开头的行</span></p><p><span style="font-family: 宋体, SimSun">dog$ 匹配dog 结尾的行</span></p><p><span style="font-family: 宋体, SimSun">^cat$&nbsp;&nbsp;&nbsp;&nbsp;匹配只有cat的行</span></p><p><span style="font-family: 宋体, SimSun">另一种定位符是字边界。\&lt;和\&gt; 可分别用于匹配一个字词的开头和结尾</span></p><p><span style="font-family: 宋体, SimSun">通配符和倍数<br /></span></p><p><span style="font-family: 宋体, SimSun">正则表达式使用 “.”作为无限制通配符。 正则表达式 c.t 将会依次查找包含 c、任一字符和 t 的数据。比如：cat ,cot ,c5t ,cQt 等等。</span></p><p><span style="font-family: 宋体, SimSun">有限制通配[ ] ,如c[aou]t ，匹配出来的的结果只能包括cat ,cot ,cut 。</span></p><p><span style="font-family: 宋体, SimSun">倍数与通配符一起使用可以匹配多个字符。“*”在证据表达式中修饰它前一位字符，从表示该字符的数量可为0至无限大。如果使用正则表达式c.*t 将会匹配 cat ,cot,coat,culvert 等以c开头t结尾的，中间包含任意多个字符的数据。</span></p><p><span style="font-family: 宋体, SimSun">另一种倍数将会指示模式中前面字符的期望个数。c.\{2\}t是使用显式倍数的一个示例。此正则表达式将会匹配以 c 开头，以 t 结尾且中间包含两个任意两个字符的数据。</span></p><p><span style="font-family: 宋体, SimSun">在不同的脚本语言中，正则表达式的语法会存在些许差异。</span></p><p><span style="font-family: 宋体, SimSun">使用grep</span></p><p><span style="font-family: 宋体, SimSun">grep是用作部分分发的一个命令，其使用正则表达式来隔离匹配的数据。</span></p><pre class="brush:bash;toolbar:false">grep&nbsp;&#039;cat$&#039;&nbsp;/usr/share/dict/words</pre><p><span style="font-family: 宋体, SimSun;color: #00B050">注意：由于正则表达式常含有shell 元字符（如$、* 等），建议练习的时候使用单引号（‘’）来括起命令行上的正则表达式。</span></p><pre class="brush:bash;toolbar:false">ps&nbsp;aux&nbsp;|&nbsp;grep&nbsp;&#039;^student&#039;&nbsp;&nbsp;&nbsp;&nbsp;#通过使用&nbsp;|&nbsp;，grep&nbsp;可以与其它命令一起使用。</pre><table><tbody><tr class="firstRow"><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">选项<br /></span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">功能</span></td></tr><tr><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">-i</span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">使用所提供的正则表达式；但是不会强制区分大小写（运行不区分大小写的操作）。</span></td></tr><tr><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">-v</span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">仅显示不包含正则表达式匹配项的行。</span></td></tr><tr><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">-r</span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">将递归匹配正则表达式的数据搜素应用到一组文件或目录中。</span></td></tr><tr><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">-A &lt;NUMBER&gt;</span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">显示正则表达式匹配项之后的行数</span></td></tr><tr><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">-B &lt;NUMBER&gt;</span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">显示正则表达式匹配项之后的行数</span></td></tr><tr><td valign="top" style="border-width: 1px;border-style: solid"><p><span style="font-family: 宋体, SimSun">-e</span></p></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">如果使用多个-e选项，则提供多个正则表达式，并将与逻辑or一起使用</span></td></tr></tbody></table><pre class="brush:bash;toolbar:false">grep&nbsp;-i&nbsp;&#039;cat&#039;&nbsp;file&nbsp;&nbsp;&nbsp;&nbsp;#不区分大小写
grep&nbsp;-i&nbsp;-v&nbsp;&#039;cat&#039;&nbsp;file&nbsp;&nbsp;&nbsp;&nbsp;#不显示带有cat（大小写）的内容
grep&nbsp;-v&nbsp;&#039;^[#;]&#039;&nbsp;file&nbsp;&nbsp;&nbsp;&nbsp;#不显示以#或者；开头的行
grep&nbsp;-e&nbsp;&#039;cat&#039;&nbsp;-e&nbsp;&#039;dog&#039;&nbsp;file&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#显示包含cat&nbsp;或者dog的行
grep&nbsp;&#039;^Aug&nbsp;*8&nbsp;1[345]&#039;&nbsp;door.log&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#查找8月8日，13点-15点分发生的事
grep&nbsp;&#039;^Aug&nbsp;*8&nbsp;14.*OPEN&#039;&nbsp;door.log&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#找8月8日14点的包含OPEN的信息
grep&nbsp;&#039;^Aug&nbsp;*8&nbsp;14:[345]&#039;&nbsp;wall.log&nbsp;27&nbsp;&nbsp;#查找8月8日，14点30-50分发生的事
grep&nbsp;&#039;^Aug&nbsp;*8&nbsp;14.*ALERT&#039;&nbsp;wall.log&nbsp;28&nbsp;&nbsp;#查找8月8日14点的包含ALERT的信息
grep&nbsp;&#039;^Aug&nbsp;*8&nbsp;14:40&#039;&nbsp;proxy.log&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#查找8月8日&nbsp;14:40分发生的事
grep&nbsp;-A&nbsp;24&nbsp;&#039;14:40&#039;&nbsp;proxy.log&nbsp;&nbsp;&nbsp;&nbsp;#查找匹配之后的24行</pre><p><br /></p>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>323</wp:post_id>
		<wp:post_date><![CDATA[2018-05-06 14:15:16]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-05-06 06:15:16]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e7%ac%ac%e4%ba%8c%e7%ab%a0-%e9%80%9a%e8%bf%87grep%e4%bd%bf%e7%94%a8%e6%ad%a3%e5%88%99%e8%a1%a8%e8%be%be%e5%bc%8f]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="rhel134"><![CDATA[RHEL134]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_page_template]]></wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[hestia_layout_select]]></wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>RH134 第三章 使用VIM创建和编辑文本文件</title>
		<link>https://www.rhel.tk/2018/05/08/rh134-%e7%ac%ac%e4%b8%89%e7%ab%a0-%e4%bd%bf%e7%94%a8vim%e5%88%9b%e5%bb%ba%e5%92%8c%e7%bc%96%e8%be%91%e6%96%87%e6%9c%ac%e6%96%87%e4%bb%b6/</link>
		<pubDate>Tue, 08 May 2018 03:07:04 +0000</pubDate>
		<dc:creator><![CDATA[blogs]]></dc:creator>
		<guid isPermaLink="false">https://www.rhel.tk/?p=338</guid>
		<description></description>
		<content:encoded><![CDATA[<p><span style="font-family: 宋体, SimSun">当非特权用户在RHEL7 计算机上使用vi时，执行的命令将是vim。这是在shell 启动时通过/etc/profile.d/vim.sh 中设置的别名完成的。<br /></span></p><p><span style="font-family: 宋体, SimSun">对于 UID 小于或等于200的用户，没有设置这一别名。这些用户将执行vi，也就是vi兼容模式中的vim。这意思意味了典型vi中没有的功能将被禁用。在需要较新的功能时，建议始终执行vim 命令。而不要依赖不一定可用的别名。用户通常需要以root身份操作时尤其需要这么做。</span></p><p><strong><span style="font-family: 宋体, SimSun;font-size: 36px">三种不同版本的vim&nbsp;</span><span style="font-family: 宋体, SimSun"><br /></span></strong></p><p><span style="font-family: 宋体, SimSun">vim-minimal:仅提供vi功能和相关命令，此版本包括在RHEL7最小化安装里。</span></p><p><span style="font-family: 宋体, SimSun">vim-enhanced：此版本提供vim命令，提供表达式，高亮，文件类型插件，和拼写检查</span></p><p><span style="font-family: 宋体, SimSun">vim-X11：此版本提供gvim 图形化的vim.同时支持鼠标</span></p><p><strong><span style="font-family: 宋体, SimSun;font-size: 36px">vim 的三个主要模式：</span></strong></p><table><tbody><tr class="firstRow"><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">功能</span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">模式</span></td></tr><tr><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">命令模式</span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">此模式用于文件导航，剪切和粘贴以及简单命令。 撤销，重做和其他操作也可以从此模式执行</span></td></tr><tr><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">插入模式</span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">此模式用于正常文本编。替换模式是插入模式的一种变体，替换文本而不是插入文本。</span></td></tr><tr><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">执行模式</span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">此模式用于保存，退出和打开文件，以及搜索和替换等更复杂的操作。从这种模式中，可以将程序的输出插入到当前文件中.配置 vim等等。 任何操作都有可能可能使用ex这个模式完成。</span></td></tr></tbody></table><p><span style="font-family: 宋体, SimSun">打开文件后，vim将在命令模式中启动。将在屏幕左下角看到有关已打开文件信息（文件名、行数、字符数），并将在右下角看到当前的光标位置（行、字符）以及正在显示文件的哪个部分（ALL表示全部，Top表示文件前几行，Bot 表示文件底部），或者显示百分比来表示当前所处文件位置。最下方线条在vim术语中称为标尺。</span><br /></p><p><span style="font-family: 宋体, SimSun">要切换到插入模式，系统提供了可用的命令，且每个命令在键盘上均分配有一个不同的键</span></p><p><span style="font-family: 宋体, SimSun"></span></p><table><tbody><tr class="firstRow"><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">键</span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">结果</span></td></tr><tr><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">i</span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">切换到插入模式，并在当前光标位置之前插入</span></td></tr><tr><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">a</span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">切换到插入模式，并在当前光标位置之后插入</span></td></tr><tr><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">I</span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">将光标移至当前行的开头位置，并切换到插入模式</span></td></tr><tr><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">A</span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">将光标移到当前行的结尾位置，并切换到插入模式</span></td></tr><tr><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">R</span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">从光标下的字符开始，切换到替换模式。处理替换模式时，不会插入文件，输入的每个字符均将替换当前文档中的字符。</span></td></tr><tr><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">o</span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">在当前行的下方新打开一个行，并切换到插入模式。</span></td></tr><tr><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">O</span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">在当前行的上方新打开一个行，并切换到插入模式。</span></td></tr></tbody></table><p><span style="font-family: 宋体, SimSun">每次处于插入或替换模式时，标尺将会显示--INSERT-- 或 --REPLACE--。按Esc 即可返回命令模式。</span></p><p><span style="font-family: 宋体, SimSun">RHEL 随附的vi和vim 版本已经配置为在命令和插入模式中识别和使用常规光标键以及如PgUp和End等键，这并不是vi所有安装版本上的默认行为。事实上，之前版本的vi根本不识别光标键，而是只允许在命令模式中使用诸如hjkl的键来操作。</span><br /></p><p><strong><span style="font-family: 宋体, SimSun;font-size: 36px">vim光标操作</span></strong></p><p><strong><span style="font-family: 宋体, SimSun"></span></strong></p><table><tbody><tr class="firstRow"><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">键<br /></span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">结果</span></td></tr><tr><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">h</span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">向左移动一个位置</span></td></tr><tr><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">l</span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">向右移动一个位置</span></td></tr><tr><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">j</span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">向下移动一下位置</span></td></tr><tr><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">k</span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">向上移动一个位置</span></td></tr><tr><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">^</span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">移至当前行首</span></td></tr><tr><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">$</span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">移至当前行尾</span></td></tr><tr><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">gg</span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">移至文件第一行</span></td></tr><tr><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">G</span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">移至文件最后一行</span></td></tr></tbody></table><p><span style="font-family: 宋体, SimSun">保存文件通过ex模式实现，在命令模式下按&nbsp; :（冒号）进入 ex模式</span></p><table><tbody><tr class="firstRow"><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">键</span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">结果</span></td></tr><tr><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">:wq</span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">保存并退出当前文件</span></td></tr><tr><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">: x<br /></span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">保存当前文件（如果存在未保存的更改），然后退出</span></td></tr><tr><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">:w</span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">保存当前文件并保留在编辑器中</span></td></tr><tr><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">:w &lt;filename&gt;</span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">以其他文件名保存当前文件</span></td></tr><tr><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">:q</span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">退出当前文件（仅在没有未保存更改的的情况下）</span></td></tr><tr><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">:q!</span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">退出当前文件，忽略任何未保存更改，！表示强制</span></td></tr><tr><td valign="top" colspan="1" rowspan="1" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">:3</span></td><td valign="top" colspan="1" rowspan="1" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">跳到第3行</span></td></tr></tbody></table><p><span style="font-family: 宋体, SimSun">高级移动命令，仅在命令模式中可用，所有移到命令可以通过键入数字来加上前缀，如5w,将光标移动5个单词，或者12j将光标向下移到12行。实际上，每个命令（包括切换到插入模式）都可通过实际命令前键入重复次数来重复执行一定的次数，在vim术语中，这称为计数。</span><br /></p><table><tbody><tr class="firstRow"><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">键</span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">结果</span></td></tr><tr><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">w</span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">将光标移到下一单词的开头（w包含标点符号）</span></td></tr><tr><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">b</span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">将光标移到上一单词的开头（b包含标点符号）</span></td></tr><tr><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">(</span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">将光标移到当前或上一句子的开头</span></td></tr><tr><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">)</span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">将光标移到下一句子的开头</span></td></tr><tr><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">{</span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">将光标移到当前/上一段落的开头</span></td></tr><tr><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">}</span></td><td valign="top" style="border-width: 1px;border-style: solid"><span style="font-family: 宋体, SimSun">将光标移到下一段落的开头</span></td></tr></tbody></table><p><span style="font-family: 宋体, SimSun">替换文本，vim允许用户通过&quot;change&quot;命令替换大量（或少量）文件。&quot;change&quot;命令的使用方式为：按 c 键，后面加上光标移动；例如cw可以将当前光标位置更改到当前单词的末尾。要替换的文本被删除（放置在未命名寄存器中），vim 也会切换到插入模式。<br /></span></p><p><span style="font-family: 宋体, SimSun">按c 两下（cc）将开始以行范围的方式替换，即替换一整行（或者带上数字时替换多行）同样的操作也适用于删除（d）</span></p><p><span style="font-family: 宋体, SimSun">大多数移动命令可以带上i和a前缀，以选择inner 或a 版本的移动。例如ciw将替换整个当前单词，而不仅仅是从当前光标位置起，而caw则执行相同的功能，但包括周围任何空白区。</span></p><p><span style="font-family: 宋体, SimSun">要替换到行末为止，可以使用cS，但C可执行相同的功能。（同样适用于删除命令（D））</span></p><p><span style="font-family: 宋体, SimSun">要权替换光标处的字符，可按r再键入新的字符</span></p><p><span style="font-family: 宋体, SimSun">要改变光标处字符的大小写，或按 ~</span></p><p><span style="font-family: 宋体, SimSun"><br /></span></p><p><span style="font-family: 宋体, SimSun">删除文本的操作方式与替换文本相同。用于删除文本的命令是d,而且对更改文本有效的所有相同移到也适用于删除，包括D可以删除光标位置到行末的内容。</span></p><p><strong><span style="font-family: 宋体, SimSun;font-size: 36px">复制和粘贴</span></strong><span style="font-family: 宋体, SimSun"><br /></span></p><p><span style="font-family: 宋体, SimSun">vim 用于描述复制和粘贴操作的术语与大多数人目前熟悉的稍有不同，复制操作也称为拖拉，而粘贴操作则叫做放置，这体现在分配给这些操作的键盘命令上：拖拉是y加上移到，而放置操作则通过p和P执行。</span></p><p><span style="font-family: 宋体, SimSun">拖拉操作遵循与替换和删除操作相同的通用方案：如用户可以选择键入要重复某一操作的次数，后面加上y，再加上一种移到。例如5yaw，将复制当前的单词，以及后面4个单词（共5个）.按yy将拖拉一整行，等等</span></p><p><span style="font-family: 宋体, SimSun">放置（粘贴）通过p和P命令执行；小写p将内容放置到当前光标位置的后面（如果粘贴是的是行范围数据，则放在当前行下面），而大写P则放置到当前光标位置的前面或者当前行上方。与所有其它命令一样，放置命令可以加上寄存器粘贴次数作为前缀。</span></p><p><strong><span style="font-family: 宋体, SimSun;font-size: 36px">多个寄存器</span></strong></p><p><span style="font-family: 宋体, SimSun">vim 不是仅提供一个供复制和粘贴 使用的剪贴板，而是提供26个命名寄存器，以及欠点特殊用途的寄存器。拥有多个寄存器可以让用户更加高效地很乖剪切和粘贴命令，而不必担心丢失数据，或者过多的移动光标。如果未指定要使用的寄存器，则将使用“未命名”寄存器。常规寄存器称为a到z,通过在命令的计数和实际命令之间放入&quot;registername来选择，例如：要复制当前行和后面2行到t寄存器中，用户可以使用3&quot;tyy</span></p><p><span style="font-family: 宋体, SimSun">要放置命名寄存器中的内容，只需要在放置命令之前加上&quot;registername，例如：&quot;sp将在光标位置后面放置s寄存器中的内容。</span></p><p><span style="font-family: 宋体, SimSun">每次使用命名寄存器时，未命名寄存器也会更新。</span></p><p><span style="font-family: 宋体, SimSun">删除和更改操作也可加上寄存器选择作为前缀。未指定寄存器时，将仅使用未命名寄存器。当使用寄存器的大写版本时，被剪切或拖拉的文本将附加到该寄存器，而不是覆盖它。</span></p><p><strong><span style="font-family: 宋体, SimSun;font-size: 36px">特殊寄存器</span></strong></p><p><span style="font-family: 宋体, SimSun">有10个数字编号的寄存器，分别为&quot;0 - &quot;9寄存器，&quot;0使用拥有最近拖拉文本的副本，而寄存器&quot;1则具有最近删除的文本的副本。当新的文本补更改或删除时，&quot;1的内容将移到&quot;2中，&quot;2的内容移动&quot;3中，以此类推。与命名寄存器不同，数字编号寄存器的内容不会在会话之间保存。</span></p><p><strong><span style="font-family: 宋体, SimSun;font-size: 36px">可视模式</span></strong></p><p><span style="font-family: 宋体, SimSun">在进入可视模式后（通过标尺--VISUAL--表示），任何光标移动将开始选择文本。可视模式中发出的任何更改、删除或拖拉命令不需要光标移动部分，而是对选定的文件起作用。</span></p><p><span style="font-family: 宋体, SimSun">可视模式有三个类别：基于字符（通过 v 启动）、基于行（通过 V 启动） 、基于块（通过 Ctrl+v 启动）。使用gvim时，也可通过鼠标选择文本。</span></p><p><span style="font-family: 宋体, SimSun">可视模式中发出的任何ex 命令也默认对选定的文本起作用。</span></p><p><strong><span style="font-family: 宋体, SimSun;font-size: 36px">搜索</span></strong></p><p><span style="font-family: 宋体, SimSun">在当前文档中搜索可能通过两种方式：按 / 键从光标处向前搜索，或者按 ？从当前光标位置向后搜索。进入搜索模式后，可以键入要搜索的正则表达式，然后按Enter 键跳到第一个匹配项。</span></p><p><span style="font-family: 宋体, SimSun">要搜索下一个或者上一个匹配项可分别按 n 和 N 键。</span></p><p><span style="font-family: 宋体, SimSun">奖励快捷方式：* 将立即向前搜索光标处的单词。</span></p><p><strong><span style="font-family: 宋体, SimSun;font-size: 36px">搜索和替换</span></strong></p><p><span style="font-family: 宋体, SimSun">vim 中的搜索和替换通过 ex 命令实施，其使用的语法与用户通过sed 搜索和替换时所用的相同，包括使用正则表达式进入搜索的功能：</span></p><p><span style="font-family: 宋体, SimSun">ranges/pattern/string/flags</span></p><p><span style="font-family: 宋体, SimSun">range 可以是行号（43）、行范围（1，7 表示1 - 7行）、搜索条件（/README\.txt）、%(当前文档中的所有行；搜索和替换通常仅会对当前行操作)，或者&#039;&lt;,&#039;&gt;(当前的可视选择)。</span></p><p><span style="font-family: 宋体, SimSun">两个最常见的flaga 是 g （替换一行中多个位置上的pattern） 和 i&nbsp; （使当前的搜索区分大小写）</span></p><pre class="brush:bash;toolbar:false">:%s/\&lt;cat\&gt;/god/gi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#搜索文档中每个位置的cat&nbsp;，并替换成dog&nbsp;，不区分大小写，但仅对完整的词语，而不是诸如：&quot;catalog&quot;&nbsp;中的一部分。</pre><p><span style="font-family: 宋体, SimSun"></span><br /></p><p><strong><span style="font-family: 宋体, SimSun;font-size: 36px">撤消和恢复</span></strong></p><p><span style="font-family: 宋体, SimSun">为了允许人为的失误存在，vim配备了撤消/恢复机制。只要在命令模式中按 u 即可撤消最近一个操作。如果撤消了过多操作，按 Ctrl + r 即可恢复最近一次撤消。</span></p><p><span style="font-family: 宋体, SimSun">奖励诀窍：从命令模式中按 . (句号 英文)将对当前恢复最近一个编辑操作。这可以用于对多个行轻松执行同一编辑操作。</span></p>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>338</wp:post_id>
		<wp:post_date><![CDATA[2018-05-08 11:07:04]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-05-08 03:07:04]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[rh134-%e7%ac%ac%e4%b8%89%e7%ab%a0-%e4%bd%bf%e7%94%a8vim%e5%88%9b%e5%bb%ba%e5%92%8c%e7%bc%96%e8%be%91%e6%96%87%e6%9c%ac%e6%96%87%e4%bb%b6]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="rhel134"><![CDATA[RHEL134]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_page_template]]></wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[hestia_layout_select]]></wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>RH134 第四章 计划将来的linux 任务</title>
		<link>https://www.rhel.tk/2018/05/14/rh134-%e7%ac%ac%e5%9b%9b%e7%ab%a0-%e8%ae%a1%e5%88%92%e5%b0%86%e6%9d%a5%e7%9a%84linux-%e4%bb%bb%e5%8a%a1/</link>
		<pubDate>Mon, 14 May 2018 01:25:12 +0000</pubDate>
		<dc:creator><![CDATA[blogs]]></dc:creator>
		<guid isPermaLink="false">https://www.rhel.tk/?p=354</guid>
		<description></description>
		<content:encoded><![CDATA[<p><strong><span style="font-family: 宋体, SimSun;font-size: 36px">使用at 计划一次性任务</span></strong></p><p><span style="font-family: 宋体, SimSun">at 不是单机工具，而是一个系统守护进程（atd），它有一组命令行工具可与守护进程（at,atd 等）进行交互。在默认的RHEL安装过程中，atd 守护进程将自动安装和启用。atd 守护进程可以在at软件包中找到。</span></p><p><span style="font-family: 宋体, SimSun">用户（包括root）可使用命令行工具 at 为 atd 守护进程的作业排除。atd 守护进程提供了 a 到 z 共26个队列。作业按字母顺序排列，队列越后，系统优先级越低</span></p><p><strong><span style="font-family: 宋体, SimSun;font-size: 24px">计划作业</span></strong></p><p><span style="font-family: 宋体, SimSun">使用命令 at &lt;TIMESPEC&gt; 可以计划新作业。at 随后会读取从stdin 执行的命令。对于较大的命令以及错别字敏感的命令，使用来自脚本文件(例如at now +5min &lt;myscript) 的输入重定向比在终端窗口中手动输入所有命令要简单。手动输入命令时，可以通过 Ctrl +D 来完成输入。</span></p><p><span style="font-family: 宋体, SimSun">&lt;TIMESPEC&gt; 允许许多强大的组合，使用户（几乎）可以自由地来说明应运行作业的确切时间。通常这些组合以时间（例如02:00pm,13:59 甚至teatime）开头，后面接一个可选日期或将来的天数。</span></p><ul class=" list-paddingleft-2" style="list-style-type: disc"><li><p><span style="font-family: 宋体, SimSun">now +5min</span></p></li><li><p><span style="font-family: 宋体, SimSun">teatime tomorrow (下等茶时间16:00)</span></p></li><li><p><span style="font-family: 宋体, SimSun">noon +4&nbsp; &nbsp; days&nbsp; (noon 12:00)</span></p></li><li><p><span style="font-family: 宋体, SimSun">5pm august 3 2016&nbsp;</span></p></li></ul><p><strong><span style="font-family: 宋体, SimSun;font-size: 24px">检查管理作业</span></strong></p><p><span style="font-family: 宋体, SimSun">stq 或者 at -l&nbsp;</span></p><p><span style="font-family: 宋体, SimSun"></span></p><pre class="brush:bash;toolbar:false">[root@desktop0&nbsp;~]#&nbsp;at&nbsp;-l&nbsp;&nbsp;&nbsp;&nbsp;#查看任务计划
1Wed&nbsp;May&nbsp;&nbsp;9&nbsp;12:00:00&nbsp;2018&nbsp;a&nbsp;root
#共4列</pre><p><span style="font-family: 宋体, SimSun"></span><br /></p><ul class=" list-paddingleft-2" style="list-style-type: disc"><li><p><span style="font-family: 宋体, SimSun">作业编号，当前为1</span></p></li><li><p><span style="font-family: 宋体, SimSun">该作业计划的日期和时间，Wed May 9 12:00:00 2018</span></p></li><li><p><span style="font-family: 宋体, SimSun">作业所在队列是a</span></p></li><li><p><span style="font-family: 宋体, SimSun">作业所有者（以及将运行作业的用户身份），当前为root</span></p></li></ul><p><span style="font-family: 宋体, SimSun"><br /></span></p><p><span style="font-family: 宋体, SimSun">普通的非特权用户只能查看和控制自己的作业。root 可以查看和管理所有作业<br /></span></p><p><span style="font-family: 宋体, SimSun">要检查执行作业时运行的实际命令，请使用命令at -c &lt;JobNumber&gt; ,该输入首先会显示所设置作业环境，以便在用户创建作业时反映用户的环境，后跟运行的实际命令。</span></p><p><strong><span style="font-family: 宋体, SimSun;font-size: 24px">删除作业</span></strong></p><p><span style="font-family: 宋体, SimSun">atrm &lt;<span style="font-family: 宋体, SimSun;font-size: 14px">JobNumber</span>&gt; 将会删除计划的作业。当不再需要作业时（例如，远程防火墙配置成功且不需要重置时）</span></p><pre class="brush:bash;toolbar:false">atrm&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;#删除任务计划&nbsp;1</pre><p><span style="font-family: 宋体, SimSun"></span><br /></p><p><span style="font-family: 宋体, SimSun"></span></p><pre class="brush:bash;toolbar:false">[root@desktop0&nbsp;~]#&nbsp;echo&nbsp;&quot;date&nbsp;&gt;&nbsp;~/myjob&quot;&nbsp;|&nbsp;at&nbsp;now&nbsp;+3min&nbsp;&nbsp;&nbsp;&nbsp;#设置任务计划
job&nbsp;4&nbsp;at&nbsp;Tue&nbsp;May&nbsp;&nbsp;8&nbsp;15:16:00&nbsp;2018
[root@desktop0&nbsp;~]#&nbsp;atq&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#查看任务计划
4Tue&nbsp;May&nbsp;&nbsp;8&nbsp;15:16:00&nbsp;2018&nbsp;a&nbsp;root</pre><p><span style="font-family: 宋体, SimSun"></span></p><pre class="brush:bash;toolbar:false">[root@desktop0&nbsp;~]#&nbsp;at&nbsp;-q&nbsp;g&nbsp;teatime&nbsp;tomorrow&nbsp;&nbsp;&nbsp;&nbsp;#在任务队列&nbsp;g&nbsp;创建作业任务
at&gt;&nbsp;touch&nbsp;/home/student/tea&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#任务内容
at&gt;&nbsp;&lt;EOT&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#Ctrl&nbsp;+&nbsp;D&nbsp;退出任务编辑
job&nbsp;6&nbsp;at&nbsp;Wed&nbsp;May&nbsp;&nbsp;9&nbsp;16:00:00&nbsp;2018
[root@desktop0&nbsp;~]#&nbsp;atq&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;&nbsp;&nbsp;查看任务
6Wed&nbsp;May&nbsp;&nbsp;9&nbsp;16:00:00&nbsp;2018&nbsp;g&nbsp;root
[root@desktop0&nbsp;~]#&nbsp;at&nbsp;-q&nbsp;b&nbsp;16:05&nbsp;tomorrow&nbsp;&nbsp;&nbsp;&nbsp;#在任务队列&nbsp;b&nbsp;创建作业任务
at&gt;&nbsp;touch&nbsp;/home/student/cookies
at&gt;&nbsp;&lt;EOT&gt;
job&nbsp;7&nbsp;at&nbsp;Wed&nbsp;May&nbsp;&nbsp;9&nbsp;16:05:00&nbsp;2018
[root@desktop0&nbsp;~]#&nbsp;atq&nbsp;&nbsp;&nbsp;&nbsp;#查看
6	Wed&nbsp;May&nbsp;&nbsp;9&nbsp;16:00:00&nbsp;2018&nbsp;g&nbsp;root
7	Wed&nbsp;May&nbsp;&nbsp;9&nbsp;16:05:00&nbsp;2018&nbsp;b&nbsp;root
[root@desktop0&nbsp;~]#&nbsp;at&nbsp;-c&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#查看作业任务6的详细信息
[root@desktop0&nbsp;~]#&nbsp;atrm&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;#删除
[root@desktop0&nbsp;~]#&nbsp;atq
7	Wed&nbsp;May&nbsp;&nbsp;9&nbsp;16:05:00&nbsp;2018&nbsp;b&nbsp;root</pre><p><span style="font-family: 宋体, SimSun"><strong><span style="font-size: 36px">使用cron计划周期性作业</span></strong></span></p><p><span style="font-family: 宋体, SimSun">at 是一次性作业任务，在RHEL 中附带了特别针对周期性作业的crond 守护进程，且默认开机启用并启动。crond 是由多个配置文件和系统范围内的文件控制的，每个用户对应一个配置文件（使用crontab(1) 命令进行编辑）。这些配置文件使用户和管理员拥有细微的控制权，可以控制应执行周期性作业的确切时间。crond 守护进程作为 cronie软件包的一部分安装。<br /></span></p><p><span style="font-family: 宋体, SimSun">如果从cron 作业运行的命令向末重定向的 stdout 或 stderr 生成任何输出，则crond 守护进程将尝试使用系统中配置的邮件服务器将该输出通过电子邮件发送给拥有该作业的用户（除非被覆盖）。根据环境，这可能需要其它配置。</span></p><p><strong><span style="font-family: 宋体, SimSun;font-size: 24px">计划作业</span></strong></p><p><span style="font-family: 宋体, SimSun">普通用户使用crontab 命令来管理作业，可以通过四种方式调用该命令：</span></p><table><tbody><tr class="firstRow"><td valign="top"><span style="font-family: 宋体, SimSun">命令</span></td><td valign="top"><span style="font-family: 宋体, SimSun">预期用途</span></td></tr><tr><td valign="top"><span style="font-family: 宋体, SimSun">crontab -l</span></td><td valign="top"><span style="font-family: 宋体, SimSun">列出当前用户的计划任务</span></td></tr><tr><td valign="top"><span style="font-family: 宋体, SimSun">crontab -r</span></td><td valign="top"><span style="font-family: 宋体, SimSun">删除当前用户的所有计划任务</span></td></tr><tr><td valign="top"><span style="font-family: 宋体, SimSun">crontab -c</span></td><td valign="top"><span style="font-family: 宋体, SimSun">编辑当前用户的计划任务</span></td></tr><tr><td valign="top"><span style="font-family: 宋体, SimSun">crontab &lt;filename&gt;</span></td><td valign="top"><span style="font-family: 宋体, SimSun">删除所有作业，并替换为从&lt;filename&gt;读取作业。如果未指定任何文件，则将使用stdin&nbsp;</span></td></tr></tbody></table><p><span style="font-family: 宋体, SimSun">root 可以使用 -u&nbsp; username 选项管理其他用户的作业。不建议使用crontab 命令来管理系统作业。</span></p><p><span style="font-family: 宋体, SimSun">在使用crontab -e 编辑作业时，编辑器会启动（如果editor 环境变量尚未设置其它值，则默认为vi），正在编辑的文件，每行均有一个作业。允许有空行，并且注释的行以 （#）开头。环境变量也可以使用格式：NAME=value 来声明，并且会影响声明所在行下面的所有行。crontab 中的常见变量包括 SHELL 和 MAILTO 。设置SHELL 变量将会更改用于其下面的行中执行命令的shell ，而设置 MAILTO 变量将会更改发送到电子邮件地址输出（所有）</span></p><p><span style="font-family: 宋体, SimSun">重要提示：发送电子邮件可能需要另外配置本地邮件服务器或系统中的SMTP转发</span></p><p><span style="font-family: 宋体, SimSun">各个作业都包含 6 个字段，详述了执行的时间和内容，如果前 5 个字段都与当前日期和时间相匹配，则会执行最后一个字段中的命令，这些字段包括：</span></p><ul class=" list-paddingleft-2" style="list-style-type: disc"><li><p><span style="font-family: 宋体, SimSun">分钟&nbsp;</span></p></li><li><p><span style="font-family: 宋体, SimSun">小时&nbsp;</span></p></li><li><p><span style="font-family: 宋体, SimSun">几号&nbsp;</span></p></li><li><p><span style="font-family: 宋体, SimSun">月份&nbsp;</span></p></li><li><p><span style="font-family: 宋体, SimSun">星期几&nbsp;</span></p></li><li><p><span style="font-family: 宋体, SimSun">命令</span></p></li></ul><p><span style="font-family: 宋体, SimSun"></span></p><p><span style="font-family: 宋体, SimSun">如果几号和星期几字段都不是 * ，则该命令将在其中任一字段匹配时执行，例如 * * 15 * 5 ls ,将在每月 15 号或每周 5 执行ls命令</span></p><p><span style="font-family: 宋体, SimSun">前 5 个字段全部使用相同的语法规则：</span></p><ul class=" list-paddingleft-2" style="list-style-type: disc"><li><p><span style="font-family: 宋体, SimSun">* 表示“无关紧要”/始终</span></p></li><li><p><span style="font-family: 宋体, SimSun">数字可用于指定分钟，小时，日期或工作日。（对于工作日0 - 7，0表示星期日，1表示星期一，依次类推。7也表示星期日）</span></p></li><li><p><span style="font-family: 宋体, SimSun">x-y 表示范围，x到y(含)</span></p></li><li><p><span style="font-family: 宋体, SimSun">x,y 表示列表。列表也可以包含范围，例如“分钟”列中的5,10-13,17,表示作业应当在每小时的第5，10-13，17分钟分别运行一次</span></p></li><li><p><span style="font-family: 宋体, SimSun">*/x 表示x的时间间隔，例如分钟列 */7 表示每 7 分钟运行一次。</span></p></li></ul><p><span style="font-family: 宋体, SimSun">此外，可以使用三个字母的英文缩写来表示月份和工作日，例如Jan ,Feb 以及 Tue , Wed .</span></p><p><span style="font-family: 宋体, SimSun">最后一个字段包含要执行的命令，如果尚未声明shell的环境变量，则该命令将由 /bin/sh 执行。<span style="font-family: 宋体, SimSun;color: #FF0000">如果命令中包含未转义的百分比符号(%),则该百分比符号将被当作新行，且百分比符号之后的所有内容将反馈到stdin 中的命令。</span></span></p><p><span style="font-family: 宋体, SimSun"></span></p><pre class="brush:bash;toolbar:false">0&nbsp;9&nbsp;2&nbsp;2&nbsp;*&nbsp;/usr/local/bin/yearly_bakcup&nbsp;&nbsp;&nbsp;&nbsp;#在每年的2月2上午9点整执行命令&nbsp;/usr/local/yearly_backup
*/7&nbsp;9-16&nbsp;*&nbsp;Jul&nbsp;5&nbsp;echo&nbsp;&quot;China&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#在七月每周五的上午9点&nbsp;和下午5点之间，每七分钟向该作业的所有者发送包含单词的&nbsp;China&nbsp;的电子&nbsp;邮件
58&nbsp;23&nbsp;*&nbsp;*&nbsp;1-5&nbsp;/usr/local/bin/daily_report&nbsp;&nbsp;&nbsp;&nbsp;#在每个工作日午夜前2分钟运行命令/usr/local/daily_report
0&nbsp;9&nbsp;*&nbsp;*&nbsp;1-5&nbsp;mutt&nbsp;-s&nbsp;&quot;Checking&nbsp;in&quot;&nbsp;boss@example.com&nbsp;%&nbsp;Hi&nbsp;there&nbsp;boss&nbsp;,just&nbsp;checking&nbsp;in&nbsp;.&nbsp;
#在每个工作日（周一到周五）的上午9点整，使用mutt&nbsp;向&nbsp;boss@example.com&nbsp;发送邮件。</pre><p><span style="font-family:宋体, SimSun"></span><br /></p><pre class="brush:bash;toolbar:false">[student@desktop0&nbsp;~]$&nbsp;crontab&nbsp;-e
no&nbsp;crontab&nbsp;for&nbsp;student&nbsp;-&nbsp;using&nbsp;an&nbsp;empty&nbsp;one
crontab:&nbsp;installing&nbsp;new&nbsp;crontab
[student@desktop0&nbsp;~]$&nbsp;crontab&nbsp;-l
*/2&nbsp;9-16&nbsp;*&nbsp;*&nbsp;1-5&nbsp;date&nbsp;&gt;&gt;&nbsp;/home/student/my_first_cron_job
[student@desktop0&nbsp;~]$&nbsp;cat&nbsp;my_first_cron_job&nbsp;
Tue&nbsp;May&nbsp;&nbsp;8&nbsp;17:10:02&nbsp;CST&nbsp;2018
[student@desktop0&nbsp;~]$&nbsp;crontab&nbsp;-r
[student@desktop0&nbsp;~]$&nbsp;crontab&nbsp;-l
no&nbsp;crontab&nbsp;for&nbsp;student
[student@desktop0&nbsp;~]$</pre><p><span style="font-size: 36px"><strong><span style="font-family: 宋体, SimSun">计划系统cron作业</span></strong></span></p><p><span style="font-family: 宋体, SimSun">除了用户cron作业外，还有系统cron作业，系统cron作业不是使用crontab 命令定义的，而是在一组配置文件中配置的。这些配置文件之间主要区别在于一个<span style="font-family: 宋体, SimSun;color: #FF0000">额外的的字段，该字段位置位置星期几和命令字段之间</span>，指定了作业应在哪个用户下运行。</span></p><p><span style="font-family: 宋体, SimSun">/etc/crontab 的随附注释中包含了实用的语法图</span></p><p><img src="/wp-content/uploads/image/20180508/1525771056304457.png" title="1525771056304457.png" alt="image.png" /></p><p><span style="font-family: 宋体, SimSun">系统作业配置文件在 /etc/crontab 和 /etc/cron.d/* .安装cron 作业的软件包应当通过在/etc/cron.d/ 中放置文件才能执行安装操作，但是，管理员还可以使用此位置来更轻松的将相关作业分到单个文件中，或者使用配置管理系统推送作业。</span></p><p><span style="font-family: 宋体, SimSun">还有预定义作业每小时，每天、每周和每月运行一次，这个作业将分别执行位于/etc/cron.hourly/ 、/etc/cron.daily/、/etc/cron.weekly 和 /etc/cron.monthly/ 中的所有脚本，<span style="font-family: 宋体, SimSun;color: #FF0000">请注意，这些目录包含可执行脚本，而不包含cron配置文件 。</span></span></p><p><span style="font-family: 宋体, SimSun;color: #000000">/etc/cron.hourly/* 脚本是使用run-parts 命令从/ec/cron.d/0hourly 中定义的作业执行的，每日、每周和每月的作业也使用run-parts命令执行，但是人其它配置文件 /etc/anacrontab 执行。<br /></span></p><p><span style="color: #000000;font-family: 宋体, SimSun">过程anacrontab 是由单独的守护进程(anacron)处理的，但是在RHEL 7 中，该文件由常规crond 守护进程解析。该文件旨在确保重要的作业始终运行，且不会因为系统在应执行作业时关闭或休眠而意外跳过。</span></p><p><span style="color: #000000;font-family: 宋体, SimSun">/etc/anacrontab 的语法与其它cron 配置文件有所不同。它每行正好包含四个字段：</span></p><p><span style="color: #000000;font-family: 宋体, SimSun"></span></p><pre class="brush:bash;toolbar:false">Period&nbsp;in&nbsp;days&nbsp;&nbsp;&nbsp;&nbsp;#每多少天运行一次
Delay&nbsp;in&nbsp;minutes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#在启动该作业前，cron守护进程应等待的时间
Job&nbsp;identifier&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#此为&nbsp;/var/spool/anacron/&nbsp;中文件的名称，该文件将用于检查该作业是否已运行。在cron&nbsp;从/etc/anacrontab&nbsp;启动作业时，它会更新此文件的时间戳。同一时间戳可用于检查&nbsp;作业上次运行的时间。
Command&nbsp;&nbsp;&nbsp;&nbsp;#要执行的命令</pre><p><span style="font-family: 宋体, SimSun"></span><br /></p><p><span style="font-family: 宋体, SimSun">/etc/anacrontab 还包含使用语法 NAME=value 的环境变量声明，特别相关的是 START_HOURS_RANGE: 作业不会在些范围外启动。</span></p><p><strong><span style="font-family: 宋体, SimSun;font-size: 36px">管理临时文件</span></strong></p><p><span style="font-family: 宋体, SimSun">使用systemd-tmpfiles 管理临时文件</span></p><p><span style="font-family: 宋体, SimSun">用户高度可见的临时文件和目录（常规用户所使用和滥用的/tmp）<br /></span></p><p><span style="font-family: 宋体, SimSun">特定于任务的历史文件和目录（例如守护进程以及/run下特定用户的易失性目录，易失性的文件值存在内存中，在系统重启或断电时，所有内容都会丢失。）</span></p><p><span style="font-family: 宋体, SimSun">为保持系统充分运行，有必要创建那些不存在的目录和文件，因为守护进程可能会依靠它们存在，而清除旧文件后就不会填满磁盘空间或提供错误信息。</span></p><p><span style="font-family: 宋体, SimSun">旧版本中，系统管理员依靠RPM软件包和systemV初始脚本来创建这些目录，依靠名为tmpwatch的工具来配置目录中删除未使用的旧文件。在RHEL7 中，systemd 提供了一个更加结构化的可配置方法来管理临时目录和文件，systemd-tmpfiles.</span></p><p><span style="font-family: 宋体, SimSun">在systemd启动系统后，其中一个启动的服务单元是systemd-tmpfiles-setup。该服务运行命令：</span></p><p><span style="font-family: 宋体, SimSun"></span></p><pre class="brush:bash;toolbar:false">systemd-tmpfiles&nbsp;--create
systemd-tmpfiles&nbsp;--remove
systemd-tmpfiles&nbsp;--clean</pre><p><span style="font-family: 宋体, SimSun"></span><br /></p><p><span style="font-family: 宋体, SimSun">该命令会从 /usr/lib/tmpfiles.d/*.conf、/run/tmpfiles.d/*.conf 和 /etc/tmpfiles.d/*.conf 读取配置文件。系统将会删除这些配置文件中标记要删除的任何文件和目录，并且会创建标记要创建（或修复权限）的任何文件和目录，并使其拥有正确的权限（如有必要）</span></p><p><strong><span style="font-family: 宋体, SimSun;font-size: 24px">定期清理</span></strong></p><p><span style="font-family: 宋体, SimSun">为确保长期运行的系统不会用陈旧数据填满磁盘，也有一个systemd 定时器单元会按固定间隔调用systemd-tmpfiles --clean&nbsp;</span></p><p><span style="font-family: 宋体, SimSun">systemd 定时器单元是一类特殊的systemd服务，它有一个[Timer]块会指示同名服务的启动频率。</span></p><p><span style="font-family: 宋体, SimSun">在RHEL 7 系统中，systemd-tmpfiles-clean.timer 单元的配置如下所示：</span></p><p><img src="/wp-content/uploads/image/20180513/1526219726507971.png" title="1526219726507971.png" alt="blob.png" /></p><p><span style="font-family: 宋体, SimSun">这表示同名服务（systemd-tmpfiles-clean.service）将在systemd启动15分钟后启动，然后每隔24小时启动一次。</span></p><p><span style="font-family: 宋体, SimSun">命令systemd-tmpfiles --clean 解析的配置文件与systemd-tmpfiles --create 相同，但前者不会创建文件和目录，而是会清楚在比配置文件中定义的最长期限更近的时间尚未访问、更改或修改的所有文件。</span></p><p><strong><span style="font-family: 宋体, SimSun;font-size: 24px">tip:</span></strong></p><p><span style="font-family: 宋体, SimSun">man page tmpfiles.d(5)声称，系统会删除时间“长于”配置文件中日期字段的期限文件。这并不完全正确。</span></p><p><span style="font-family: 宋体, SimSun">Linux 文件系统中遵循PSOSIX标准的文件有三个时间戳：atime(上次访问文件的时间)、mtime（上次修改文件内容的时间）、以及 ctime （上次由 chown 、chmod等更改文件状态的时间）。大多数 Linux 文件系统都没有创建时间戳。这在类似Unlix 的文件系统中很常见。</span></p><p><span style="font-family: 宋体, SimSun">如果这三个时间戳比systemd-tmpfiles期限配置都旧，则文件将会被视为未使用。如果其中任一时间戳比期限配置新，则根据systemd-tmpfiles的期限将不会删除文件。</span></p><p><span style="font-family: 宋体, SimSun">可以在文件上运行stat 命令(stat filename)，以查看所有这三个时间戳的值，ls -l 命令通常会显示mtime。</span></p><p><br /></p><p><strong><span style="font-family: 宋体, SimSun;font-size: 24px">systemd-tmpfiles 配置文件</span></strong></p><p><span style="font-family: 宋体, SimSun">tmpfiles.d(5) 手册中详述了system-tmpfiles的配置文件格式</span></p><p><span style="font-family: 宋体, SimSun">基本语法由七列构成：“类型”、“路径”、“模式”、UID、GID、“期限”和“参数”。“类型”指的是systemd-tmpfiles应执行的操作；例如 d 表示创建还不存在的目录，或者 Z 表示以递归方式恢复SElinux 上下文以及文件权限和所有权。<br /></span></p><p><span style="font-family: 宋体, SimSun"></span></p><pre class="brush:bash;toolbar:false">d&nbsp;/run/systemd/seats&nbsp;0755&nbsp;root&nbsp;root&nbsp;-
#在创建文件和目录是，如果目录/run/systemd/seats还不存在，则创建该目录，所有者为用户root和组root,权限设置为&nbsp;rwxr-xr-x.系统不会清除该目录。
D&nbsp;/home/student&nbsp;0700&nbsp;student&nbsp;student&nbsp;1d
#如果目录/home/student&nbsp;还不存在，请创建该目录。如果存在，则清空其所有内容。运行systemd-timpfiles&nbsp;--clean&nbsp;时，删除在超过一天时间内尚未被访问、更改或修改过的所有文件
L&nbsp;/run/fstablink&nbsp;-&nbsp;root&nbsp;root&nbsp;/etc/fastab
#创建指向/etc/fstab的符号链接&nbsp;/run/fstablink&nbsp;。绝对不要自动清除这一行。</pre><p><span style="font-family: 宋体, SimSun"></span><br /></p><p><span style="font-family: 宋体, SimSun">配置文件优先级，配置文件位置可位于三个位置：</span></p><p><span style="font-family: 宋体, SimSun"></span></p><pre class="brush:bash;toolbar:false">/etc/tmpfiles.d/*.conf
/run/tmpfiles.d/*.conf
/usr/lib/tmpfiles.d/*.conf</pre><p><span style="font-family: 宋体, SimSun"></span><br /></p><p><span style="font-family: 宋体, SimSun">/usr/lib/tmpfiles.d/ 中的文件是由相关RPM软件包提供的，不应该由系统管理员进行编辑。</span></p><p><span style="font-family: 宋体, SimSun">/run/tmpfiles.d/ 下的文件本身是易失性文件，通常有守护进程用来管理自己运行时的临时文件。</span></p><p><span style="font-family: 宋体, SimSun">/etc/tmpfiles.d/ 下的文件旨在供管理员配置自定义临时位置，以及覆盖供应商提供的默认值。</span></p><p><span style="font-family: 宋体, SimSun">如果出现同名配置文件优先权依次是： /etc/tmpfiles.d/ &gt;&gt; /run/tmpfiles.d/ &gt;&gt; /usr/lib/tmpfiles.d/ 。</span></p><p><span style="font-family: 宋体, SimSun">给定优先权规则后，管理员将相关文件复制到/etc/tmpfiles.d/ 然后编辑该配置文件，即可轻松覆盖供应商提供的设置。如果以这种方式工作，则确保可从中央配置管理系统轻松管理管理员提供的设置，并且软件包的更新不会覆盖这些设置。<br /></span></p><p><span style="font-family: 宋体, SimSun">在测试新配置或修改后的配置时，对于仅在一个配置文件外应用命令会十分有用。在命令行中指定配置文件中的名称即可实现这一点。</span></p><p><span style="font-family: 宋体, SimSun"></span></p><pre class="brush:bash;toolbar:false">systemd-tmpfiles&nbsp;--creat&nbsp;tmp.conf&nbsp;&nbsp;&nbsp;&nbsp;#测试tmp.conf文件
systemd-tmpfiles&nbsp;--clean&nbsp;tmp.conf</pre><p><span style="font-family: 宋体, SimSun"></span><br /></p>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>354</wp:post_id>
		<wp:post_date><![CDATA[2018-05-14 09:25:12]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-05-14 01:25:12]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[rh134-%e7%ac%ac%e5%9b%9b%e7%ab%a0-%e8%ae%a1%e5%88%92%e5%b0%86%e6%9d%a5%e7%9a%84linux-%e4%bb%bb%e5%8a%a1]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="rhel134"><![CDATA[RHEL134]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_page_template]]></wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[hestia_layout_select]]></wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_old_date]]></wp:meta_key>
			<wp:meta_value><![CDATA[2018-05-13]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>RH134 第五章 管理Linux 进程优先级</title>
		<link>https://www.rhel.tk/2018/05/14/rh134-%e7%ac%ac%e4%ba%94%e7%ab%a0-%e7%ae%a1%e7%90%86linux-%e8%bf%9b%e7%a8%8b%e4%bc%98%e5%85%88%e7%ba%a7/</link>
		<pubDate>Mon, 14 May 2018 03:30:58 +0000</pubDate>
		<dc:creator><![CDATA[blogs]]></dc:creator>
		<guid isPermaLink="false">https://www.rhel.tk/?p=362</guid>
		<description></description>
		<content:encoded><![CDATA[<h6>Linux 进程调度和多任务&nbsp; &nbsp;</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;通过使用称为时间片的技术，Linux（和其它操作系统）实际能够运行的进程数（和线程数）可以超出可用的实际处理单元数。操作系统<span style="color: #FF0000">进程调度程序</span>将在单个核心上的进程之间快速切换，从而给用户一种有多个进程在同时运行的印象。<br /></p><p>相对优先级</p><p>&nbsp;&nbsp;&nbsp;&nbsp;由于不是每种进程都与其它进程同样重要，可告知高度程序为不同的进程使用不同的调度策略。常规系统上运行的大多数进程所使用的调度策略称为SCHED_OTHER(也称为SCHED_NORMAL),但还有一些其他策略可用于不同的目的。<br /></p><p>&nbsp;&nbsp;&nbsp;&nbsp;由于并非所有进程都以同样的方式创建，可为采用SCHED_NORMAL 策略运行的进程指定相对优先级。此优先级称为进程的 nice 值，一个进程可以有正好 40 种不同的 nice 值。这些 nice 值正好从 -20 到 19。默认情况下，进程将继承其父进程的 nice 级别，通常为 0 ， nice 值 级别越高，表示优先级越低（该进程容易将其 CPU 使用量让给其他进程）； nice 级别越低，表示优先级越高（该进程更加不倾向于让出CPU）。<br /></p><p><img src="/wp-content/uploads/image/20180514/1526262567734231.png" title="1526262567734231.png" alt="image.png" /></p><h6>nice 级别和权限</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;为很占CPU资源的进程设置较低的 nice 级别可能对同一系统上运行的其它进程的性能造成负面影响，所以仅允许 root 用户（更具体的说，具有 CAP_SYS_NICE 功能的用户）设置负 nice 级别以及降低现有进程的 nice 级别。<br /></p><p>&nbsp;&nbsp;&nbsp;&nbsp;普通非特权用户仅允许设置正的nice 级别。此外，他们只能对现有进程提升 nice 级别。而不能降低 nice 级别<br /></p><h6>TIP：</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;除 nice 级别以外，还有更多方法可以影响进程优先级和资源使用情况。有备用的高度程序策略和设置、控制组（cgroups）等等，但是 ,nice 级别是最容易的，并且系统管理员和普通用户都可以使用。<br /></p><p>使用 nice 和 renice&nbsp; 影响进程优先级</p><h6>查看 nice 级别</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;可以通过多种不同的方式查看现有进程的 nice 级别。大多数进程管理工具（如 gnome-system-monitor）默认情况下已显示 nice 级别，或可以配置为显示 nice 级别。<br /></p><h6>使用top 显示 nice 级别</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;top 命令可用于通过交互方式查看（和管理）进程。在默认配置中，top 将显示与 nice 级别有关的两列：N1 表示实际 nice 级别，而PR将 nice 级别显示为映射到更大优先级队列： nice 级别 -20 映射到优先级 0 ，而 nice 级别 +19 映射到优先级39。<br /></p><h6>使用ps 显示 nice 级别</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;ps 命令也可以显示进程的 nice 级别，但它在大多数默认输出格式中并不显示，然后，用户可以通过 ps 准备请求所需的列，而 nice 字段的名称为 nice&nbsp;<br /></p><pre class="brush:bash;toolbar:false">#ps&nbsp;请求包括&nbsp;pid&nbsp;、名称和nice&nbsp;级别，按&nbsp;nice&nbsp;级别降序排列：
[root@server0&nbsp;~]#&nbsp;ps&nbsp;axo&nbsp;pid,comm,nice&nbsp;--sort=-nice
&nbsp;&nbsp;&nbsp;PID&nbsp;COMMAND&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NI
&nbsp;&nbsp;&nbsp;286&nbsp;khugepaged&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;19
&nbsp;&nbsp;&nbsp;884&nbsp;alsactl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;19
&nbsp;&nbsp;2639&nbsp;tracker-miner-f&nbsp;&nbsp;19
&nbsp;&nbsp;&nbsp;285&nbsp;ksmd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5
&nbsp;&nbsp;&nbsp;927&nbsp;rtkit-daemon&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;systemd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;kthreadd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;ksoftirqd/0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7&nbsp;migration/0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;rcu_bh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0</pre><p>某些进程的nice 级别可能报告为 - 。这些进程使用不同的高度策略运行，并且调度程序几乎将他们视为具有较高优先级。通过从ps 请求 cls 字段，可以显示调度程序策略。此字段中的 TS 表示该进程在 SCHED_NORMAL 下运行并且可以使用 nice 级别；任何其它内容都表示正在使用不同的调度程序策略。<br /></p><h6>启动具有不同 nice 级别的进程</h6><p>启动进程时，它通常将继承父进程的 nice 级别。这表示从命令行启动一个进程时，它将与从其启动的shell进程具有相同的nice 级别。在大多数情况下，这将导致新进程运行的 nice 级别为 0 。</p><p>要启动具有不同 nice 级别的进程，用户和系统管理员可以使用 nice 工具运行其命令。不带任何其它选项的情况下，运行 nice &lt;COMMAND&gt; 将启动 nice 级别为 10 的 &lt;COMMAND&gt;.通过 nice 命令使用 -n &lt;NICELEVEL&gt; 选项，可以选择其他 nice 级别。如：启动 nice 级别为 15 的命令 dogecoinminer 并将其立即发送到后台:</p><p>nice -n 15 dogecoinminer &amp;</p><h6>TIP:</h6><p>非特权用户允许设置正的 nice级别 （0 - 19 ）。只有 root 可以设置负的 nice级别 （- 20 到 -1）。</p><h6>更改现有进程的 nice 级别</h6><p>可以在命令行中使用 renice 命令来更改现有进程的 nice 级别。 renice 命令的语法如下：</p><p>renice -n &lt;NICELEVEL&gt; &lt;PID&gt; ... （可以一次指定多个进程）</p><p>renice -n -7 $(pgrep origami@home)&nbsp;&nbsp;&nbsp;&nbsp;#将所有origami@home进程的 nice 级别更改为 -7&nbsp;</p><h6>TIP:&nbsp;</h6><p>普通用户仅允许提升 nice 级别，只有 root 才能使用 renice 降低 nice 级别。</p><p>也可以使用 top 命令（以交互方式）更改进程的 nice 级别，在top 中，按 r ，然后跟要更改的 PID 和 新的 nice 级别<br /></p><p><img src="/wp-content/uploads/image/20180514/1526266653786433.png" title="1526266653786433.png" alt="image.png" /></p><p><img src="/wp-content/uploads/image/20180514/1526266685205928.png" title="1526266685205928.png" alt="image.png" /></p><p><img src="/wp-content/uploads/image/20180514/1526266750818667.png" title="1526266750818667.png" alt="image.png" /></p><p><img src="/wp-content/uploads/image/20180514/1526266722562134.png" title="1526266722562134.png" alt="image.png" /></p><p><br /></p>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>362</wp:post_id>
		<wp:post_date><![CDATA[2018-05-14 11:30:58]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-05-14 03:30:58]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[rh134-%e7%ac%ac%e4%ba%94%e7%ab%a0-%e7%ae%a1%e7%90%86linux-%e8%bf%9b%e7%a8%8b%e4%bc%98%e5%85%88%e7%ba%a7]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="rhel134"><![CDATA[RHEL134]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_page_template]]></wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>RH134 第六章 使用访问控制列表（ACL）控制对文件的访问</title>
		<link>https://www.rhel.tk/2018/05/17/rh134-%e7%ac%ac%e5%85%ad%e7%ab%a0-%e4%bd%bf%e7%94%a8%e8%ae%bf%e9%97%ae%e6%8e%a7%e5%88%b6%e5%88%97%e8%a1%a8%ef%bc%88acl%ef%bc%89%e6%8e%a7%e5%88%b6%e5%af%b9%e6%96%87%e4%bb%b6%e7%9a%84%e8%ae%bf%e9%97%ae/</link>
		<pubDate>Thu, 17 May 2018 09:16:40 +0000</pubDate>
		<dc:creator><![CDATA[blogs]]></dc:creator>
		<guid isPermaLink="false">https://www.rhel.tk/?p=369</guid>
		<description></description>
		<content:encoded><![CDATA[<h6>访问控制列表概念<br /></h6><p>标准Linux 文件权限可以满足绝大多数情况的要求，但它也有局限性。限制访问文件的权限也仅限授予文件所有者、单组成员或其他任何人。进程（正在运行的程序）可能不适合成为文件所属的成员，授予所有人权限则更不是理想的操作。</p><p>ACL 允许向文件分配细化权限。除标准的文件所有者、组所有者和其他文件权限之外，还可以向指定用户或指定组，以及由UID或GUID确定的用户和组授予权限。这个权限均应用相同的权限标志：r w x .</p><p>文件所有者可以在单个文件或目录上设置ACL 。新文件和子目录可以自动从父目录默认ACL（若存在）中继承ACL设置。与常规文件的访问规则相似，父目录层次结构需要至少设置其他执行权限，以便启用指定用户和指定组的访问权限。</p><h6>文件系统挂载选项</h6><p>文件系统挂载已经启用的ACL 支持。<span style="color: #FF0000">XFS</span> 文件系统内置有 ACL支持。在 RHEL 7上创建的<span style="color: #FF0000">ext4</span> 文件系统默认启用了 acl 选项，而安装红帽早期版本中创建的ext4 文件系统则可能需要通过<span style="color: #FF0000">挂载请求包含ACL 选项</span>，或者在超级块中设置选项。</p><h6>查看和解释ACL 权限</h6><p>ls -l 仅输入最少的 ACL 设置详细信息</p><p><img src="/wp-content/uploads/image/20180514/1526285537683356.png" title="1526285537683356.png" alt="image.png" /></p><p>如果由10个字符组成的权限字符串的末尾是 “+”，即表示此文件有相关联的ACL 设置 。对用户、组和其它的“rwx”标志解释如下：<br /></p><ul class=" list-paddingleft-2" style="list-style-type: disc"><li><p>用户：显示用户 ACL 设置，其与标准的用户文件设置相同：rwx</p></li><li><p>组：显示当前的 ACL 掩码设置，而不是组所有者设置：rw</p></li><li><p>其他：显示其他 ACL 设置，其与标准的其它文件设置相同，无访问权限。</p></li></ul><h6>TIPS:</h6><p>如果使用chmod 更改具有 ACL 文件的组权限，则不会更改组所有者仅限，而是更改 ACL 掩码。如果目的是更新文件的组所有者权限，需要使用</p><p>&nbsp;setfacl -m g::perms file</p><h6>查看文件 acl&nbsp;</h6><p>要显示文件上的 ACL 设置 ，使用 getfacl file</p><p><img src="/wp-content/uploads/image/20180514/1526286552326310.png" title="1526286552326310.png" alt="image.png" /></p><p><img src="/wp-content/uploads/image/20180514/1526286628954630.png" title="1526286628954630.png" alt="image.png" /></p><pre class="brush:bash;toolbar:false">#前三行是注释，用于识别文件名、所有者（student）、和组所有者（controller）.如果存在任何其它文件标志（如&nbsp;setuid&nbsp;或&nbsp;setgid&nbsp;),则会出现第四行注释来显示所设置的标志。</pre><p><img src="/wp-content/uploads/image/20180514/1526286600143773.png" title="1526286600143773.png" alt="image.png" /></p><ol class=" list-paddingleft-2" style="list-style-type: decimal"><li><p>文件所有者权限。student 具有 rwx 。<br /></p></li><li><p>指定用户权限。与此文件相关联的每位指定用户均有一个条目。james 不具有任何权限。</p></li><li><p>指定用户权限。UID 1005 具有 rwx ，但是掩码将有效权限限制为rw&nbsp;</p></li></ol><h6>掩码条目：</h6><p><img src="/wp-content/uploads/image/20180514/1526288457208748.png" title="1526288457208748.png" alt="image.png" /></p><p>掩码设置显示可能为所有指定用户、组所有者和指定组提供的最大权限 。 UID 1005 、controller 和 GID 2210 无法执行此文件，即便每个条目增均已经设置执行权限。</p><h6>其它条目：</h6><p><img src="/wp-content/uploads/image/20180514/1526288467671948.png" title="1526288467671948.png" alt="image.png" /></p><p>其他或“全局”权限。所有其他的UID 和GID 均无任何权限。</p><h6>查看目录 ACL</h6><p>要显示目录上的 ACL 设置，使用 getfacl /direcotry:</p><p><img src="/wp-content/uploads/image/20180514/1526288669879354.png" title="1526288669879354.png" alt="image.png" /></p><h6>打开注释条目：</h6><p><img src="/wp-content/uploads/image/20180514/1526288787444516.png" title="1526288787444516.png" alt="image.png" /></p><p>前三行是注释，用于识别目录名、所有者（student)和组所有者（controller）。如果存在任何其他目录标志（如 setuid,setgid,sticky）,则会出现第四行注释来显示所设置的标志（示例为 setgid）</p><h6>标准 ACL 条目</h6><p><img src="/wp-content/uploads/image/20180515/1526347461483244.png" title="1526347461483244.png" alt="image.png" /></p><p>此目录上的 ACL 权限与前述文件示例中的相同，但适用于目录。其关键区别在于这些条目包含了执行权限（适用时），以允许目录搜索权限<br /></p><h6>默认条目</h6><p><img src="/wp-content/uploads/image/20180515/1526347563548361.png" title="1526347563548361.png" alt="image.png" /></p><ol class=" list-paddingleft-2" style="list-style-type: decimal"><li><p>默认文件所有者 ACL 权限。 文件所有者将获得 rwx ，并在新子目录上执行操作<br /></p></li><li><p>默认指定用户 ACL 权限，每位指定用户均有一个条目，他们将自动获得应用到新文件或子目录的默认ACL ，james 始终默认设置为没有任何权限</p></li></ol><p><img src="/wp-content/uploads/image/20180515/1526347790707759.png" title="1526347790707759.png" alt="image.png" /></p><p>默认掩码设置显示可能为所有新建文件或目录，（其具有指定用户 ACL 、组所有者 ACL 或指定组 ACL ）提供的初始最大权限： 读取和写入新文件，对新子目录的执行权限，但是新文件永远不可获得执行权限。<br /></p><p><img src="/wp-content/uploads/image/20180515/1526347988908292.png" title="1526347988908292.png" alt="image.png" /></p><p>默认其它或“全局”权限，所有其它 UID 和 GID&nbsp; 对新文件或新子目录均没有任何权限。<br /></p><p>上述示例中的默认条目不包括指定用户 （ UID 1005）和指定组（GID 2210），因此，它们不会自动获得添加至任何新文件或新子目录的初始 ACL 条目。这会有效的将他们限制在其已具有 ACL 的文件和子目录中，或者限制在相关文件所有者后来使用 setfacl 添加了 ACL 的文件和子目录。这些条目仍可创建自己的文件和子目录。</p><h6>TIPS:</h6><p>getfacl 中的输出可用作 setfacl 的输入。使用 getfacl -R /directory 生成目录及其内容的输出，通过将此输出传递给 setfacl --set-file=file 进行批量更新，可保存此输出并可用于日后恢复。</p><p>ACL 掩码<br /></p><p>ACL&nbsp; 掩码定义可授予指定用户、组所有者和指定组的最大权限。它不限制文件所有者或其他用户的权限。所有实施 ACL 的文件和目录都将具有ACL 掩码。</p><p>可使用 getfacl 查看掩码，并通过 setfacl 显示设置掩码。如果未显式设置，系统会自动计算并添加掩码；但也可从父目录默认掩码设置中继承掩码。默认情况下，每当添加、修改或删除任何受影响的 ACL 时，均会重新计算掩码。&nbsp;</p><h6>ACL 权限优先级</h6><p>在决定一个进程（正在运行的程序）能否访问文件时，将按如下所示应用文件权限和 ACL ：</p><ul class=" list-paddingleft-2" style="list-style-type: disc"><li><p>如果正在以文件所有者身份运行进程，则应用文件的用户 ACL 权限。</p></li><li><p>如果正在以指定用户 ACL 条目中列出的用户身份运行进程，则应用指定用户 ACL 权限（只要掩码允许）</p></li><li><p>如果正在以与文件的组所有者相匹配的组身份运行进程，或者以具有显式指定组 ACL 条目的组身份运行进程，则应用相匹配的 ACL 权限（只要掩码允许 ）</p></li><li><p>否则，将应用文件的其它 ACL 权限。</p></li></ul><h5>使用 ACL 保护文件安全</h5><h6>更改 ACL 文件权限</h6><p>使用 setfacl 添加、修改或删除文件和目录的标准 ACL&nbsp;</p><p>ACL 采用普通的权限文件系统表示法：rwx (读、写、执行)，“-”表示缺少相关权限。X(大写) 表示如果文件还没有相关的执行权限，则只设置目录的执行权限，用户同 chmod&nbsp;</p><h6>添加或修改 ACL 权限</h6><p>可以使用 -m 通过合作行设置，或者使用 -M（使用“-”（短划线），而不使用 stdin 的文件名）通过文件传递 ACL 。这两个选项会为文件或目录添加新的 ACL 条目，或替换特定的现在 ACL 条目。文件或目录的任何其它现在 ACL 条目不变</p><p>使用 --set 或 --set-file 选项来完全替换文件的 ACL 设置</p><p>首次定义文件的 ACL 时，如果添加操作不包含文件所有者、组所有者或其它权限的设置，则系统会基于当前标准文件权限来设置以上权限的设置（这些设置也称为基础 ACL ，且无法删除），系统也会计算并添加新掩码值。</p><p>要添加或修改用户 ACL 或指定用户 ACL ：</p><pre class="brush:bash;toolbar:false">setfacl&nbsp;-m&nbsp;u:name:rX&nbsp;file</pre><p>如果 name 留空，则它适用于文件所有者，否则 name 可以是用户名或 UID 值。在本例中，授予权限为只读和执行（需要文件所属组有执行权限）（除非 file 为目录，此时目录设置执行权限，以允许进程目录搜索）</p><p>ACL 文件所有者和标准文件所有者权限相同，因此使用chmod 设置所有者权限对 ACL 没有任何影响</p><p>要添加或修改组 ACL 或指定组 ACL&nbsp;</p><pre class="brush:bash;toolbar:false">setfacl&nbsp;-m&nbsp;g:name:rw&nbsp;file</pre><p>与添加或修改用户 ACL 的模式相同，如果 name 留空，则它适用于所有者。否则请指定组名或 GID 值。</p><p>对于具有 ACL 设置的谁的， chmod 的对任何组权限都没有影响，但会更新 ACL 掩码。<br /></p><p>要添加或修改其它 ACL&nbsp;</p><pre class="brush:bash;toolbar:false">setfacl&nbsp;-m&nbsp;o::-&nbsp;file</pre><p>其它 ACL 仅接受权限设置，权限通常为 “-”即无权限，或者指定任何标准权限 rwx&nbsp;</p><p>ACL 其它权限及标准其他权限相同，因此使用其它权限中的 chmod 等于使用其它权限中的 setfacl&nbsp;</p><p>通过一条命令添加多个条目，并以逗号分隔各个条目</p><pre class="brush:bash;toolbar:false">setfacl&nbsp;-m&nbsp;u::rwx,g:sodor:rX,o::-&nbsp;file</pre><h6>使用 getfacl 作为输入</h6><p>getfacl 的输出作为 setfacl 输入</p><pre class="brush:bash;toolbar:false">getfacl&nbsp;file-A&nbsp;|&nbsp;setfacl&nbsp;--set-file=-&nbsp;file-B
#&nbsp;--set-file&nbsp;接受文件或&nbsp;stdin&nbsp;中的输入，‘-’指定了&nbsp;stdin&nbsp;的使用。在此例中，file-B&nbsp;和&nbsp;file-A&nbsp;设置相同。</pre><h6>设置明确的 ACL 掩码<br /></h6><p>可以明确设置文件或目录的 ACL 掩码，以限制指定用户、组所有者和指定组的最大有效权限。限制超出掩码的权限。</p><pre class="brush:bash;toolbar:false">setfacl&nbsp;-m&nbsp;m::r&nbsp;file</pre><p>该操作会设置 ACL 的掩码值为只读权限，此设置不影响所有者和其它用户。</p><p>getfacl 时会在受掩码设置限制的条目旁边显示 “<span style="color: #FF0000">注释</span>”</p><h6>TIPS:</h6><p>默认情况下，每当修改或删除受影响的 ACL 设置（指定用户、组所有者或指定组）时系统都会重新计算 ACL 掩码，进而可能重新设置上一个明确的掩码设置。</p><p>为避免重新计算掩码，请使用 -n ,或者将掩码设置 （ -m m::perms） 包含在会修改受掩码影响的 ACL 设置的任何 setfacl 操作中。</p><p>递归 ACL 修改，使用 -R 选项</p><pre class="brush:bash;toolbar:false">setfacl&nbsp;-R&nbsp;-m&nbsp;u:name:rX&nbsp;directory</pre><p>#该操作会将用户name 添加到 directory 和所有文件和子目录中，从而授予只读和条件执行权限。</p><h6>删除 ACL&nbsp;</h6><p>无需指定 &quot;:perms（权限）&quot; 外，删除特定 ACL 条目与修改操作的基本形式相同。</p><pre class="brush:bash;toolbar:false">setfacl&nbsp;-x&nbsp;u:name,g:name&nbsp;file</pre><p>该操作只会从文件或目录 ACL 列表中删除指定用户和指定组。任何其它现有 ACL 均保持活动。可以在同一 setfacl 操作中使用删除 (-x) 和 修改 （-m）操作。</p><p>掩码只能在未设置其它 ACL （无法删除的基础 ACL 除外）的情况下删除。因此必须最后删除。文件不再有 ACL ，并且 ls -l 不会在权限字符串旁边显示 “+” 符号。要删除文件或目录的所有 ACL （包括目录的默认 ACL ）使用：</p><pre class="brush:bash;toolbar:false">setfacl&nbsp;-b&nbsp;file</pre><h6>控制默认 ACL 文件权限</h6><p>目录可以设置默认 ACL ，这些 ACL 会由所有新文件和新子目录自动继承，可以针对各个标准 ACL 设置来设置默认 ACL 权限，其中包括默认掩码</p><p>目录仍然需要具备标准 ACL 才能进程访问权限控制，因为默认 ACL 不会对目录实施访问权限控制；他们仅提供 ACL 权限继承支持。</p><pre class="brush:bash;toolbar:false">setfacl&nbsp;-m&nbsp;d:u:name:rx&nbsp;directory</pre><p>该命令会添加一个默认的指定用户（d:u:name），该用户拥有对子目录的只读和执行权限。</p><p>用于为各个 ACL 类型添加默认 ACL 的 setfacl 命令与用于标准 ACL 的命令完全相同，但是以 &quot;d:&quot; 开关，或者在命令行使用 &quot;-d&quot; 选项。</p><h6>TIPS：</h6><p>设置目录默认 ACL 时，需要在默认 ACL 中包含执行权限（X）来确保用户可以访问子目录.</p><p>用户不会自动设置对新文件的常规文件执行权限，新常规文件的掩码为rw-</p><p>新文件和新子目录会继续从创建用户设置自己的 UID 和主要组 GID 值，不过当父目录 setgid 标志启用时除外，这种情况下，主要组 GID 与 父目录 GID 相同。</p><h6>删除默认 ACL</h6><pre class="brush:bash;toolbar:false">setfacl&nbsp;-x&nbsp;d:u:name&nbsp;directory&nbsp;
setfacl&nbsp;-k&nbsp;/directory&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#删除目录的所有默认&nbsp;ACL&nbsp;
setfacl&nbsp;-b&nbsp;/directory&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#删除目录的所有&nbsp;ACL</pre><pre class="brush:bash;toolbar:false">setfacl&nbsp;-Rm&nbsp;g:sodor:rwX&nbsp;/shares/steamies&nbsp;&nbsp;&nbsp;&nbsp;#递归授予sodor组&nbsp;读取、写入、条件执行权限。（仅针对目录和现有可执行文件）
setfacl&nbsp;-Rm&nbsp;u:james:-&nbsp;/shares/steamies&nbsp;&nbsp;&nbsp;&nbsp;#递归授予&nbsp;james&nbsp;无任何权限
setfacl&nbsp;-m&nbsp;d:g:sodor:rwx&nbsp;/shares/steamies&nbsp;&nbsp;&nbsp;&nbsp;#添加sodor&nbsp;组默认访问规则，steamies&nbsp;目录的读取、写入、执行权限
setfacl&nbsp;-m&nbsp;d:u:james:-&nbsp;/share/steamies&nbsp;&nbsp;&nbsp;&nbsp;#添加用户james&nbsp;对steamies&nbsp;目录无任何权限</pre><p><br /></p>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>369</wp:post_id>
		<wp:post_date><![CDATA[2018-05-17 17:16:40]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-05-17 09:16:40]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[rh134-%e7%ac%ac%e5%85%ad%e7%ab%a0-%e4%bd%bf%e7%94%a8%e8%ae%bf%e9%97%ae%e6%8e%a7%e5%88%b6%e5%88%97%e8%a1%a8%ef%bc%88acl%ef%bc%89%e6%8e%a7%e5%88%b6%e5%af%b9%e6%96%87%e4%bb%b6%e7%9a%84%e8%ae%bf%e9%97%ae]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="rhel134"><![CDATA[RHEL134]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_page_template]]></wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>RH134 第七章 管理 SELINUX 安全性</title>
		<link>https://www.rhel.tk/2018/05/21/rh134-%e7%ac%ac%e4%b8%83%e7%ab%a0-%e7%ae%a1%e7%90%86-selinux-%e5%ae%89%e5%85%a8%e6%80%a7/</link>
		<pubDate>Mon, 21 May 2018 09:41:40 +0000</pubDate>
		<dc:creator><![CDATA[blogs]]></dc:creator>
		<guid isPermaLink="false">https://www.rhel.tk/?p=377</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>SElinux 安全的基本概念<br /></h3><p>Security Enhanced Linux（SELinux）是一个额外的系统安全层。SELinux 的主要目标是防止已遭泄露的系统服务访问用户数据。大多数Linux管理员都熟悉标准的用户/组/其他权限安全模型。这种基于用户和组的模型称为自由决定的访问控制。SELinux 提供另一层安全，它基于对象并由更加复杂的规则控制，称为强制访问控制。</p><p><img src="/wp-content/uploads/image/20180518/1526607016211181.png" title="1526607016211181.png" alt="blob.png" /></p><p>要允许远程匿名访问Web服务器，必须打开防火墙端口。然而，恶意人员却有机会通过安全漏洞侵入系统，而且如果他们破坏web 服务器进程，还会取得其权限，即apache 用户和apache 组的权限。该用户/组具有对文档根目录（/var/www/html）等项目的读取权限，以及对 /tmp 、/var/tmp 和所有人均可编写的任何其他文件/目录的写入权限<br /></p><p><img src="/wp-content/uploads/image/20180521/1526867174600183.png" title="1526867174600183.png" alt="image.png" /></p><p>SELinux 是用于确定哪个进程可以访问哪些文件、目录和端口的一组安全规则。每个文件文件、进程和端口都具有特别的安全标签，称为SELinux 上下文。上下文是一个名称，SELinux 策略使用它来确定某个进程能否访问文件、目录或端口。除非显式规则授予访问权限，否则，在默认情况下，策略不允许任何交互。如果没有允许规则，则不允许访问。<br /></p><p>SELinux 标签具有多种上下文：用户、角色、类型和敏感度。目标策略（即 RHEL 中启用的默认策略）会根据类型上下文来制定自己规则。类型上下文名称通常以 _t 结尾。</p><p>Web 服务器的类型上下文是 httpd_t 。</p><p>通常位于 /var/www/html 中的文件和目录的类型上下文是 httpd_sys_content_t 。&nbsp;</p><p>通常位于 /tmp 和 /var/tmp 中的文件和目录的类型上下文是 tmp_t 。</p><p>Web 服务器端口的类型上下文是 http_port_t .</p><p>存在某个策略规则 ，其允许 Apache （作为httpd_t 运行的Web 服务器进程）访问上下文通常位于 /var/www/html 及其他 Web 服务器目录 （httpd_sys_content_t） 中的文件和目录。对于通常位于 /tmp 和 /var/tmp 中的文件，策略中没有允许 规则 ，因此不允许进程访问。有了 SELinux ，恶意用户就无法访问 /tmp 目录。SELinux 还有适用于 NFS 和 CIFS 等远程文件系统的规则，尽管这些文件系统上的所有文件都使用相同的上下文标签。<br /></p><p>许多处理文件的命令具有一个用于显示或设置 SELinux 的上下文选项（通常是 -Z ）.例如，ps、ls、cp 和 mkdir 全都使用 -Z 选项来显示或设置 SELinux 上下文。</p><p><img src="/wp-content/uploads/image/20180521/1526868364153324.png" title="1526868364153324.png" alt="image.png" /></p><h6>SELinux 模式<br /></h6><p>若出于故障排除目的，可使用 SELinux 模式暂时禁用 SELinux 保护</p><p><img src="/wp-content/uploads/image/20180521/1526868454617069.png" title="1526868454617069.png" alt="image.png" /><br /></p><p>在强制（Enforcing）模式中，SELinux 主动拒绝访问尝试读取类型上下文 tmp_t 的文件的Web 服务器。在强制模式中，SELinux 不仅记录而且提供保护。<br /></p><p><br /></p><p><img src="/wp-content/uploads/image/20180521/1526868484423514.png" title="1526868484423514.png" alt="image.png" /></p><p>许可（Permissive ）模式通常用于对问题进程故障排除，在许可模式中，即使没有显式规则， SELinux 也会允许所有交互，而且会记录它在强制模式中拒绝的那些交互。可使用此模式来暂时允许访问 SELinux 正在限制的内容。无需重新启动即可在强制模式和许可模式之间相互转换。</p><p>第三种模式是禁用（Disabled）模式，会完全禁用SELinux 。需要重新启动系统才能彻底禁用SELinux ，或是从禁用模式转为强制模式或许可模式。</p><h6>TIPS:</h6><p>最好使用许可模式，而不是彻底关闭 SELinux 。原因之一在于即使在许可模式中，内核也将根据需要自动维护 SELinux 文件系统标签，从而避免为了启用 SELinux 而重启系统，重新标记文件系统所带来的昂贵费用。</p><p>要显示当前使用的有效 SELinux 模式，使用 getenforce 命令<br /></p><pre class="brush:bash;toolbar:false">[root@client&nbsp;~]#&nbsp;getenforce&nbsp;
Enforcing</pre><h6>SELinux 布尔值<br /></h6><p>SELinux 布尔值的更改 SELinux 策略行为的开关。 SELinux&nbsp; 布尔值是可以启用或禁用的规则，安全管理可以使用 SELinux 布尔值来有选择地调整策略。</p><p>getsebool&nbsp; 命令用于显示 SELinux 布尔值及其当前值。 -a 选项可列出所有布尔值</p><pre class="brush:bash;toolbar:false">[root@client&nbsp;~]#&nbsp;getsebool&nbsp;-a
abrt_anon_write&nbsp;--&gt;&nbsp;off
abrt_handle_event&nbsp;--&gt;&nbsp;off
abrt_upload_watch_anon_write&nbsp;--&gt;&nbsp;on
antivirus_can_scan_system&nbsp;--&gt;&nbsp;off
………………</pre><h6>更改 SELinux 模式</h6><p>setenforce 命令修改当前的 SELinux 模式。</p><pre class="brush:bash;toolbar:false">[root@client&nbsp;~]#&nbsp;setenforce&nbsp;
usage:&nbsp;&nbsp;setenforce&nbsp;[&nbsp;Enforcing&nbsp;|&nbsp;Permissive&nbsp;|&nbsp;1&nbsp;|&nbsp;0&nbsp;]</pre><p>暂时性设置 SELinux 模式的另一种做法是在启动时将参数传递给内核。传递内核参数 enforcing=0 会使系统在启动时进入许可模式。值 1 将指定强制模式。可在指定 selinux=0 参数时禁用 SELinux 。值 1 将启用 SELinux 。<br /></p><h6>设置默认 SELinux&nbsp;</h6><p>确定在启动时使用哪种 SELinux 模式的配置文件是 /etc/selinux/config .配置文件中包含有用的注释信息</p><p><img src="/wp-content/uploads/image/20180521/1526871627344712.png" title="1526871627344712.png" alt="image.png" /></p><p>使用 /etc/selinux/config 更改启动时的默认 SELinux 模式。在上述示例中，它被设置为强制模式。<br /></p><p>传递 selinux= 和/或 enforcing= 内核参数会覆盖在 /etc/selinux/config 中指定的任何默认值。</p><p>更改 SELinux 上下文</p><p>初始 SELinux 上下文</p><p>通常文件父目录的 SELinux 上下文决定该文件的初始 SELinux 上下文。父目录的上下文会分配给新建文件。这适用于 vim、cp、和touch等命令。但是，如果文件是在其他位置创建并且权限得以保留，（如使用 mv 或 cp -a），那么原始 SELinux 上下文将不会发生更改。</p><p><img src="/wp-content/uploads/image/20180521/1526872601651338.png" title="1526872601651338.png" alt="image.png" /><br /></p><p>更改文件的 SELinux 上下文。可使用两个命令来更改文件 SELinux 上下文： chcon 和restorecon 。chcon 命令将文件的上下文更改成已指定为该命令参数的上下文。 -t 选项经常只用于指定上下文的类型。</p><p>restorecon 命令是更改文件或目录的 SELinux 上下文的首选方法。不同于 chcon ，在使用此命令时，不会明确指定上下文，它使用 SELinux 策略中的规则来确定应该是哪种文件上下文。</p><h6>TIPS：</h6><p>不应使用 chcon 来更改文件的 SELinux 上下文。在明确指定上下文时，可能会出错。如果在系统启动时重新标记了其它文件系统，文件上下文将会还原为默认上下文。</p><pre class="brush:bash;toolbar:false">[root@server0&nbsp;~]#&nbsp;mkdir&nbsp;/virtual
[root@server0&nbsp;~]#&nbsp;ls&nbsp;-Zd&nbsp;/virtual/
drwxr-xr-x.&nbsp;root&nbsp;root&nbsp;unconfined_u:object_r:default_t:s0&nbsp;/virtual/
[root@server0&nbsp;~]#&nbsp;chcon&nbsp;-t&nbsp;httpd_sys_content_t&nbsp;/virtual/
[root@server0&nbsp;~]#&nbsp;ls&nbsp;-Zd&nbsp;/virtual/
drwxr-xr-x.&nbsp;root&nbsp;root&nbsp;unconfined_u:object_r:httpd_sys_content_t:s0&nbsp;/virtual/
[root@server0&nbsp;~]#&nbsp;restorecon&nbsp;-v&nbsp;/virtual/
restorecon&nbsp;reset&nbsp;/virtual&nbsp;context&nbsp;unconfined_u:object_r:httpd_sys_content_t:s0-&gt;unconfined_u:object_r:default_t:s0
[root@server0&nbsp;~]#&nbsp;ls&nbsp;-Zd&nbsp;/virtual/
drwxr-xr-x.&nbsp;root&nbsp;root&nbsp;unconfined_u:object_r:default_t:s0&nbsp;/virtual/</pre><h6>定义 SELinux 默认文件上下文规则<br /></h6><p>semanage fcontext 命令可用于显示或修改 restorecon 命令用来设置默认文件上下文的规则。它使用扩展正则表达式来指定路径和文件名。fcontext 规则中最常用的扩展正则表达式是 (/.*)?，这意味着：“（可选）匹配 / 后跟任意的字符”。它将会匹配在表达式前面列出的目录并递归地匹配该目录中的所有内容。</p><p>restorecon 命令是 policycoreutil 软件包的一部分； semanage 是 policycoreutil-python 软件包的一部分。</p><pre class="brush:bash;toolbar:false">[root@server0&nbsp;~]#&nbsp;touch&nbsp;/tmp/file1&nbsp;/tmp/file2
[root@server0&nbsp;~]#&nbsp;ls&nbsp;-Z&nbsp;/tmp/file*
-rw-r--r--.&nbsp;root&nbsp;root&nbsp;unconfined_u:object_r:user_tmp_t:s0&nbsp;/tmp/file1
-rw-r--r--.&nbsp;root&nbsp;root&nbsp;unconfined_u:object_r:user_tmp_t:s0&nbsp;/tmp/file2
[root@server0&nbsp;~]#&nbsp;mv&nbsp;/tmp/file1&nbsp;/var/www/html/
[root@server0&nbsp;~]#&nbsp;cp&nbsp;/tmp/file2&nbsp;/var/www/html/
[root@server0&nbsp;~]#&nbsp;ls&nbsp;-Z&nbsp;/var/www/html/
-rw-r--r--.&nbsp;root&nbsp;root&nbsp;unconfined_u:object_r:user_tmp_t:s0&nbsp;file1
-rw-r--r--.&nbsp;root&nbsp;root&nbsp;unconfined_u:object_r:httpd_sys_content_t:s0&nbsp;file2
[root@server0&nbsp;~]#&nbsp;semanage&nbsp;fcontext&nbsp;-l
………………
/var/www(/.*)?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;all&nbsp;files&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;system_u:object_r:httpd_sys_content_t:s0&nbsp;
………………
[root@server0&nbsp;~]#&nbsp;restorecon&nbsp;-Rv&nbsp;/var/www/
restorecon&nbsp;reset&nbsp;/var/www/html/file1&nbsp;context&nbsp;unconfined_u:object_r:user_tmp_t:s0-&gt;unconfined_u:object_r:httpd_sys_content_t:s0
[root@server0&nbsp;~]#&nbsp;ls&nbsp;-Z&nbsp;/var/www/html/file
ls:&nbsp;cannot&nbsp;access&nbsp;/var/www/html/file:&nbsp;No&nbsp;such&nbsp;file&nbsp;or&nbsp;directory
[root@server0&nbsp;~]#&nbsp;ls&nbsp;-Z&nbsp;/var/www/html
-rw-r--r--.&nbsp;root&nbsp;root&nbsp;unconfined_u:object_r:httpd_sys_content_t:s0&nbsp;file1
-rw-r--r--.&nbsp;root&nbsp;root&nbsp;unconfined_u:object_r:httpd_sys_content_t:s0&nbsp;file2</pre><p>以下示例显示了如何使用semanage 为新目录添加上下文。<br /></p><pre class="brush:bash;toolbar:false">[root@server0&nbsp;~]#&nbsp;touch&nbsp;/virtual/index.html
[root@server0&nbsp;~]#&nbsp;ls&nbsp;-Zd&nbsp;/virtual/
drwxr-xr-x.&nbsp;root&nbsp;root&nbsp;unconfined_u:object_r:default_t:s0&nbsp;/virtual/
[root@server0&nbsp;~]#&nbsp;ls&nbsp;-Z&nbsp;/virtual/
-rw-r--r--.&nbsp;root&nbsp;root&nbsp;unconfined_u:object_r:default_t:s0&nbsp;index.html
[root@server0&nbsp;~]#&nbsp;semanage&nbsp;fcontext&nbsp;-a&nbsp;-t&nbsp;httpd_sys_content_t&nbsp;&#039;/virtual(/.*)?&#039;
[root@server0&nbsp;~]#&nbsp;restorecon&nbsp;-RFvv&nbsp;/virtual/
restorecon&nbsp;reset&nbsp;/virtual&nbsp;context&nbsp;unconfined_u:object_r:default_t:s0-&gt;system_u:object_r:httpd_sys_content_t:s0
restorecon&nbsp;reset&nbsp;/virtual/index.html&nbsp;context&nbsp;unconfined_u:object_r:default_t:s0-&gt;system_u:object_r:httpd_sys_content_t:s0
[root@server0&nbsp;~]#&nbsp;ls&nbsp;-Zd&nbsp;/virtual/
drwxr-xr-x.&nbsp;root&nbsp;root&nbsp;system_u:object_r:httpd_sys_content_t:s0&nbsp;/virtual/
[root@server0&nbsp;~]#&nbsp;ls&nbsp;-Z&nbsp;/virtual/
-rw-r--r--.&nbsp;root&nbsp;root&nbsp;system_u:object_r:httpd_sys_content_t:s0&nbsp;index.html</pre><pre class="brush:bash;toolbar:false">#实验
[root@server0&nbsp;~]#&nbsp;mkdir&nbsp;/custom
[root@server0&nbsp;~]#&nbsp;echo&nbsp;&quot;This&nbsp;is&nbsp;server0&quot;&nbsp;&gt;/custom/index.html
[root@server0&nbsp;~]#&nbsp;vim&nbsp;/etc/httpd/conf/httpd.conf&nbsp;
[root@server0&nbsp;~]#&nbsp;grep&nbsp;custom&nbsp;/etc/httpd/conf/httpd.conf&nbsp;
DocumentRoot&nbsp;&quot;/custom&quot;
&lt;Directory&nbsp;&quot;/custom&quot;&gt;
[root@server0&nbsp;~]#&nbsp;systemctl&nbsp;start&nbsp;httpd
[root@server0&nbsp;~]#&nbsp;semanage&nbsp;fcontext&nbsp;-a&nbsp;-t&nbsp;httpd_sys_content_t&nbsp;&#039;/custom(/.*)?&#039;
[root@server0&nbsp;~]#&nbsp;restorecon&nbsp;-Rv&nbsp;/custom/
restorecon&nbsp;reset&nbsp;/custom&nbsp;context&nbsp;unconfined_u:object_r:default_t:s0-&gt;unconfined_u:object_r:httpd_sys_content_t:s0
restorecon&nbsp;reset&nbsp;/custom/index.html&nbsp;context&nbsp;unconfined_u:object_r:default_t:s0-&gt;unconfined_u:object_r:httpd_sys_content_t:s0</pre><h6>更改 SELinux 布尔值</h6><p>SELinux 布尔值是更改 SELinux 策略行为的开关。 SELinux 布尔值是可以启用或禁用的规则。安全管理员可以使用 SELlinux 布尔值来有选择地调整策略。</p><p>selinux-policy-devel 软件包提供多个手册页（即 *_selinux(8)），可用于解释不同服务的布尔值的含义。如果已经安装此软件包，则 man -k &#039;_selinux&#039; 命令会列出这些文档。</p><p>getsebool 命令用于显示SELinux 布尔值；setsebool 用于修改 SELinux 布尔值。setsebool -P 修改 SELinux 策略，并使修改永久保留。 semanage boolean -l 将显示布尔值是否为永久值，并提供该布尔值的简短描述。</p><p><br /></p><pre class="brush:bash;toolbar:false">getsebool&nbsp;-a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#查看所有boolean&nbsp;值
getsebool&nbsp;httpd_enable_homedirs&nbsp;&nbsp;&nbsp;&nbsp;#查看指定内容布尔值
setsbool&nbsp;httpd_enable_homedirs&nbsp;[&nbsp;on&nbsp;|&nbsp;off&nbsp;|&nbsp;0&nbsp;|&nbsp;1&nbsp;]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#设置布尔值，1=on,0=off
semanage&nbsp;boolean&nbsp;-l&nbsp;|&nbsp;grep&nbsp;httpd_eable_homedirs&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;查看布尔值是否为永久值（当前，永久）
setsebool&nbsp;-P&nbsp;httpd_enable_homedirs&nbsp;[&nbsp;on&nbsp;|&nbsp;off&nbsp;|&nbsp;0&nbsp;|&nbsp;1&nbsp;]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#设置永久布尔值
semanage&nbsp;boolean&nbsp;-l&nbsp;&nbsp;-C&nbsp;&nbsp;&nbsp;&nbsp;#仅列出本地修改的&nbsp;SELinux&nbsp;布尔值状态（与策略中默认值不同的任何设置）</pre><h6><span style="font-size: 14px"></span>对 SELinux 进行故障的排除<br /></h6><p>1、在考试做任何调整之前，应了解到SELinux 禁止意图访问的这一做法也许非常正确。当Web 服务器尝试访问 /home 中的文件时，如果用户并未发布 Web 内容，则可能表明服务器遭入侵。如果已授权访问权限，则需要采取其他步骤来解决此问题。</p><p>2、最常见的 SELinux 问题是使用不正确的文件上下文，此问题会在以下情况中发生：即，使用一个文件上下文在某个位置创建了文件，而该文件又被移至预期会使用其他上下文的地方。在大多数情况下，运行 restorecon 将会更正此问题。以这种方式更正问题对系统剩余部分的安全性有非常小的影响。</p><p>3、对于严苛限制性访问的另一个补救措施可以通过调整布尔值。例如：ftpd_anon_write 布尔值控制匿名 FTP 用户能否上传文件。如果希望允许匿名 FTP 用户上传文件到服务器，则必须启用此布尔值。调整布尔值需格外谨慎，因为布尔值会对系统的安全性造成广泛影响。</p><p>4、SELinux 策略可能存在阻止合法访问的漏洞。由于 SELinux 技术已经成熟，这种情况极少发生。</p><h6>监控 SELinux 冲突</h6><p>必须安装setroubleshoot-server 包，以便将 SELinux 消息发送到 /var/log/messages 。setroubleshoot-server 侦听 /var/log/audit/audit.log 中的审核消息，并发送简短摘要到 /var/log/messages 。该摘要包括 SELinux 冲突的唯一标识符 （ UUID ），可用于收集更多信息。 <span style="color: #FF0000">sealert </span>-l UUID&nbsp; 可用于生成特定事件的报告。 <span style="color: #FF0000">sealert -a</span> /var/log/audit/audit.log 用于生成该文件中的所有事件报告。</p><p><img src="/wp-content/uploads/image/20180521/1526892834926496.png" title="1526892834926496.png" alt="image.png" /></p><p><img src="/wp-content/uploads/image/20180521/1526892877639896.png" title="1526892877639896.png" alt="image.png" /></p><p><img src="/wp-content/uploads/image/20180521/1526892917350022.png" title="1526892917350022.png" alt="image.png" /></p><p><img src="/wp-content/uploads/image/20180521/1526892939342968.png" title="1526892939342968.png" alt="image.png" /></p><h6>TIPS：</h6><p>“Raw Audit Messages”部分显示，目标文件 /var/www/html/file3 正是问题所在，同样，目标上下文 tcontext 似乎并不属于Web 服务器。使用 restorecon /var/www/html/file3 命令修复此文件上下文。如果还需要调整其它文件，restorecon 可递归地重置上下文：restorecon -R /var/www/</p><p>1、查看 tail -f /var/log/messages&nbsp; 查看有sealert 的内容，确定事件 UUID&nbsp;</p><p>2、运行给出的 sealert -l UUID 查看解决办法</p><p>3、运行 2 中的命令给出信息的头部是建议解决方案</p><p>4、查看 &quot;Raw Audit Messages&quot; 确定问题文件，给结合步骤 3 给出解决方案。</p><p><br /></p><p><span style="font-size: 14px"><br /></span></p><p><br /></p><p><br /></p>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>377</wp:post_id>
		<wp:post_date><![CDATA[2018-05-21 17:41:40]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-05-21 09:41:40]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[rh134-%e7%ac%ac%e4%b8%83%e7%ab%a0-%e7%ae%a1%e7%90%86-selinux-%e5%ae%89%e5%85%a8%e6%80%a7]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="rhel134"><![CDATA[RHEL134]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_page_template]]></wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>RH134 第八章 连接到网络定义的用户和组</title>
		<link>https://www.rhel.tk/2018/07/06/rh134-%e7%ac%ac%e5%85%ab%e7%ab%a0-%e8%bf%9e%e6%8e%a5%e5%88%b0%e7%bd%91%e7%bb%9c%e5%ae%9a%e4%b9%89%e7%9a%84%e7%94%a8%e6%88%b7%e5%92%8c%e7%bb%84/</link>
		<pubDate>Fri, 06 Jul 2018 10:00:19 +0000</pubDate>
		<dc:creator><![CDATA[blogs]]></dc:creator>
		<guid isPermaLink="false">https://www.rhel.tk/?p=390</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>使用身份管理服务<br /></h3><p>用户信息和身份验证服务</p><p>集中式身份管理系统至少需要提供两项服务：</p><p>1、账户信息：包括用户名、主目录位置、UID 和 GID 、组成员身份等信息。常用的解决方案包括 LDAP （轻量级目录访问协议，用于 Active Directory 和 IPA 服务器等多个产品中）以及网络信息服务（NIS）。</p><p>2、身份验证信息：系统验证用户身份的一种方法。这可以通过两种方式完成：向客户端系统提供加密密码哈希，或向服务器发送（加密）密码并接收响应。 LDAP 服务器不仅提供账号信息，也提供身份验证信息。 Kerberos 仅提供 sso 身份验证服务，通常与 LDAP 用户信息一起使用。 Kerberos 可用于 IPA 服务器和 Active Directory。</p><p>在 RHEL7 系统上，本地用户信息由 /etc/passwd 提供，而身份验证信息（采用哈希密码的形式）由 /etc/shadow 提供。</p><p>将系统连接到集中式 LDAP 服务器和 Kerberos 服务器</p><h6>Authconfig</h6><p>将 RHEL 7 系统配置为使用集中式身份管理服务器需要编辑各种文件，以及配置某些守护进程。为连接到中央 LDAP 服务器和 Kerberos 服务器，至少需要更新以下文件：</p><p>/etc/ldap.conf：关于中央 LDAP 服务器及其设置的信息</p><p>/etc/krb5.conf：关于中央 Kerberos 基础架构的信息</p><p>/etc/sssd/sssd.conf：用于配置系统安全服务守护进程（sssd），即负责检索和缓存用户信息和身份验证信息的守护进程</p><p>/etc/nsswitch.conf：为系统指明应使用哪些用户信息和身份验证服务</p><p>/etc/pam.d/*：配置应如何处理各种服务的身份验证</p><p>/etc/openldap/cacerts：用于存储根证书颁发机构（CA），这些证书颁发机构可以验证用来识别 LDAP 服务器的 SSL 证书。</p><p>sssd 守护进程需要先启用并启动，然后才能供系统使用<br /></p><p>配置如此多的文件和服务很容易出错 ， RHEL 7 随附了一套工具，可以自动完成这些配置：authconfig. authconfig 包含三个全部可以执行相同操作的相关工具：</p><p>authconfig：命令行工具。此工具可用于在多个系统间自动进程配置。与 authconfig 配置使用的命令往往都较长，其中会传递多个选项。此工具使用 authconfig 软件包安装。</p><p>authconfig-tui: authconfig 的交互式版本。使用菜单驱动的文本界面。可通过 ssh 使用。此工具使用 authconfig 软件包安装</p><p>authconfig-gtk：此版本将启动图形界面，它也可以作为 system-config-authentication 启动。此工具使用 authconfig-gtk 软件安装。</p><h6>必需的LDAP 参数</h6><p>要连接到中央LDAP服务以获取用户信息，authconfig 需要一些设置：</p><p>LDAP 服务器的主机名称</p><ul class=" list-paddingleft-2" style="list-style-type: disc"><li><p>系统应在其中查找用户的LDAP树部分的base DN(区分名称)。这通常类似于 dc=example,dc=com 或 ou=People,o=PonyCorp. 此信息将由 LDAP 服务器管理员提供。</p></li><li><p>如果使用SSL/TLS 为与 LDAP 服务器的通信加密，那么 LDAP 服务器将提供可验证证书的根CA证书。</p></li></ul><p>重要信息：系统还需要安装一些额外的软件包来提供LDAP 客户端功能。安装 sssd 将提供所有必需的依赖关系。</p><h6>必需的 Kerberos 参数</h6><p>要将系统配置为使用集中工 Kerberos 系统进程用户身份验证，authconfig 需要以下设置：</p><ul class=" list-paddingleft-2" style="list-style-type: disc"><li><p>要使用 Kerberos 域的名称， Kerberos 域是全部使用一组共同的 Kerberos 服务器和用户进行身份验证的计算机组成的域。</p></li><li><p>一个或多个关键分发中心（KDC）。这是Kerberos 服务器的主机名称。</p></li><li><p>一个或多个管理服务器主机名称。这是客户端在希望更改密码或执行其他修改时将联系的计算机。它通常与主KDC 相同，但也可以是不同的计算机。</p></li></ul><p>此外，管理员可以指定是否应使用 DNS 来查找要为特定主机名称使用的域，以及自动查找 KDC 服务器和管理服务器。可以安装一个额外的软件包 krb5-workstation ,以便帮助对 Kerberos 问题进行调试，以及从命令行处理 Kerberos 票据。</p><h6>使用authconfig-gtk&nbsp;<br /></h6><p>要使用authconfig-gtk 配置系统以采用 LDAP + Kerberos 请执行以下步骤：</p><p>1、安装必需的软件包</p><pre class="brush:bash;toolbar:false">yum&nbsp;-y&nbsp;install&nbsp;authconfig-gtk&nbsp;sssd&nbsp;krb5-workstation&nbsp;pam_krb5(必须)</pre><p>2、启动authconfig-gtk&nbsp;<br /></p><p>3、填写相关信息，如图</p><p><img src="/wp-content/uploads/image/20180706/1530842356574303.png" title="1530842356574303.png" alt="image.png" /></p><p>4、如果支持 TLS ，请选中使用 TLS 加密连接，然后下载 CA 证书<br /></p><p>5、从身份验证方法下载菜单选择 Kerberos 密码，然后填写域，KDC 和管理服务器字段。如果选中使用 DNS 查找域的 KDC 选项，则最后两个字段不可用。</p><p>6、如果中央目录不可用，用户可以通过选项高级选项上的在首次登录时创建的主目录框，在首次登录时创建目录</p><p>7、单击应用按钮以保存并激活更改。这将写入所有相关配置文件，并（重新）启动 sssd 服务。</p><h6>测试配置</h6><p>要测试 LDAP + Kerberos 配置，管理员只需要尝试使用某个网络用户的凭据登录系统（通过ssh ），此外，<span style="color: #FF0000">getent </span>命令可用于检索有关某个网络用户的信息，格式为 getent passwd &lt;USERNAME&gt;<br /></p><p>TIPS ： 在默认配置中，当没有为 getent&nbsp; 命令指定用户名时， sssd 不会列举网络用户，这是为保持图形登录 屏幕的整洁以及节省宝贵的网络资源和时间。</p><h6>将系统连接到 IPA 服务器</h6><p>红帽提供了一种配置 LDAP 和 Kerberos 的集成解决方案：IPA (身份、策略和审核)服务器。 IPA 服务器提供 LDAP 和 Kerberos ,还有一套基于命令行和基于Web 的管理工具。除用户和身份验证信息以外， IPA 服务器还可以将 sudo 规则、ssh 公钥、SSH 主机密钥、TLS 证书、自动挂载器映射以及更多功能集中化。</p><p>使用 ipa-client&nbsp;</p><p>可以通过 authconfig 这套工具将 RHEL7 系统配置为使用 IPA 服务器，但还有一种专用的工具：ipa-client-install&nbsp; 。此命令可从ipa-client 包安装，该软件包将引入所有依赖关系（如 sssd）</p><p>使用 ipa-client-install 的优势之一是，它可以从DNS 检索到几乎所有的必要信息（当由IPA服务器配置或由管理员手动配置时），并能够在 IPA服务器上创建主机条目和更多信息。这就使 IPA 服务器管理员可以为该主机设置访问策略、创建服务主体（例如，对于 NFSv4 导出）等等</p><p>当不带任何参数运行 ipa-client-install 时，它将首次尝试从 DNS 检索有关为其DNS 域配置的 IPA 服务器信息，如果失败，它将提示管理员输入必要信息，例如IPA 服务器的域名和要使用的域。需要提供的其他信息是允许在 IPA 服务器上创建新计算机条目的账户的用户名和密码。除非已为此目的创建了另一个账户，否则默认 IPA 服务器管理员账户（admin） 可以用于此目的。</p><p>DNS 驱动配置参考：<br /></p><pre class="brush:bash;toolbar:false">ipa-client-install&nbsp;--domain=server0.example.com&nbsp;--no-ntp&nbsp;--mkhomedir</pre><p><img src="/wp-content/uploads/image/20180706/1530861460111883.png" title="1530861460111883.png" alt="image.png" /></p><p>可以将所有必需信息作为命令行参数指定，从而使无人值守设置作为系统初始配置的一部分完成：例如通过kickstart 指定这些信息。<br /></p><p>使系统加入 Active Directory&nbsp;<br /></p><p>RHEL 7 提供多种方法可使系统加入 Active Directory 。管理员可以选择安装 <span style="color: #FF0000">samba-winbind </span>软件包，然后通过authconfig 系统工具配置winbind;，也可以安装<span style="color: #FF0000"> sssd </span>和 <span style="color: #FF0000">realmd </span>软件包，然后使用 sssd 和 realm 命令。</p><p>注意：rcalm 命令也可以用于加入 Kerberos 域或 IPA 服务器域，但最终配置略有不同。例如，用户的用户名将加上@domain .ipa-client-install 是加入 IPA 域的首选方法。</p><p>例：假定 Active Directory 域名为 domain.example.com&nbsp;</p><pre class="brush:bash;toolbar:false">1、yum&nbsp;-y&nbsp;install&nbsp;realmd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#安装必要的软件包&nbsp;realmd&nbsp;
2、sudo&nbsp;realm&nbsp;discover&nbsp;domain.example.com&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#发现domain域的设置
3、sudo&nbsp;realm&nbsp;join&nbsp;domain.example.com&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#加入域并配置&nbsp;sssd、pam、&nbsp;/etc/nsswitch.conf&nbsp;.此命令尝试使用&nbsp;Administrator&nbsp;账户使本地系统加入&nbsp;Active&nbsp;directory&nbsp;，系统提示时输入此账户密码。要使用其它账户，请使用&nbsp;--user&nbsp;参数。
4、#Active&nbsp;Directory&nbsp;账户现在本地可用，但使用&nbsp;Active&nbsp;Directory&nbsp;登录仍处理禁用状态。要启用登录，请使用以下命令：
sudo&nbsp;realm&nbsp;permit&nbsp;--realm&nbsp;domain.example.com&nbsp;--all
#要仅允许特定用户登录，请将&nbsp;--all&nbsp;替换为这些用户的列表。例如：
sudo&nbsp;realm&nbsp;permit&nbsp;--realm&nbsp;domain.example.com&nbsp;DOMAIN\\Itchy&nbsp;DOMAIN\\Scratchy.</pre><h6>注意</h6><p>默认情况下，域用户必须使用其完全限定名称登录；例如</p><p>ipauser@ipa.example.com(IPA 用户) 或 DOMAIN\Picard (Active Directory)。要禁用此功能，<span style="color: #FF0000">请将 /etc/sssd/sssd.conf 中相应域块中的 use_fully_qualified_names 设置更改为False</span> ，或将其完全删除，然后重新启动 sssd 服务。</p><p><br /></p><p>authconfig{ , -{ ,-gtk , -tui}}&nbsp; 可用于将系统配置为使用集中式身份管理服务<br /></p><p>sssd 配置为后台检索、验证缓存身份验证和用户信息。</p>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>390</wp:post_id>
		<wp:post_date><![CDATA[2018-07-06 18:00:19]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-07-06 10:00:19]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[rh134-%e7%ac%ac%e5%85%ab%e7%ab%a0-%e8%bf%9e%e6%8e%a5%e5%88%b0%e7%bd%91%e7%bb%9c%e5%ae%9a%e4%b9%89%e7%9a%84%e7%94%a8%e6%88%b7%e5%92%8c%e7%bb%84]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="rhel134"><![CDATA[RHEL134]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_page_template]]></wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>2</wp:comment_id>
			<wp:comment_author><![CDATA[blogs]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[blogs@rhel.tk]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[49.68.71.108]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-07-07 11:00:39]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-07-07 03:00:39]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[getent passwd ldapuser0 无法获取的时候看一下有没有安装pam_krb5 的库]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>2</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_error]]></wp:meta_key>
				<wp:meta_value><![CDATA[1530932439]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1530932439.358758;s:5:"event";s:11:"check-error";s:4:"user";s:5:"blogs";s:4:"meta";a:1:{s:8:"response";s:7:"invalid";}}]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
				<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1531274029.66925;s:5:"event";s:15:"status-approved";s:4:"user";s:5:"blogs";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>RH134 第九章 向linux 系统添加磁盘、分区和文件系统</title>
		<link>https://www.rhel.tk/2018/07/12/rh134-%e7%ac%ac%e4%b9%9d%e7%ab%a0-%e5%90%91linux-%e7%b3%bb%e7%bb%9f%e6%b7%bb%e5%8a%a0%e7%a3%81%e7%9b%98%e3%80%81%e5%88%86%e5%8c%ba%e5%92%8c%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f/</link>
		<pubDate>Thu, 12 Jul 2018 03:21:48 +0000</pubDate>
		<dc:creator><![CDATA[blogs]]></dc:creator>
		<guid isPermaLink="false">https://www.rhel.tk/?p=399</guid>
		<description></description>
		<content:encoded><![CDATA[<p>使用fdisk 在采用MBR 分区方案的磁盘上创建和删除磁盘分区<br /></p><p>使用gdisk在采用 GPT 分区方案的磁盘上创建和删除磁盘分区</p><p>使用mkfs 格式化带有文件系统的设备</p><h6>磁盘分区</h6><p>硬盘分区可以将硬盘划分为多个逻辑存储单元，这些单元称为分区。通过将磁盘划分为多个分区，系统管理员可以使用不同的分区执行不同功能，例如：</p><ul class=" list-paddingleft-2" style="list-style-type: disc"><li><p>限制应用或用户的可用空间</p></li><li><p>允许从同一磁盘进行不同操作系统的多重启动</p></li><li><p>将操作系统和程序文件与用户文件分隔开。</p></li><li><p>创建用于操作系统虚拟内存交换的单独区域。</p></li><li><p>限制磁盘空间使用情况，提高诊断工具和备份映像的性能。</p></li></ul><h6>MBR 分区方案</h6><p>MBR 指定BIOS 如果对磁盘进行分区，最多支持4个主分区，在linux 上可以使用扩展分区和逻辑分区来创建最多15个分区。由于分区大小数据以32位值存储，最大磁盘和分区大小限制为 2 TiB<br /></p><h6>GPT 分区方案</h6><p>对于运行统一可扩展固件接口接口（UEFI）固件的系统，GPT 是在物理硬盘上布置上分区表的标准。GPT是UEFI 标准的一部分。GPT 默认情况下支持最多128个分区。GPT 使用 64 位值，支持最大 8 ZiB 。即80亿太字字的分区和磁盘。</p><h6>注意：</h6><p>GTP 的 8 ZiB限制是基于512字节的块大小，随着硬盘驱动器供应商转为使用 4096 字节块，此限制将增加至64 ZiB.</p><p>除解决 MBR 分区方案的限制以外，GPT 还可提供一些其他功能特性和优势。正如其名，GPT 使用128的GUID 来唯一识别每个磁盘和分区。与 MBR 存在单一故障点不同， GPT 提供分区表信息的冗余。主GPT 位于磁盘头部，而备份副本（次要GPT）位于磁盘尾部。此外 GPT 采用 CRC 校验和来检测 GPT 头和分区表中的错误与损坏。</p><h6>使用fdisk 管理MBR 分区<br /></h6><p>创建 MBR 式磁盘分区涉及八个步骤：</p><p>1、指定设备，以root身份运行</p><p><img src="/wp-content/uploads/image/20180711/1531276497330227.png" title="1531276497330227.png" alt="image.png" /></p><p>2、请求一个新的主分区可扩展分区</p><p>输入 n 以请求一个新分区，并指定该分区是主分区还是扩展分区。默认为主分区类型，超过4个分区可通过扩展分区来解决</p><p><img src="/wp-content/uploads/image/20180711/1531276592930306.png" title="1531276592930306.png" alt="image.png" /></p><p>3、指定分区编号<br /></p><p>用来作为磁盘上新分区的标识使用，默认值是未使用的最小分区编号</p><p><img src="/wp-content/uploads/image/20180711/1531276722303229.png" title="1531276722303229.png" alt="image.png" /></p><p>4、指定新分区开始的第一个扇区<br /></p><p>默认值为第一个可用扇区，一般不需要改</p><p><img src="/wp-content/uploads/image/20180711/1531276804698343.png" title="1531276804698343.png" alt="image.png" /></p><p>5、指定新分区结束 的最后一个扇区</p><p>默认值是与新分区相邻的可用且未分区扇区中的最后一个扇区。</p><p><img src="/wp-content/uploads/image/20180711/1531276896690206.png" title="1531276896690206.png" alt="image.png" /></p><p>除末尾扇区编号以外，fdisk 还可以接受代表分区期望大小的数字，该数字以扇区数表示：</p><p><img src="/wp-content/uploads/image/20180711/1531276914317730.png" title="1531276914317730.png" alt="image.png" /></p><p>fdisk 提供的最后一个，也是最为用户友好的输入选项，就是以单位 KB,MB,或GB 指定新分区的大小：</p><p><img src="/wp-content/uploads/image/20180711/1531276934798991.png" title="1531276934798991.png" alt="image.png" /></p><p>输入分区的末尾边界后，fdisk 就会显示分区创建的确认信息。</p><p><img src="/wp-content/uploads/image/20180711/1531276954842354.png" title="1531276954842354.png" alt="image.png" /></p><p>6、定义分区类型</p><p>如果新创建的分区应具有 Linux 以外的类型，请输入 t 命令来更改分区类型。输入新分区类型的十六进制代码。如果需要，可使用 L 命令显示所有分区类型的十六进制代码表。正确设置分区类型非常重要，因为某些工具依靠它才能正常运行。例如，当 Linux 内核遇到类型为 0xfd（Linux RAID）分区时，它将尝试自动启动 RAID 卷。</p><p><img src="/wp-content/uploads/image/20180711/1531276971677806.png" title="1531276971677806.png" alt="image.png" /></p><p>7、保存分区表更改</p><p>发出 w 命令，以便将更改写入到磁盘分区表并退出 fdisk 程序。从而完成创建请求。<br /></p><p><img src="/wp-content/uploads/image/20180711/1531276989994678.png" title="1531276989994678.png" alt="image.png" /></p><p>8、启动内核对新分区表的重新读取。</p><p>运行partprobe 命令，并将磁盘设备名称作为参数，以强制重新读取其分区表。</p><p><img src="/wp-content/uploads/image/20180711/1531277008909144.png" title="1531277008909144.png" alt="image.png" /></p><h6>tips:</h6><p>仅当管理员发出 w 命令将所有分区表更改定稿到磁盘时，fdisk 程序才会将所有分区表编辑排队，并将这些编辑写入到磁盘。如果在退出交互式fdisk 会话之前未执行 w 命令，则所有请求都会被丢弃，而磁盘的分区表不变。此功能在向fdisk 发出错误命令时尤为实用，要放弃错误的命令并避免意想不到的后果。只需退出 fdisk 并且不保存分区表更改。</p><p>删除 MBR 磁盘分区<br /></p><p>使用 fdisk 从采用 MBR 分区的磁盘中删除分区需要到五个步骤：</p><p>1、指定要删除分区的磁盘，执行 fdisk 命令，并指定磁盘设备名称作为参数</p><p>2、确定要删除分区的编号，输入 p 以打印分区表</p><p>3、请求删除分区，输入 d 命令启动分区删除，然后指定要删除的分区编号&nbsp;</p><p>4、保存分区表更改，发出 w 指令，将更改写入到分区表，从而完成分区表删除请求</p><p>5、启动内核对分区表的重新读取，使用 partprobe 以磁盘名称为参数。 ps: partprobe /dev/sdb&nbsp;</p><p><br /></p><hr /><h6>使用 gdisk 管理gpt 分区</h6><p>对于采用 GPT 分区方案的磁盘，可使用 gdisk 分区编辑器管理分区。</p><h6>警告：</h6><p>尽管已向 fdisk 添加了 GPT 的支持，但该支持仍被视为实验性质，因此应使用 gdisk 命令在采用 GPT 分区方案进行分区的磁盘上执行分区更改。</p><p><br /></p><p>创建 GPT 磁盘分区需要八个步骤：</p><p>1、指定要创建分区的设备，同 fdisk&nbsp;</p><p>2、 请求新分区，同 fdisk&nbsp;</p><p>3、指定分区编号 ，同 fdisk&nbsp;</p><p>4、指定新分区开始的磁盘位置，同 fdisk ,支持指定大小（KB,MB,GB,TB,PB）的方式</p><p>5、指定磁盘上新分区的最后一个扇区，同 fdisk&nbsp;</p><p>6、定义分区类型，操作同 fdisk&nbsp;</p><p>7、保存分区表</p><p>8、重新加载分区</p><p>删除 GPT 的磁盘分区表，同 fdisk 操作<br /></p><h6>创建文件系统&nbsp;<br /></h6><p>创建块设备后，下一步是为其应用文件系统格式。文件系统将向块设备应用一种结构 ，这样就可以存储数据并从中检索数据。红帽企业 Linux 支持许多不同的文件系统类型，其中两种常见的类型是 xfs 和 ext4 。红帽企业 Linux 安装程序 anaconda 中默认使用 xfs .<br /></p><p>mkfs 命令可用于为块设备应用文件系统。如果不指定类型，则将使用扩展类型二（ext2）文件系统，该类型在许多使用场合下并不可取。要指定文件类型，应使用 -t 。</p><p><img src="/wp-content/uploads/image/20180711/1531296248918343.png" title="1531296248918343.png" alt="image.png" /></p><h6>挂载文件系统</h6><p>应用文件系统格式后，添加新文件系统的文件最后一步是将该文件系统连接到目录结构中。文件系统连接到目录层次结构中后，用户空间实用程序可以访问设备上的文件或在设备上写入文件。</p><h6>手动挂载文件系统</h6><p>管理员可使用 mount 命令将设备手动连接到目录位置或挂载点，具体为指定设备和挂载点，以及可能需要的任何选项，从而自定义设备的行为。</p><pre class="brush:bash;toolbar:false">mount&nbsp;/dev/sdb1&nbsp;/mnt</pre><p>mount 还可用于查看当前已挂载的文件系统、挂载点和选项</p><p><img src="/wp-content/uploads/image/20180711/1531296936475764.png" title="1531296936475764.png" alt="image.png" /></p><p>手动挂载文件系统是验证已经格式化的设备是否可访问或是否按预期方式工作的一种理想方式。但是，当系统重新启动后，尽管文件系统仍然存在并且具有完整的数据，但它不会再次换挂载到目录树中。如果管理员希望永久挂载文件系统，则需要将该文件系统的一个列表添加到 /etc/fstab 。<br /></p><h6>永久挂载文件系统</h6><p>通过将设备的列表添加到 /etc/fstab&nbsp; 文件中，管理员可心将设备配置为在系统启动后挂载到挂载点。</p><p>/etc/fstab 是以空格分隔的文件，每行具有六个字段</p><p><img src="/wp-content/uploads/image/20180711/1531297457952475.png" title="1531297457952475.png" alt="image.png" /></p><p>第一个字段是指定要使用的设备。示例中分别使用了 UUID 和设备文件两种方式来指定设备。UUID 存储在文件系统超级块中，并在文件系统创建时创建。</p><h6>tips:</h6><p>使用 UUID 更为可取，因为块设备标识符在特定情况下可能会发生变化，例如当云提供商更改虚拟机的基础存储层时。块设备的文件可能会变化，但UUID 会在设备的超级块中保持不变。</p><p>blkid 命令可用于扫描连接到计算机的块设备，并报告已分配的 UUID 和文件系统格式等数据。</p><p><img src="/wp-content/uploads/image/20180711/1531297827908462.png" title="1531297827908462.png" alt="image.png" /></p><p>第二个字段是设备应连接到目录层次结构中的挂载点。挂载点应已存在，如果不存在，可以使用 mkdir 创建挂载点。挂载点中最好不要有文件。</p><p>第三个字段是包含已应用于块设备的文件系统类型。</p><p>第四个字段是挂载时应该应用于设备以便自定义行为的选项列表。此字段是必须的，且有一组称为 defaults 的常用选项。其它选项记录在 mount man page 中。</p><p>最后两个字段是转储标志和 fsck 顺序。转储标志与dump 命令配合使用，用于生成设备内容的备份。fsck 顺序字段确定在文件系统未完全卸载的情况下，是否应在启动时运行 fsck 。fsck 顺序的值指示当有多个文件系统需要检查时，应对这些文件系统运行 fsck 的顺序 。</p><h6>tips :<br /></h6><p>/etc/fstab 中存在错误的条目可能会导致计算机无法启动。为避免这种情况，管理员应卸载新文件系统，然后使用 mount -a （该命令将读取 /etc/fstab ）将该文件系统重新挂载到原位，以验证条目是否有效。如果 mount -a 命令返回错误，则应在重新启动计算机之前纠正错误。</p><h6>管理交换空间</h6><p>交换空间是可与Linux&nbsp; 内核内存管理子系统配合使用的磁盘区域。交换空间用于通过保存不活动的内存页来补充系统RAM 。系统 RAM与交换空间组合在一起称为虚拟内存。</p><p>当系统上的内存使用量超过定义的限制时，内核将梳理 RAM ，寻找已分配给进程但空闲的内存页。内核将空闲的内存页写入到交换区，并且重新分配 RAM 页面以代其他进程使用。如果某个程序需要访问已写入到磁盘的页面，则内核会找到另一个空闲的内存页，将其写入到磁盘，然后从交换区重新调用所需的页面。</p><p>由于交换区位于磁盘上，所以与 RAM相经交换非常慢。尽管交换空间用于扩充系统 RAM ，但应仅可能将交换空间的使用保持在最低限度。</p><p>创建交换空间，管理员需要执行三项任务：</p><ul class=" list-paddingleft-2" style="list-style-type: disc"><li><p>创建分区</p></li><li><p>将分区的类型设置为 82 Linux swap&nbsp;</p></li><li><p>对设备进行签名格式化</p></li></ul><p>创建分区，使用工具 fdisk 创建所需大小的分区。</p><p><img src="/wp-content/uploads/image/20180712/1531359731927864.png" title="1531359731927864.png" alt="image.png" /></p><p><img src="/wp-content/uploads/image/20180712/1531359756116868.png" title="1531359756116868.png" alt="image.png" /></p><h6>分配分区类型<br /></h6><p>交换分区创建后，建议为做法是将分区类型可系统 ID 更改为 82 Linux swap 。在过去，工具会根据分配类型来确定是否应激活设备，但现在情况已不再如此。即使实用程序不再使用分区类型，设备分区类型也可以全管理员快速确定该分区的用途。</p><p><img src="/wp-content/uploads/image/20180712/1531359953672134.png" title="1531359953672134.png" alt="image.png" /></p><p>格式化设备， mkswap 命令向设备应用交换签名。与其他格式化工具不同， mkswap 在设备开关写入单个数据块，而将设备的其余部分保留为未格式化，从而使其可用于存储内存页。</p><p><img src="/wp-content/uploads/image/20180712/1531359975493820.png" title="1531359975493820.png" alt="image.png" /></p><h6>激活交换空间</h6><p>管理员可以使用&nbsp; swapon 命令激活已格式化交换空间。可以在设备上调用 swapon&nbsp; ，否则 swapon -a 就将激活 /etc/fstab 文件中列出的所有交换空间。</p><p><img src="/wp-content/uploads/image/20180712/1531360582174595.png" title="1531360582174595.png" alt="image.png" /></p><h6>永久激活交换空间<br /></h6><p>交换空间很可能需要在每次计算机启动时自动激活。为使计算机在每次启动时都激活交换空间，必需在 /etc/fstab 文件中进行配置。</p><p>如果需要，管理员可以使用 swapoff 命令停用交换空间。只有当任何交换的数据都可以写入到其他活动的交换空间或写回内存中时， swapoff 才会成功。如果数据无法写入到其他位置，则 swapoff 会失败，并显示错误，而交换空间将仍保持活动。</p><p><img src="/wp-content/uploads/image/20180712/1531360808313305.png" title="1531360808313305.png" alt="image.png" /></p><p>该示例使用UUID 作为第一个字段。 UUID 存储在设备上存储的交换签名中，并且是 mkswap 输出的一部份。如果 mkswap 输出已丢失，则可以使用 blkid 命令扫描系统并报告所有已连接的块设备。如果管理员不希望使用 UUID ，则第一个字段也可以使用原始设备名称。</p><p>第二个字段通常为 mount point 保留。但是，由于交换设备无法通过目录结构访问，此字段是占位符值 swap&nbsp;</p><p>第三个字段是文件系统类型。交换空间的文件系统类型为 swap&nbsp;</p><p>第四个字段是选项，在上例中，使用了选项 defaults 。defaults 包括 挂载选项 auto, 即用于设备交换空间在启动时自动激活的选项。</p><p>最后两个字段 是转储标志和 fsck 顺序。交换空间不需要备份，也不需要文件系统检查 。</p><h6>注意：</h6><p>默认情况下会按顺序使用交换空间，即先使用第一个已激活交换空间，直到其空间已满，然后内核将开始使用第十个交换空间。使用 swapon -s 可显示交换空间的优先级。并可使用 pri= 挂载选项设备这些优先级。如果交换空间具有相同的优先级，则内核将循环写入到这些空间，而非写入单个交换空间直到其容量已满。</p><p><br /></p><p><img src="/wp-content/uploads/image/20180712/1531365704503638.png" title="1531365704503638.png" alt="image.png" /></p>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>399</wp:post_id>
		<wp:post_date><![CDATA[2018-07-12 11:21:48]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-07-12 03:21:48]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[rh134-%e7%ac%ac%e4%b9%9d%e7%ab%a0-%e5%90%91linux-%e7%b3%bb%e7%bb%9f%e6%b7%bb%e5%8a%a0%e7%a3%81%e7%9b%98%e3%80%81%e5%88%86%e5%8c%ba%e5%92%8c%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="rhel134"><![CDATA[RHEL134]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_page_template]]></wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>RH134 第十章 管理逻辑卷管理(LVM)存储</title>
		<link>https://www.rhel.tk/2018/07/31/rh134-%e7%ae%a1%e7%90%86%e9%80%bb%e8%be%91%e5%8d%b7%e7%ae%a1%e7%90%86lvm%e5%ad%98%e5%82%a8/</link>
		<pubDate>Tue, 31 Jul 2018 09:42:47 +0000</pubDate>
		<dc:creator><![CDATA[blogs]]></dc:creator>
		<guid isPermaLink="false">https://www.rhel.tk/?p=415</guid>
		<description></description>
		<content:encoded><![CDATA[<p><span style="font-size: 24px">逻辑卷管理（LVM）概念</span><br /></p><p>逻辑卷和逻辑卷管理有助于更加轻松的管理磁盘空间。如果 LVM 托管的文件系统需要更多的空间，可以将其卷组中的可用空间分配给逻辑卷，并且可以调整文件系统的大小。如果磁盘开始出现错误，可以将替换磁盘注册为物理卷放入卷组中，并且逻辑卷的区块可迁移到新磁盘。</p><p><br /></p><p><br /></p><p><img src="/wp-content/uploads/image/20180730/1532914548221728.png" title="1532914548221728.png" alt="image.png" width="358" height="302" /></p><p><br /></p><ul class=" list-paddingleft-2" style="list-style-type: disc"><li><p>物理设备是用于保留逻辑卷中所存储的存储设备。它们是块设备，可以是磁盘分区、整个磁盘、RAID阵列或SAN磁盘。设备必须初始化为 LVM 物理卷，才能与 LVM结合使用。整个”设备“将作用一个物理卷。</p></li><li><p>物理卷（PV）用于注册基础物理设备以便在卷组中使用。 LVM 自动将 PV划分为物理区块(PE);它们是充当 PV 是最小的存储块的小块数据。</p></li><li><p>卷组（VG） 是存储池，由一个或多个物理卷组成。一个PV只能分配给一个 VG ，VG 可以包含未使用的空间和任意数目的逻辑卷。</p></li><li><p>逻辑卷（LV）根据卷组中的空闲物理范围创建，提供应用、用户和操作系统所使用的”存储“设备。 LV是逻辑区块 （ LE）的集合， LE映射到物理区块（PV 的最小存储块）。默认情况下，每个 LE将映射到一个PE ，设置特定的 LV选项将会更改此映射；例如：镜像会导致每个 LE映射到两个 PE。</p></li></ul><p><img src="/wp-content/uploads/image/20180730/1532915362809606.png" title="1532915362809606.png" alt="image.png" /></p><p><span style="font-size: 20px">管理逻辑卷<br /></span></p><p><span style="font-size: 18px">创建逻辑卷</span><br /></p><p><span style="font-size: 16px">创建可用的逻辑卷需要五个步骤：</span></p><p>1、准备物理设备</p><p>&nbsp;使用 fdisk 、gdisk 或 parted 创建新分区，以便与 LVM 结合使用。在 LVM 分区上，始终将分区类型设备为 Linux LVM 。也可以使用完成的磁盘、RAID 阵列或 SAN 磁盘。</p><p><img src="/wp-content/uploads/image/20180730/1532915604992709.png" title="1532915604992709.png" alt="image.png" /></p><p>2、创建物理卷</p><p>使用pvcreate 为分区（或其他物理设备）添加标签，使其作为物理卷与 LVM 结合使用。会将用于存储 LVM 配置数据的一个标头直接写入到 PV ，PV 分为多个固定大小的物理范围（PE），以空格分隔多个设备名。<br /></p><p><img src="/wp-content/uploads/image/20180730/1532915758521488.png" title="1532915758521488.png" alt="image.png" /></p><p>此命令会将设备 /dev/vda2 和 /dev/vdb1 标记为 PV，准备好分配到卷组中。</p><p>仅当没有空闲的 PV 可以创建或扩展 VG 时，才需要创建 PV</p><p>3、创建卷组</p><p>&nbsp;vgcreate 用于创建包含一个或多个物理卷的池，称为卷组。 VG 的大小由池中的物理范围的总数决定。 VG&nbsp; 负责通过向 LV 分配空闲 PE 来托管一个或多个逻辑卷；因此 ，在创建 LV时 ,VG 必须具有足够的空闲 PE 可用。</p><p>以 vgcreate 的参数形式，定义 VG 名称并列出一个或多个要分配给 VG 的 PV。</p><p><img src="/wp-content/uploads/image/20180730/1532916156887043.png" title="1532916156887043.png" alt="image.png" /></p><p>此命令将创建名为 vg-alpha 的 VG ，它的大小是 /dev/sda2 和 /dev/vdb1 ，这两个PV的总大小（以PE单位计）</p><p>仅当没有现有 VG 时才需要创建VG.可能会出于管理原因创建额外的 VG ，用于管理 PV和 LV的使用。否则，可在需要时扩展现有 VG 以容纳新的 LV。</p><p>4、创建逻辑卷</p><p>&nbsp;lvcreate 根据卷组中的可用物理范围创建新的逻辑卷。至少为 lvcreate 使用以下参数：使用 -n 选项设置 LV名称，使用 -L 选项设置 LV 大小（以字节为单位），并确定要在其中创建 LV 的 VG 名称。</p><p><img src="/wp-content/uploads/image/20180730/1532916442904085.png" title="1532916442904085.png" alt="image.png" /></p><p>此命令将在 VG vg-alpha 中创建一个名为 hercules 的 LV ，其大小为 2GB.必须有足够的空闲物理范围来分配 2GB，如有必要会将其取整为 PE 单元大小的倍数。</p><p>有多种方式可以指定大小： -L 要求以字节或更大指定值为单位的大小。例如 M,G。-l 选项要求以物理范围数为单位进行衡量的大小。</p><p>lvcreate -L 128M,将逻辑卷的大小确定为正好 128 MiB</p><p>lvcreate -l 128,将逻辑卷的大小确定为正好128个范围（PE）的大小，大小取决于 PE 块的大小。</p><p>TIPS :</p><p>不同的工具将使用传统名称 /dev/vgname/lvname 或内核设备映射程序名。 /dev/mapper/vgname-lvname 。显示逻辑卷名。</p><p>5、添加文件系统</p><p>使用 mkfs 在新逻辑卷上创建文件系统（xfs,ext4）</p><p><img src="/wp-content/uploads/image/20180730/1532917059786660.png" title="1532917059786660.png" alt="image.png" /></p><p><span style="font-size: 18px">删除逻辑卷</span></p><p>删除所有逻辑卷组件需要四个步骤：</p><p>1、准备文件系统</p><p>将必须保留的所有数据移动到另一个文件系统，然后使用 umount 卸载该文件系统。不要忘记删除与此文件系统关联的任何/etc/fstab 条目</p><p><img src="/wp-content/uploads/image/20180730/1532923101657518.png" title="1532923101657518.png" alt="image.png" /></p><p><span style="font-size: 20px">tips:</span><br /></p><p>删除逻辑卷会破坏该逻辑卷上存储的所有数据。删除逻辑卷之前，请备份或移动数据&nbsp;</p><p>2、删除逻辑卷</p><p>使用 lvremove 删除不再使用的逻辑卷。使用设备名称作为参数。</p><p><img src="/wp-content/uploads/image/20180730/1532923218881106.png" title="1532923218881106.png" alt="image.png" /></p><p>运行此命令之前，必须卸载 LV 文件系统。删除 LV 之前，将请求确认</p><p>LV 的物理范围将会被释放，并可用于分配给卷组中的现在 LV 或新 LV。</p><p>3、删除卷组</p><p>使用 vgremove 删除不再需要的卷组。使用 VG 名称作为参数。</p><p><img src="/wp-content/uploads/image/20180730/1532923227946554.png" title="1532923227946554.png" alt="image.png" /></p><p>VG 的物理卷组会被释放，并可用于分配给系统中的现在 VG 或新 VG</p><p>4、删除物理卷</p><p>使用 pvremove 删除不再需要的物理卷。使用空格分隔的 PV 设备列表同时删除多个 PV 。PV 元数据将从分区（或磁盘）清除，分区现在已空闲，可重新分配或重新格式化。</p><p><img src="/wp-content/uploads/image/20180730/1532923483491728.png" title="1532923483491728.png" alt="image.png" /></p><p><span style="font-size: 18px">查看 LVM 状态信息</span></p><p>使用 pvdisplay 显示有关物理卷的信息。如果未随命令指定任何参数，则它将列出有关系统上所有 PV 的信息。如果参数为特定设备名称，则将仅显示特定 PV 的信息。</p><p><img src="/wp-content/uploads/image/20180730/1532923530769371.png" title="1532923530769371.png" alt="image.png" /></p><ol class="custom_num list-paddingleft-1"><li class="list-num-1-1 list-num-paddingleft-1"><p>PV Name 映射到设备名称</p></li><li class="list-num-1-2 list-num-paddingleft-1"><p>VG Name 显示将 PV 分配到的卷组。</p></li><li class="list-num-1-3 list-num-paddingleft-1"><p>PV Size 显示 PV 的物理大小，包括任何不可用的空间。</p></li><li class="list-num-1-4 list-num-paddingleft-1"><p>PE Size 是物理范围大小，它是逻辑卷中可分配的最小大小。</p></li><ol class="custom_num1 list-paddingleft-2"><li class="list-num-2-1 list-num1-paddingleft-1"><p>它也是计算以 PE 单位报告的任何值（如 Free PE）的大小时的倍数，例如：26个 PE x 4MiB（PE Size）可提供104 MiB 可用空间。逻辑卷大小将取整为 PE 单位的倍数。<br /></p></li></ol><li class="list-num-1-5 list-num-paddingleft-1"><p>Free PE 显示有多少 PE 单位可用于分配给新逻辑卷。</p></li></ol><p><span style="font-size: 16px">卷组</span></p><p>&nbsp;使用 vgdisplay 显示有关卷组的信息。如果没有为命令指定任何变量，则它将显示有关所有 VG 的信息， 使用 VG 名称作为变量将仅显示该特定 VG 的信息。</p><p><img src="/wp-content/uploads/image/20180730/1532923545926922.png" title="1532923545926922.png" alt="image.png" /></p><ol class="custom_num list-paddingleft-1"><li class="list-num-1-1 list-num-paddingleft-1"><p>VG Name 是此卷组的名称</p></li><li class="list-num-1-2 list-num-paddingleft-1"><p>VG Size 是存储池可用于逻辑卷分配的总大小。</p></li><li class="list-num-1-3 list-num-paddingleft-1"><p>Total PE 是以 PE 单位表示的总大小</p></li><li class="list-num-1-4 list-num-paddingleft-1"><p>Free PE /Size 显示 VG 中有多少空闲空间可用于分配给新 LV 或扩展现在 LV。</p></li></ol><p><span style="font-size: 16px">逻辑卷</span></p><p>&nbsp;使用 lvdisplay 显示有关逻辑卷的信息。同样，如果未随命令指定任何参数，则将显示有关所有 LV 的信息； 而使用 LV 设备名称任何参数将仅显示有关该特定设备的信息。</p><p><img src="/wp-content/uploads/image/20180730/1532923602504982.png" title="1532923602504982.png" alt="image.png" /></p><ol class="custom_num list-paddingleft-1"><li class="list-num-1-1 list-num-paddingleft-1"><p>LV Patch 显示此逻辑卷的设备名称；某些工具可能会将设备名报告为/dev/mapper/vgname-lvname; 两个名称都表示同一 LV&nbsp;</p></li><li class="list-num-1-2 list-num-paddingleft-1"><p>VG Name 显示从其分配 LV的卷组。</p></li><li class="list-num-1-3 list-num-paddingleft-1"><p>LV Size 显示 LV的总大小。使用文件系统工具检查可用空间和数据存储的已用空间。</p></li><li class="list-num-1-4 list-num-paddingleft-1"><p>Current LE 显示此 LV 使用的逻辑范围数。 LE 通常映射到 VG 中的物理范围，并因此映射到物理卷。</p></li></ol><p><br /></p><p><span style="font-size: 18px">扩展逻辑卷</span><br /></p><p><span style="font-size: 16px">扩展和缩减卷组</span></p><p>可以通过添加额外的物理卷来为卷组增加更多磁盘空间。这种做法称为扩展卷组。由额外的物理卷提供的新物理区段可以分配给逻辑卷。</p><p>可以将未使用的物理卷从卷组中删除。这种做法称为缩减卷组。可以使用名为 pvmove 的工具，将数据从一个物理卷上的区段移动到卷组中其他物理卷上的区段。通过这种方式，可以将新磁盘添加到现在卷组，将数据从较旧或较慢的磁盘移动到新磁盘，并将旧磁盘从卷组中删除。可在卷组中的逻辑卷正在使用时完成这些操作。</p><p><span style="font-size: 18px">扩展卷组可能需要四个步骤：</span></p><p>1、准备物理设备</p><p><img src="/wp-content/uploads/image/20180730/1532934683798263.png" title="1532934683798263.png" alt="image.png" /></p><p>2、创建物理卷</p><p><img src="/wp-content/uploads/image/20180730/1532934694227911.png" title="1532934694227911.png" alt="image.png" /></p><p>3、扩展卷组</p><p>vgextend 用于向卷组添加新物理卷。使用 VG 名称和 PV 设备名称作为 vgextend 的参数。</p><p><img src="/wp-content/uploads/image/20180730/1532934705170371.png" title="1532934705170371.png" alt="image.png" /></p><p>4、验证新空间是否可用</p><p><img src="/wp-content/uploads/image/20180730/1532934716787931.png" title="1532934716787931.png" alt="image.png" /></p><p><span style="font-size: 18px">缩减卷组需要两个步骤：</span></p><p>1、移动物理区段</p><p>使用 pvmove将物理卷上使用的任何物理区段重新分配给 VG 中的其他 PV。仅当 VG 中存在足够的空间范围，且所有这些范围都来自其他 PV 时，才能执行此操作。使用将移动的 PE 所属的 PV 设备名称作为该命令的参数。</p><p><img src="/wp-content/uploads/image/20180730/1532934896111896.png" title="1532934896111896.png" alt="image.png" /></p><p><span style="font-size: 24px">警告：</span><br /></p><p>使用 pvmove 前建议备份卷组所有逻辑卷上存储的数据。如果操作期间意外断电，可能会导致卷组状态不一致。这可能导致卷组中逻辑卷上的数据丢失。</p><p>2、缩减卷组</p><p>使用 vgreduce 将物理卷从卷组中删除。使用VG 名称和 PV 设备名称作为该命令参数。</p><p><img src="/wp-content/uploads/image/20180730/1532935348576038.png" title="1532935348576038.png" alt="image.png" /></p><p>/dev/vdb2 PV 现在已从 vg-alpha VG 删除，并可以添加到其他 VG 。或者 ，也可以使用 pvremove 永久停止将设备用作 PV。</p><p><span style="font-size: 18px">扩展逻辑卷和 XFS 文件系统</span></p><p>逻辑卷是一个优势在于能够在不停机的情况下增加其大小。可将卷组中的空闲物理区段添加到逻辑卷以扩展其容量，然后可使用逻辑卷扩展所包含的文件系统。</p><p><span style="font-size: 18px">扩展逻辑卷需要三个步骤：</span><br /></p><p>1、验证卷组是否具有可用的空间</p><p>&nbsp;使用 vgdisplay 验证是否有足够的物理区段供使用。</p><p><img src="/wp-content/uploads/image/20180730/1532935692930444.png" title="1532935692930444.png" alt="image.png" /></p><p>检查输入中的 Free PE /Size ，它应该报告一个等于或大于所需额外空间的值 。如果没有足够的可用空间，则卷组扩展幅度至少要达到所需空间的大小。</p><p>2、扩展逻辑卷</p><p>&nbsp;lvextend 可将逻辑卷扩展为新的大小。添加 LV设备名称作为命令的最后一个参数。</p><p><img src="/wp-content/uploads/image/20180730/1532935843642498.png" title="1532935843642498.png" alt="image.png" /></p><p>此命令可将逻辑卷 hercules 的大小增加 300 M 。请注意空间大小前面的”+“，它表示 向现有大小增加此值；如无该符号，该值定义 LV 的最终确切大小。<br /></p><p>与 lvcreate 类似，有多种方式可以指定大小：-l 通常要求物理区段值，而 -L 要求以字节或更大的单位表示 。</p><p>lvextend -l 128 ：将逻辑卷的大小调整为正好 128 个范围</p><p><span style="font-size: 14px">lvextend -l +128：向逻辑卷的当前大小添加128 个范围</span></p><p><span style="font-size: 14px">lvextend -L 128M：将逻辑卷的大小调整为正好128M</span></p><p><span style="font-size: 14px">lvextend -L +128M：向逻辑卷的当前大小增加128M</span></p><p><span style="font-size: 14px">lvextend -l +50%FREEE：向 LV 添加 VG 中当前可以空间的 50%</span></p><p><span style="font-size: 14px">3、扩展文件系统</span></p><p><span style="font-size: 14px;color: #FF0000">xfs_growfs</span><span style="font-size: 14px"> /mountpoint 扩展文件系统以占用已扩展的 LV。 xfs_growfs 要求在文件系统运行时进行搭载该系统；在调整大小操作期间仍然可以使用该文件系统。</span></p><p><span style="font-size: 14px"><img src="/wp-content/uploads/image/20180730/1532936322407591.png" title="1532936322407591.png" alt="image.png" /></span></p><p><span style="font-size: 24px">注意：</span></p><p>常见错误是运行 lvextend 但忘记运行 xfs_growfs&nbsp; 。两步合二为一的方法是 lvextend 使用 -r 作为命令的一个选项，这将使用 fsadm（8） 在扩展 LV后调整文件系统的大小。它可以用于多种不同的文件系统。</p><p>验证已挂载文件系统的新大小：</p><pre class="brush:bash;toolbar:false">df&nbsp;-h&nbsp;/mountpoint</pre><p><span style="font-size: 18px">扩展逻辑卷和ext 4文件系统</span><br /></p><p>扩展基于ext4 的逻辑卷的步骤基本和扩展基于 xfs的 LV 相同，只有调整文件系统大小的步骤不同</p><p>1、验证卷组的可用性</p><p>2、扩展逻辑卷</p><p>3、扩展文件系统</p><p>resize2fs /dev/vgname/lvname 扩展文件系统以占用新扩展的 LV。正与 xfs_growfs 一样，可以在文件系统正在运行时挂载该文件系统（可选）包含 -p 选项以查看调整大小操作的进度。</p><p><img src="/wp-content/uploads/image/20180731/1533021882431708.png" title="1533021882431708.png" alt="image.png" /></p><p><span style="font-size: 24px">注意：</span></p><p>xfs_growfs 与 resize2fs 之间的主要区别是为识别文件系统而传递的参数。</p><p>xfs_growfs 采用挂载点，而resize2fs&nbsp; 采用逻辑卷名称。</p><p><span style="font-size: 24px">总结：</span></p><p>管理逻辑卷</p><ul class=" list-paddingleft-2" style="list-style-type: disc"><li><p>pvcreate、pvremove和pvdisplay 创建、删除和列出物理卷（PV）</p></li><li><p>vgcreate、vgremove和vgdisplay 创建、删除和列出卷组（VG）</p></li><li><p>lvcreate、lvremove和lvdisplay 创建、删除和列出逻辑卷（LV）</p></li><li><p>添加逻辑卷以 PV、VG、和 LV的先后顺序完成。</p></li><li><p>删除逻辑卷以 LV、VG、和 PV 的先后顺序完成。</p></li></ul><p>扩展逻辑卷</p><ul class=" list-paddingleft-2" style="list-style-type: disc"><li><p>使用 pvcreate 和 vgextend 扩展卷组（VG）；使用vgdisplay 检查结果。</p></li><li><p>使用pvmove 和 vgreduce 缩减 VG 。</p></li><li><p>使用xfs_growfs 调整xfs 文件系统的大小。</p></li><li><p>使用 resize2fs 调整ext4 文件系统的大小。</p></li></ul>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>415</wp:post_id>
		<wp:post_date><![CDATA[2018-07-31 17:42:47]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-07-31 09:42:47]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[rh134-%e7%ae%a1%e7%90%86%e9%80%bb%e8%be%91%e5%8d%b7%e7%ae%a1%e7%90%86lvm%e5%ad%98%e5%82%a8]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="rhel134"><![CDATA[RHEL134]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_page_template]]></wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[hestia_layout_select]]></wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_old_date]]></wp:meta_key>
			<wp:meta_value><![CDATA[2018-07-30]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>RH134 第十一章 访问具有网络文件系统（NFS）的网络存储</title>
		<link>https://www.rhel.tk/2018/09/10/rh134-%e7%ac%ac%e5%8d%81%e4%b8%80%e7%ab%a0-%e8%ae%bf%e9%97%ae%e5%85%b7%e6%9c%89%e7%bd%91%e7%bb%9c%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f%ef%bc%88nfs%ef%bc%89%e7%9a%84%e7%bd%91%e7%bb%9c%e5%ad%98%e5%82%a8/</link>
		<pubDate>Mon, 10 Sep 2018 09:47:03 +0000</pubDate>
		<dc:creator><![CDATA[blogs]]></dc:creator>
		<guid isPermaLink="false">https://www.rhel.tk/?p=437</guid>
		<description></description>
		<content:encoded><![CDATA[<h6>手动挂载和卸载 NFS 共享</h6><p>NFS （网络文件系统）是由Linux 、UNIX 及类似操作系统用作本地文件系统的一种互联网标准协议。它是一种活动扩展之下的开放标准，可支持本地 Linux 权限和文件系统功能。</p><p>RHEL 7 在默认情况下支持NFSv4 （版本4）,向下兼容v3及v2版本。NFSv4使用 TCP 协议与服务器进行通信，而较早版本的NFS则可能使用 TCP 或UDP 。</p><p>NFS 服务器导出共享（目录）,而NFS 客户端将导出的共享挂载到本地挂载点（目录）.本地挂载点必须已存在。可以通过多种方式挂载NFS 共享</p><ul class=" list-paddingleft-2" style="list-style-type: disc"><li><p>使用mount 命令手动挂载 NFS 共享。</p></li><li><p>使用/etc/fstab 在启动时自动挂载 NFS共享。</p></li><li><p>通过称为自动挂载的过程要挂需要挂载 NFS 共享。</p></li></ul><h6>保护 NFS 共享的文件访问权限</h6><p>NFS 服务器通过多种方法保护文件的访问权限：none ,sys,krb5,krb5i和 krb5p .NFS 服务器可以选择为每个导出的共享提供一种方式或多种广场。NFS 客户端必须使用为已导出共享规定的方法之一连接到该共享，该方法以挂载选项 sec=method 的形式指定。</p><p>安全性方法：<br /></p><p>none:可对文件进行匿名访问，对服务器的写入（如允许）将分配 UID,GID为nfsnobody&nbsp;</p><p>sys:文件访问权限基于UID和GID的值的标准Linux 文件权限。如果未指定，则此方法是默认值</p><p>krb5:客户端必须使用Kerberos 证明身份，然后适用标准Linux 的文件权限&nbsp;</p><p>krb5i:添加加密性强的保证，确保每个请求中的数据未被篡改。</p><p>krb5p:为客户端与服务器之间的所有请求添加加密，防止网络中的数据泄露。这会对性能产生影响。</p><h6>TIPS：</h6><p>Kerberos 选项将至少需要 /etc/krb5,keytab和本节中未论述的其它身份验证配置（加入kerberos域）。/etc/krb5.keytab 通常将由身份验证或安全性管理员提供。请求包含主体和 / 或 nfs 主体（最好包含两者）的keytab</p><p>连接到Kerberos 保护的共享时，NFS 使用 nfs-secure 服务来帮助协商和管理与服务器之间的通信。此服务必须正在运行，才能使用受保护的NFS共享；对其使用 start 和 enable 命令以确保其始终可用。</p><pre class="brush:bash;toolbar:false">yum&nbsp;install&nbsp;-y&nbsp;nfs-secure
systemctl&nbsp;enable&nbsp;nfs-secure
systemctl&nbsp;start&nbsp;nfs-secure</pre><h6>&nbsp;挂载 NFS 共享有三个基本步骤：</h6><p>1、识别 NFS 服务器的管理员可能提供导出详细信息，包括安全性要求。或者 NFSv4 共享可通过挂载NFS 服务器的根文件并浏览已导出目录来识别。以root 用户身份执行此操作。使用 Kerberos 安全对共享的访问将被拒绝，但共享（目录）名称将可见。可以浏览其它共享目录。</p><pre class="brush:bash;toolbar:false">mkdir&nbsp;/mountpoint
mount&nbsp;/serverX:/&nbsp;/mountpoint&nbsp;
ls&nbsp;/mountpoint</pre><p>可以使用 showmount 发现 NFSv2和 NFSv3共享</p><pre class="brush:bash;toolbar:false">showmount&nbsp;-e&nbsp;serverX</pre><p>2、挂载点：使用mkdir&nbsp; 在合适的地方创建挂载点</p><pre class="brush:bash;toolbar:false">mkdir&nbsp;-p&nbsp;/mountpoint</pre><p>3、挂载：这里有两种选择，手动挂载，或并入 /etc/fstab 文件中，为任一操作切换到root 或使用sudo</p><ul class=" list-paddingleft-2" style="list-style-type: disc"><li><p>手动使用 mount 命令</p></li></ul><pre class="brush:bash;toolbar:false">mount&nbsp;-t&nbsp;nfs&nbsp;-o&nbsp;sync&nbsp;serverX:/share&nbsp;/mountpoint</pre><p>-t nfs 选择是 NFS 共享的文件系统类型（未严格要求）。-o sync 选择使用 mount 立即与 NFS 服务器同步写操作（默认为异步）。默认安全性方法（sec=sys）将用于尝试挂载NFS 共享，使用标准 Linux 文件权限。<br /></p><ul class=" list-paddingleft-2" style="list-style-type: disc"><li><p>/etc/fstab 使用vim 编辑 /etc/fstab 文件，将挂载条目添加到文件底部。 NFS 共享将在每次系统启动时挂载。</p></li></ul><pre class="brush:bash;toolbar:false">vim&nbsp;/etc/fstab&nbsp;
……
serverX:/share&nbsp;/mountpoint&nbsp;nfs&nbsp;sync&nbsp;0&nbsp;0</pre><p>root 用户使用 umount&nbsp; 命令手动卸载共享<br /></p><pre class="brush:bash;toolbar:false">umount&nbsp;/mountpoint</pre><h6>通过 NFS 自动挂载网络存储</h6><p>自动挂载器是一种服务(autofs) ，它可以根据需要自动挂载 NFS 共享，并将在不再使用 NFS共享时自动卸载这些共享。</p><p>自动挂载器优势</p><ul class=" list-paddingleft-2" style="list-style-type: disc"><li><p>用户无需具有root 特权就可以运行 mount /umount 命令</p></li><li><p>自动挂载器中配置的 NFS 共享可供计算机上的所有用户使用，受访问权限约束</p></li><li><p>&nbsp;NFS 共享不像 /etc/fstab 中的条目一样永久连接，从而可释放网络和系统资源。</p></li><li><p>自动挂载器完全在客户端配置，无需进行任何服务器配置</p></li><li><p>自动挂载器与 mount 命令使用相同的挂载选项，包括安全性选项。</p></li><li><p>支持直接和间接挂载点映射，在挂载点位置方面提供了灵活性。</p></li><li><p>间接挂载点可通过 autofs 创建和删除，从而减少了手动管理这些挂载点的需求。</p></li><li><p>NFS 是自动挂载器的默认文件系统，但自动挂载器也可以用于自动挂载多种不同的文件系统 。</p></li><li><p>autofs 是管理方式类似于其他系统服务的一种服务。</p></li></ul><h6>创建自动挂载</h6><p>配置自动挂载的过程包括多个步骤：</p><p>1、安装 autofs&nbsp;</p><pre class="brush:bash;toolbar:false">sudo&nbsp;yum&nbsp;-y&nbsp;install&nbsp;autofs</pre><p>此软件包含使用自动挂载器挂载NFS 共享所需要的所有内容</p><p>2、向/etc/auto.master.d 添加一个主映射文件；<span style="background-color: #FF0000">此文件确定用于挂载点的基础目录，并确定用于创建自动挂载的映射文件</span>。</p><p>使用vim 创建并编辑主映射文件：</p><pre class="brush:bash;toolbar:false">sudo&nbsp;vim&nbsp;/etc/auto.master.d/demo.autofs</pre><p>主映射文件的名称不重要，但它通常是一个有意义的名称，唯一的要求就是扩展名必须为.autofs ，主映射文件可以保存多个映射条目，或者使用多个文件来将配置数据分开。</p><p>在此例中，为间接映射的挂载添加主映射条目：</p><pre class="brush:bash;toolbar:false">/shares&nbsp;/etc/auto.demo</pre><p>此条目将使用 /shares目录作为将来间接自动挂载的基础目录。/etc/auto.demo 文件包含挂载详细信息；使用绝对文件名，需要在启动autofs 服务之前 创建auto.demo 文件</p><p>要使用直接映射 的挂载点，请向同一文件（或在单独的文件中）添加条目：</p><pre class="brush:bash;toolbar:false">/-&nbsp;/etc/auto.direct</pre><p><span style="background-color: #FF0000">所有直接映射条目都使用 “/-”</span>作为基础目录。在此例中，包含挂载详细信息的映射的文件是/etc/auto.direct&nbsp;</p><p>3、创建映射文件，映射文件确定挂载点、挂载选项和挂载的源位置</p><p>使用vim 创建并编辑映射文件</p><pre class="brush:bash;toolbar:false">&nbsp;sudo&nbsp;vim&nbsp;/etc/auto.demo</pre><p>文件名不重要，按照惯例，该文件位于 /etc 中并且名为 auto.name ，其中 name 是对所有包含内容有意义的名称</p><pre class="brush:bash;toolbar:false">work&nbsp;-rw,sync&nbsp;serverX:/shares/work</pre><p>条目的格式为挂载点、挂载选项和源位置。此示例显示基本的<span style="background-color: #FF0000">间接映射条目</span>。</p><ul class=" list-paddingleft-2" style="list-style-type: disc"><li><p>挂载点在 man page 中被称为 &quot;密钥&quot; ,它将由 autofs 服务自动创建和删除。在此例中完全限制挂载点将是 /shares/work; autofs 将根据需要创建和删除/shares 目录和 work 目录</p></li><li><p>挂载选项以 “-”开关，并使用逗号分隔，不带空格。可以选项与手动挂载选项相同。几个常用的自动挂载器特定选项 -fstype= 和 -strict&nbsp; 文件文件系统 不是NFS 则使用fstype ，可指定文件系统 ；挂载文件系统时，使用strict 可将错误视为严重。</p></li><li><p>NFS 共享的源位置遵循 host:/pathname 模式；在此示例中为 serverX:/shares/work ，此目录需要已在 serverX 上导出，并带有读/写访问权限和标准的linux 文件权限的支持，这样才能挂载成功。如果要挂载的文件系统以 “/”开关，例如本地设备条目或者SMB 共享，则需要添加一个“：”作为前缀，例如 SMB 共享为 ：//serverX/share。</p></li></ul><p>4、启动并启用自动挂载服务</p><pre class="brush:bash;toolbar:false">sudo&nbsp;systemctl&nbsp;enable&nbsp;autofs
sudo&nbsp;systemctl&nbsp;start&nbsp;autofs</pre><h5><span style="font-size: 18px">映射文件 - <span style="font-size: 18px;background-color: #FF0000">直接映射</span></span></h5><p>直接映射用于将NFS 共享映射到现在的挂载点。自动挂载器不会尝试自动创建挂载点；在 autofs 服务启动之前 挂载点必须存在</p><p>继续前面的示例，/etc/auto.direct 文件的内容可能 类似下文：</p><pre class="brush:bash;toolbar:false">/mnt/docs&nbsp;-rw,sync&nbsp;serverX:/shares/docs</pre><p>挂载点（或密钥）始终为绝对路径，以 &quot;/&quot; 开关。映射文件其余部分使用相同的结构。</p><p>只有最右侧的目录受自动挂载程序控制，因此挂载点挂载点（此示例中为 /mnt ）以上的目录结构不会被 autofs 遮盖。</p><h5><span style="font-size: 18px">映射文件 -- <span style="font-size: 18px;background-color: #FF0000">间接通配符映射</span></span></h5><p>当 NFS 服务器导出一个目录中的多个子目录时，可将自动挂载程序配置为使用单个映射条目访问这些子目录其中的任何一个，作为示例，对于从NFS 服务器自动挂载用户主目录，此功能非常有用。</p><p>继续前面的示例，如果 serverX:/share 导出两个或多个子目录,并且能使用相同的挂载选项访问这些子目录，则/etc/auto.demo 文件内容可能类似于正文：</p><pre class="brush:bash;toolbar:false">*&nbsp;-rw,sync&nbsp;serverX:/shares/&amp;</pre><p>挂载点是“*”，而源位置上的子目录是 &quot;&amp;&quot; 。条目中的所有其它内容都相同</p><p>当用户尝试访问/shares/work 时，挂载点 “*”（此示例中为work）将代替源位置中的 &amp; 符号，并将挂载 serverX:/shares/work。对于间接示例，autofs 服务将自动创建和删除work 目录。</p><p><br /></p><p><br /></p><h6>实验：</h6><p>间接通配符映射</p><pre class="brush:bash;toolbar:false">sudo&nbsp;-y&nbsp;install&nbsp;autofs
vim&nbsp;/etc/auto.master.d/home.autofs&nbsp;&nbsp;&nbsp;#主配置文件
###
/home/guests&nbsp;/etc/auto.home
###
vim&nbsp;/etc/auto.home&nbsp;&nbsp;&nbsp;&nbsp;#详细信息
###
*&nbsp;-rw,sync&nbsp;classroom:/home/guests/&amp;
###
systemctl&nbsp;enable&nbsp;autofs
systemctl&nbsp;start&nbsp;autofs</pre><p>间接映射&nbsp;</p><pre class="brush:bash;toolbar:false">sudo&nbsp;-y&nbsp;install&nbsp;autofs
vim&nbsp;/etc/auto.master.d/public.autofs&nbsp;&nbsp;&nbsp;#主配置文件
###
/shares&nbsp;/etc/auto.public
###
vim&nbsp;/etc/auto.public&nbsp;&nbsp;&nbsp;&nbsp;#详细信息
###
public&nbsp;-rw,sync&nbsp;classroom:/shares/public
###
systemctl&nbsp;enable&nbsp;autofs
systemctl&nbsp;start&nbsp;autofs</pre><p>直接映射（需要提前创建挂载点）</p><pre class="brush:bash;toolbar:false">sudo&nbsp;-y&nbsp;install&nbsp;autofs
vim&nbsp;/etc/auto.master.d/public.autofs&nbsp;&nbsp;&nbsp;#主配置文件
###
/-&nbsp;/etc/auto.public
###
vim&nbsp;/etc/auto.public&nbsp;&nbsp;&nbsp;&nbsp;#详细信息
###
/mnt/public&nbsp;-rw,sync&nbsp;classroom:/shares/public
###
mkdir&nbsp;/mnt/public&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#创建目录
systemctl&nbsp;enable&nbsp;autofs
systemctl&nbsp;start&nbsp;autofs</pre><p><br /></p>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>437</wp:post_id>
		<wp:post_date><![CDATA[2018-09-10 17:47:03]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-09-10 09:47:03]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[rh134-%e7%ac%ac%e5%8d%81%e4%b8%80%e7%ab%a0-%e8%ae%bf%e9%97%ae%e5%85%b7%e6%9c%89%e7%bd%91%e7%bb%9c%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f%ef%bc%88nfs%ef%bc%89%e7%9a%84%e7%bd%91%e7%bb%9c%e5%ad%98%e5%82%a8]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="rhel134"><![CDATA[RHEL134]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_page_template]]></wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>RH134 第十二章 访问具有SMB的网络存储</title>
		<link>https://www.rhel.tk/2018/10/11/rh134-%e7%ac%ac%e5%8d%81%e4%ba%8c%e7%ab%a0-%e8%ae%bf%e9%97%ae%e5%85%b7%e6%9c%89smb%e7%9a%84%e7%bd%91%e7%bb%9c%e5%ad%98%e5%82%a8/</link>
		<pubDate>Thu, 11 Oct 2018 07:12:19 +0000</pubDate>
		<dc:creator><![CDATA[blogs]]></dc:creator>
		<guid isPermaLink="false">https://www.rhel.tk/?p=443</guid>
		<description></description>
		<content:encoded><![CDATA[<p>RHEL 使用 samba 服务提供 windows 客户端可以使用的服务。samba 实施“服务器消息块（SMB）协议”，而 “常用Internet 文件系统”（CIFS）是SMB的一种方言，这两个名称经常互换使用。<br /></p><h6>连接至SMB/CIFS共享</h6><p>红帽桌面和服务器均可连接到由使得SMB协议的任何服务器所提供的共享</p><p>访问SMB 共享的三个基本步骤：</p><p>1、识别要访问的远程共享</p><p>2、确定挂载点（应该将共享挂载到的位置），并创建挂载点的空目录。</p><p>3、挂载网络文件系统（通过适当的命令或配置更改）。</p><p>开始之前，必须先安装一上软件包才能挂载 SMB共享：cifs-utils. mount 命令和autofs 自动挂载程序 均依赖此软件包来挂载 CIFS文件系统。第二个软件包 samba-client 具有一些有用的命令行实用程序（如smbclient），因此也经常值得安装</p><h6>挂载 SMB共享</h6><p>1、识别： SMB服务器主机管理员可提供共享的详细信息，如用户名和密码、共享名称等。另一种方式是使用可浏览共享的客户端，如smbclient&nbsp;</p><pre class="brush:bash;toolbar:false">smbclient&nbsp;-L&nbsp;/serverX</pre><p>-L 选项要求 smbclient 列出 serverX 上可用的共享</p><p>2、挂载点：使用mkdir 在合适位置中创建挂载点。</p><pre class="brush:bash;toolbar:false">mkdir&nbsp;-p&nbsp;/mountpoint</pre><p>3、挂载： 手动挂载，或并入 /etc/fstab 文件中，为任一操作切换到root 或使用sudo&nbsp;</p><h6>手动：使用mount 命令</h6><pre class="brush:bash;toolbar:false">sudo&nbsp;mount&nbsp;-t&nbsp;cifs&nbsp;-o&nbsp;guest&nbsp;//serverX/share&nbsp;/mountpoint</pre><p>-t cifs 选项是 SMB共享的文件系统类型； -o guest 选项指示 mount 以guest 账户身份（无需输入密码）尝试并进行身份验证。</p><p>/etc/fstab ：使用vim 来编辑 /etc/fstab 文件并将挂载条目添加到文件的底部。将在每次启动时挂载 SMB 共享</p><pre class="brush:bash;toolbar:false;">sudo&nbsp;vim&nbsp;/etc/fstab&nbsp;
……
//serverX/share&nbsp;/mountpoint&nbsp;&nbsp;cifs&nbsp;&nbsp;guest&nbsp;&nbsp;0&nbsp;0</pre><p>使用umount 和root 特权，手动卸载共享</p><pre class="brush:bash;toolbar:false">sudo&nbsp;umount&nbsp;/mountpoint</pre><p>对SMB 共享执行身份验证。 SMB 共享可以标记为“no-browsable (不可浏览)”，这意味着 smbclient 等客户端将不会显示它们。但是，如果在挂载操作期间明确指定SMB 共享名称，则仍可以访问这些 SMB 共享。 SMB 服务器通常限制 对特定用户或用户组的访问，如果访问受保护的共享，需向 SMB服务器提供合适的凭证。</p><p>身份验证的一个常用予以反击用户名和密码对。这些对既可添加至mount 命令（或/etc/fstab 条目），也可存储在挂载操作期间被引用的凭据文件中。如果未提供密码，mount 命令将会提示输入密码，但是使用 /etc/fstab 时必须提供密码。可通过 guest 选项来请求来宾访问权限 。</p><h6>示例：</h6><pre class="brush:bash;toolbar:false">sudo&nbsp;mount&nbsp;-t&nbsp;cifs&nbsp;-o&nbsp;guest&nbsp;//serverX/docs&nbsp;/public/docs</pre><p>在 /public/docs 中挂载 SMB共享 //serverX/docs 并尝试以 guest 执行身份验证</p><pre class="brush:bash;toolbar:false">sudo&nbsp;mount&nbsp;-t&nbsp;cifs&nbsp;-o&nbsp;username=watson&nbsp;//serverX/cases&nbsp;/bakerst/cases</pre><p>在 /bakerst/cases 中挂载 SMB 共享 //serverX/cases 并尝试以 watson 执行身份验证。在此示例中，mount 命令将提示输入密码。</p><p>凭据谁的能提供更高的安全性，这是因为密码存储在更为安全的文件中，而/etc/fstab 文件则比较易于检查。</p><pre class="brush:bash;toolbar:false">sudo&nbsp;mount&nbsp;-t&nbsp;cifs&nbsp;-o&nbsp;credentials=/secure/sherlock&nbsp;&nbsp;//serverX/sherlook&nbsp;/home/sherlock/work</pre><p>在/home/sherlock/work中挂载 SMB共享 //serverX/sherlock 并尝试使用存储于/secure/sherlock 中的凭据执行身份验证。</p><p>凭据文件格式为：</p><pre class="brush:bash;toolbar:false">username=username
password=password
domain=domian</pre><p>应将其放置在仅具有 root 访问权限的某个安全位置（如 chmod 600 ）</p><p>在文件操作期间， SMB服务器将根据用于挂载共享的凭据，检查文件的访问权限。客户端将根据从服务器发送来的文件 UID/GID，检查文件的访问权限。这意味着，客户端需要具有与 SMB服务器的文件相同的UID/GID 以及补充组成员资格（如有必要）</p><p>处理本地访问检查和备用身份验证方法的挂载选项有很多，例如多用户（和cifscreds）以及基于Kerberos的选项。</p><h6>使用自动挂载程序挂载 SMB 文件系统<br /></h6><p>要使用 mount 命令，需要具有root 特权以连接到 SMB 共享。或者可将条目添加至/etc/fstab,但是此后与SMB服务器的连接需一直保持活动状态。</p><p>当某一进程试图访问SMB共享上的文件时，可以将自动挂载程序 （或autofs）服务配置为“按需”挂载 SMB 共享。当共享不再使用并处于不活动状态达一段时间以后，自动挂载程序将会挂载该共享。</p><p>使用autofs 在 SMB 共享上设置自动挂载的进程实质与其它自动挂载相同。</p><p>添加一个可识别共享基础目录和关联映射文件的auto.master.d 配置文件</p><p>创建或编辑映射文件。包括 SMB共享的挂载详细信息</p><p>启用并启动 autofs 服务</p><h6>tips :</h6><p>如果尚未安装此服务，则安装 autofs 软件包，与 mount一样，自动挂载也依赖 cifs-utils软件包来挂载 SMB 共享。</p><p>映射文件</p><p>指定文件系统类型需要先使用 -fstype=cifs 选项，然后使用一列以逗号分隔的挂载选项（与mount 相同）服务器 URI 地址以冒号“：”为前缀。</p><h6>示例：</h6><p>以下示例在路径 /bakerst/cases 为 SMB 共享 //serverX/cases 创建一个自动挂载，并根据凭据文件 /secure/sherlock 进行身份验证。</p><p>/etc/auto.master.d/bakerst.autofs</p><pre class="brush:bash;toolbar:false">/bakerst&nbsp;/etc/auto.bakerst</pre><p>/etc/auto.bakerst</p><pre class="brush:bash;toolbar:false">cases&nbsp;-fstype=cifs,credentials=/secure/sherlock&nbsp;://serverX/cases</pre><p>/secure/sherlock 内容（属于root,权限 0600）:</p><pre class="brush:bash;toolbar:false">username=sherlock
password=violin2018
domain=BAKERST</pre><p>autofs 启用并启动</p><pre class="brush:bash;toolbar:false">sudo&nbsp;systemctl&nbsp;enable&nbsp;autofs
sudo&nbsp;systemctl&nbsp;start&nbsp;autofs</pre><hr /><h6>实验</h6><pre class="brush:bash;toolbar:false">sudo&nbsp;yum&nbsp;install&nbsp;cifs-utils&nbsp;autofs&nbsp;-y
sudo&nbsp;vim&nbsp;/etc/auto.master.d/shares.autofs
&nbsp;&nbsp;/share&nbsp;/etc/auto.shares
sudovim&nbsp;/etc/auto.shares
&nbsp;&nbsp;work&nbsp;-fstype=cifs,credentials=/etc/me.cred&nbsp;://server0/student
&nbsp;&nbsp;docs&nbsp;-fstype=cifs,guest&nbsp;://server0/public
&nbsp;&nbsp;cases&nbsp;-fstype=cifs,credentials=/etc/me.cred&nbsp;://server0/student
sudo&nbsp;vim&nbsp;/etc/my.cred
&nbsp;&nbsp;username=student
&nbsp;&nbsp;password=student
&nbsp;&nbsp;domain=MYGROUP
groups&nbsp;&nbsp;&nbsp;&nbsp;#查看当前用户所属组
sudo&nbsp;groupadd&nbsp;bakerst&nbsp;-g&nbsp;10221&nbsp;&nbsp;&nbsp;&nbsp;#创建组
sudo&nbsp;usermod&nbsp;-aG&nbsp;bakerst&nbsp;student&nbsp;&nbsp;&nbsp;&nbsp;#附加组
newgrp&nbsp;bakerst&nbsp;&nbsp;&nbsp;&nbsp;#切换（更新）组</pre><p><br /></p>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>443</wp:post_id>
		<wp:post_date><![CDATA[2018-10-11 15:12:19]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-10-11 07:12:19]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[rh134-%e7%ac%ac%e5%8d%81%e4%ba%8c%e7%ab%a0-%e8%ae%bf%e9%97%ae%e5%85%b7%e6%9c%89smb%e7%9a%84%e7%bd%91%e7%bb%9c%e5%ad%98%e5%82%a8]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="rhel134"><![CDATA[RHEL134]]></category>
		<category domain="post_tag" nicename="samba"><![CDATA[samba]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_page_template]]></wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>autofs 自动挂载</title>
		<link>https://www.rhel.tk/2018/10/12/autofs-%e8%87%aa%e5%8a%a8%e6%8c%82%e8%bd%bd/</link>
		<pubDate>Fri, 12 Oct 2018 13:10:31 +0000</pubDate>
		<dc:creator><![CDATA[blogs]]></dc:creator>
		<guid isPermaLink="false">https://www.rhel.tk/?p=497</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>Autofs</h1><p><span style="font-size: 24px">安装</span><br /></p><pre class="brush:bash;toolbar:false">yum&nbsp;install&nbsp;autofs&nbsp;-y</pre><p><span style="font-size: 20px">配置</span></p><p><span style="font-size: 18px">配置文件默认目录</span><br /></p><pre class="brush:bash;toolbar:false">/etc</pre><p><span style="font-size: 18px">主配置模板</span>auto.master&nbsp;</p><pre class="brush:bash;toolbar:false">/etc/auto.master
#/media&nbsp;/etc/auto.media
#目录/media&nbsp;&nbsp;配置文件/etc/auto.media
/etc/auto.master&nbsp;
/media/misc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/etc/auto.misc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--timeout=5
/media/net&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/etc/auto.net&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--timeout=60
#第一列是基础主目录，第二列是对接的配置文件，第三列是自动超时时间，timeout&nbsp;为可选参数，单位为秒
#最好保证模板文件末尾有一个空行。</pre><p>如果您的系统上不存在基目录，则将创建该目录。将挂载基目录以加载动态加载的媒体，这意味着在启用autofs时将无法访问基目录中的任何内容。但是，此过程是非破坏性的，因此如果您不小心自动挂载到实时目录中，只需更改位置auto.master并重新启动AutoFS即可重新获得原始内容。</p><p>如果您仍想自动挂载到目标非空目录并且希望即使在挂载动态加载目录后也可以使用原始文件，则可以使用autofs将它们挂载到另一个目录（例如/var/autofs/net）和创建软链接。</p><pre class="brush:bash;toolbar:false">#ln&nbsp;-s&nbsp;/var/autofs/net/share_name&nbsp;/media/share_name</pre><p>或者，您可以让autofs将媒体安装到特定文件夹，而不是在公共文件夹中。</p><pre class="brush:bash;toolbar:false">/etc/auto.master
/&nbsp;&nbsp;-&nbsp;&nbsp;/etc/auto.template
#不指定基础目录
/etc/auto.template
/path/to/folder&nbsp;-options:/device/path
/home/user/usbstick&nbsp;-fstype&nbsp;=&nbsp;auto，async，nodev，nosuid，umask&nbsp;=&nbsp;000:/dev/sdb1</pre><p>可移动媒体</p><p>打开/etc/auto.misc以添加，删除或编辑其他设备。例如：</p><pre class="brush:bash;toolbar:false">/etc/auto.misc
#kernel&nbsp;-ro&nbsp;
ftp.kernel.org:/pub/linux&nbsp;#boot&nbsp;-fstype&nbsp;=&nbsp;ext2:/dev/hda1&nbsp;
usbstick&nbsp;-fstype&nbsp;=&nbsp;auto，async，nodev，nosuid，umask&nbsp;=&nbsp;000:/dev/sdb1&nbsp;
cdrom&nbsp;-fstype&nbsp;=&nbsp;iso9660&nbsp;，ro:/dev/cdrom&nbsp;
#floppy&nbsp;-fstype&nbsp;=&nbsp;auto:/dev/fd0</pre><p>如果您有CD / DVD组合驱动器，则可以更改该cdrom行以-fstype=auto自动检测介质类型。</p><p>NFS 检查挂载<br /></p><pre class="brush:bash;toolbar:false">showmount&nbsp;&lt;servername&gt;&nbsp;-e</pre><p>手动NFS配置</p><p>要将名为/srv/shared_dir的server_name上的NFS共享挂载到位于/mnt/foo的另一台名为client_pc的计算机，请编辑nfs.autofs并为该共享创建配置文件（auto.nfsserver_name）：</p><p><br /></p><pre class="brush:bash;toolbar:false">/etc/auto.master.d/auto.nfsserver_name
foo&nbsp;-rw,soft,intr,rsize=8192,wsize=8192&nbsp;server_name/srv/shared_dir</pre><p>samba 的配置方法</p><p>samba 检查方法</p><p>smbclient&nbsp; -L&nbsp; //servername&nbsp;</p><pre class="brush:bash;toolbar:false">/etc/auto.master.d/auto.smb
smb&nbsp;-fstype=cifs,[other_options]&nbsp;&nbsp;&nbsp;://&nbsp;[remote_server]/[remote_share_name]
#[any_name]&nbsp;-fstype=cifs,username=[username],password=[password],[other_options]&nbsp;://[remote_server]/[remote_share_name]</pre><p>ftp</p><p>安装 curlftpfs (未完待续)</p><pre class="brush:bash;toolbar:false">yum&nbsp;install&nbsp;curlftpfs&nbsp;-y
modprobe&nbsp;fuse</pre><p><br /></p><p><br /></p><p><br /></p>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>497</wp:post_id>
		<wp:post_date><![CDATA[2018-10-12 21:10:31]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-10-12 13:10:31]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[autofs-%e8%87%aa%e5%8a%a8%e6%8c%82%e8%bd%bd]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="uncategorized"><![CDATA[未分类]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_page_template]]></wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>RH134 第十三章 对 RED HAT ENTERPRISE LINUX 启动过程进程控制故障排除</title>
		<link>https://www.rhel.tk/2018/10/16/rh134-%e7%ac%ac%e5%8d%81%e4%b8%89%e7%ab%a0-%e5%af%b9-red-hat-enterprise-linux-%e5%90%af%e5%8a%a8%e8%bf%87%e7%a8%8b%e8%bf%9b%e7%a8%8b%e6%8e%a7%e5%88%b6%e6%95%85%e9%9a%9c%e6%8e%92%e9%99%a4/</link>
		<pubDate>Tue, 16 Oct 2018 03:38:24 +0000</pubDate>
		<dc:creator><![CDATA[blogs]]></dc:creator>
		<guid isPermaLink="false">https://www.rhel.tk/?p=505</guid>
		<description></description>
		<content:encoded><![CDATA[<p>REHL 7 启动过程<br /></p><p>1、计算机已接通电源</p><p>2、系统固件搜索可启动设备</p><p>3、系统固件从磁盘读取启动加载器，然后将系统控制权交给启动加载器。在 RHEL 7 中这通常是 grub2。</p><p><span style="font-size: 14px">&nbsp; &nbsp; </span><span style="font-size: 14px">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="font-size: 14px">通过以下方式进行配置 ：grub2-install&nbsp;</span></p><p>4、启动加载器从磁盘加载其配置，然后向用户显示用于启动的可能配置的菜单。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;通过以下方式进行配置：/etc/grub.d/ 、/etc/default/grub 和 （非手动） /boot/grub2/grub.cfg<br /></p><p>5、在用户做出选择（或发生自动超时）后，启动加载器会从磁盘加载配置的内核及initramfs 并将它们置于内存中。initramfs 是经过 gzip 的cpio 归档，其中包含启动时所有必要硬件的内核模块、初始化脚本等。在 RHEL7 中，initramfs 包含自身可用的整个系统。<br /></p><p>&nbsp;&nbsp;&nbsp;&nbsp;通过以下方式进行配置：/etc/dracut.conf<br /></p><p>6、启动加载器将系统控制权交给内核，从而传递启动加载器的内核命令行中指定的任何选项，以及initramfs 在内存中的位置。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;通过以下方式进行配置：/etc/grub.d/、/etc/default/grub 和 (非手动) /boot/grub2/grub.cfg<br /></p><p>7、对于内核可在 initamfs 中找到驱动程序的所有硬件，内核会初始化这些硬件，然后作为 PID 1 从 initramfs 执行 /sbin/init 。在 RHEL 7 中initramfs 包含systemd 的工作副本作为 /sbin/init ，并包含 udev 守护进程</p><p>&nbsp;&nbsp;&nbsp;&nbsp;通过以下方式进行配置 init = 命令行参数<br /></p><p>8、initramfs 中的 systemd 实例会执行 initrd.target 目标的所有单元。这包括在 /sysroot 上挂载实际的 root 文件系统 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;通过以下方式进行配置： /etc/fstab&nbsp;<br /></p><p>9、内核 root 文件系统从initramfs root 文件系统切换（回转）为之前挂载于 /sysroot 上的系统 root 文件系统。随后 ，systemd 会使用系统中安装 systemd 副本来自动重新执行。</p><p>10、systemd 会查找从内核命令传递或系统中配置的默认目标，然后启动（或停止）单元，以符合目标的配置，从而自动解决单元间的依赖关系。本质上，systemd 目标是一组应在激活后达到所需系统状态的单元。这些目标通常至少包含一个生成基于文本的登录或图形登录屏幕。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;通过以下方式进行配置： /etc/systemd/system/default.target 、/etc/systemd/system/<br /></p><h2><span style="font-size: 24px">启动、重新启动和关闭</span><br /></h2><p>要关闭或从命令行重新启动正在运行的系统，管理员可以使用systemcl 命令</p><p>systemctl poweroff 会停止所有运行的服务，卸载所有文件系统（或者在文件系统无法卸载时以只读形式将其重新挂载），然后关闭系统。</p><p>systemctl reboot 会停止所有运行的服务，卸载所有文件系统，然后重新启动系统。</p><p>为了方便身后兼容，poweroff 和 reboot 命令仍然存在，但是在RHEL 7 中，它们是指向 systemctl 工具的的符号链接。</p><h3>tips:</h3><p>systemctl halt 和 halt 也用于停止系统，但与其poweroff 不同，这些命令不会关闭系统而是让系统进入能安全地手动关闭的状态。<br /></p><h3>选择systemd 目标</h3><p>systemd 目标是一组应在启动后到达所需状态的systemd 单元。下表列出了这些目标的最重要的信息。</p><table><tbody><tr class="firstRow"><td valign="top">目标</td><td valign="top">用途</td></tr><tr><td valign="top">graphical.target</td><td valign="top">多用户、图形+文本</td></tr><tr><td valign="top">multi-user.target</td><td valign="top">多用户、文本登录</td></tr><tr><td valign="top">rescue.target</td><td valign="top">sulogin 提示，表示基本系统初始化已完成</td></tr><tr><td valign="top">emergency.target</td><td valign="top">sulogin 提示，表示 initramfs 回转完成，且系统 root 以只读形式挂载于 / 上</td></tr></tbody></table><p>某个目标可能属于另一目标：例如 graphical.target 包含 multi-user.target 。后者反过来取决于 basic.target 和其他目标，使用以下命令可从命令行查看这些依赖关系；<br /></p><pre class="brush:bash;toolbar:false">systemctl&nbsp;list-dependencies&nbsp;graphical.target&nbsp;|&nbsp;grep&nbsp;target&nbsp;&nbsp;&nbsp;&nbsp;#查看依赖关系
systemctl&nbsp;list-units&nbsp;--type=target&nbsp;--all&nbsp;#查看所有可用目标的描述
systemctl&nbsp;list-units-files&nbsp;--type=target&nbsp;--all&nbsp;#查看磁盘上安装的所有目标的概述
systemctl&nbsp;isolate&nbsp;multi-user.target&nbsp;&nbsp;&nbsp;&nbsp;#在运行的系统中，切换到其他目标，类似于老版本&nbsp;init&nbsp;5</pre><p>隔离某个目标会停止该目标（及其依赖项）不需要的所有服务，并启动任何尚未启动的所需服务。</p><h5>注意：</h5><p>并非所有目标都能隔离。只有单元文件中设置了 AllowIsolate=yes 的目标才可以隔离；例如 graphical.target 目标可以隔离，但 cryptsetup.target 目标不能隔离。AllowIsolate 设置在target 文件中配置</p><h6>设置默认目标</h6><p>在系统启动且将控制权从 initramfs 交给systemd 后，systemd 会尝试激活 default.target 目标。通常，default.target 目标是 (/etc/systemd/system中) 指向 graphical.target 或 multi-user.target 的符号链接。</p><p>systemctl 工具随附两个命令（get-default 和 set-default ） 用于管理该符号链接，而不是手动编辑该连接。</p><pre class="brush:bash;toolbar:false">[root@client&nbsp;~]#&nbsp;systemctl&nbsp;get-default
multi-user.target
[root@client&nbsp;~]#&nbsp;systemctl&nbsp;set-default&nbsp;graphical.target
Removed&nbsp;symlink&nbsp;/etc/systemd/system/default.target.
Created&nbsp;symlink&nbsp;from&nbsp;/etc/systemd/system/default.target&nbsp;to&nbsp;/usr/lib/systemd/system/graphical.target.</pre><h6>在启动时选择其他目标<br /></h6><p>要在启动时选择其它目标，可从启动加载器将特殊选项附加到内核命令行：systemd.init= .</p><p>例如，要使系统启动进入救援 shell&nbsp; （在这种情况下，系统可在（几乎）没有任何服务运行的情况下进行配置更改），则在启动前，可从交互式启动加载器菜单中附加以下内容：</p><pre class="brush:bash;toolbar:false">systemd.unit=rescue.target</pre><p>该配置更改仅影响单个启动，这使其成为排除启动过程故障的有用工具。</p><p>要使用这种选择其他目标的方法，请针对 RHEL 7 系统执行以下步骤：</p><p>1、（重新）启动系统&nbsp;</p><p>2、按任意键中断启动加载菜单倒计时。</p><p>3、将光标移动至要启动的条目</p><p>4、按e 编辑当前条目</p><p>5、将光标移动至以 linux16 开关行。此为内核命令行</p><p>6、附加 systemd.unit=desired.target&nbsp;</p><p>7、按 Ctrl +x 使用这些更改进行启动.</p><h2>修复常见启动问题<br /></h2><h3>恢复root 密码<br /></h3><p>每个系统管理员都应该能完成一项任务是恢复丢失的root密码，如果管理员仍处于登录状态，不管是作为拥有完成sudo 访问权限的非特权用户，还是作为root 用户，这个任务都很简单。如果未登录则复杂一点。<br /></p><p>有一些方法可用于设备新的root 密码。例如，系统管理员可以使用live cd 启动系统，从此处挂载root文件系统。然后编辑 /etc/shadow 。在本节中，我们将探讨一个无需使用外部介质的方法。</p><p><span style="background-color: #FFC000">注意：</span></p><p>在RHEL 6及早期版本中，管理员可以启动系统进入runlevel 1 然后看到一个root 提示。在 RHEL7 中与 runlevel 1 最接近的是 rescue.target&nbsp; 和emergency.target 目标，这两个目标都需要 root 密码才能登录 。</p><p>在 RHEL 7中，可以使从 initramfs 运行的脚本在某些点暂停，提供 root shell ，然后在该 shell 存在的情况下继续 。虽然主要是为了进行调试，但也可用户恢复丢失的 root 密码。</p><p>1、重新启动</p><p>2、按任意键中断启动加载器倒计时。</p><p>3、将光标移动到需要启动的条目</p><p>4、按 e 编辑选定的条目</p><p>5、将光标移到内核命令行（以 linux16开头的行）</p><p>6、附加<span style="background-color: #FF0000"> rd.break </span>（就在从initramfs 向实际系统移交控制权前，该操作会中断）。</p><h6><span style="background-color: #FFC000">注意</span>：</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;initramfs 提示会显示在内核命令行中指定为最后的任何控制台中。<br /></p><p>7、Ctrl +x 使用这些更改进行启动</p><h6><span style="background-color: #FFC000">注意</span>：&nbsp; &nbsp;&nbsp;</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;预建的映像可能会在内核中放置多个 console = 参数，以全支持各种各校的实施场景，对于 rd.break ，有一点需要注意的是，尽管许多内核消息将会发送到所有控制台，但提示符最终都将使用最后一个控制台。如果未看到提示符，可能要临时调整 console = 参数的顺序。<br /></p><p>此时，会显示 root shell ，且实际系统的 root 文件系统会在 /sysroot 中以只读方式挂载。</p><h6><span style="background-color: #FFC000">重要</span>：</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;由于此时尚未启动 selinux ，因此任何创建的新文件都不会创建分配有selinux 上下文。请记住，有些工具（如passwd ）首先会创建一个新文件，然后移动新文件以代替要编辑的文件，从而有地创建不 selinux 上下文的新文件。<br /></p><p>此时要恢复 root 密码，请使用以下步骤：</p><p>1、以读写方式重新挂载 /sysroot&nbsp;</p><pre class="brush:bash;toolbar:false">mount&nbsp;-o&nbsp;remount,rw&nbsp;/sysroot</pre><p>2、切换为 chroot 存入位置，其中 /sysroot 被视为文件系统树的 root&nbsp;</p><pre class="brush:bash;toolbar:false">chroot&nbsp;/sysroot</pre><p>3、设置新 root 密码</p><pre class="brush:bash;toolbar:false">passwd&nbsp;root</pre><p>4、确保所有未标记的文件（包括此时的 /etc/shadow）在启动过程中都会重新获得标记。</p><pre class="brush:bash;toolbar:false">touch&nbsp;/.autorelabel</pre><p>5、键入 exit 两次，第一次将退出 chroot 存放位置，第二次将退出 initramfs 调试 shell 。此时系统将继续进行启动，执行完整的 selinux 重新标记，然后再次重新启动。<br /></p><h4>使用 journalctl&nbsp;</h4><p>查看以前（失败）启动日志会很有用。如果 journald 日志已被已久性的，则使用 journaclctl 工具即可查看。</p><p>首先确定启用了永久性的 journald 记录</p><pre class="brush:bash;toolbar:false">mkdir&nbsp;-p&nbsp;-m2775&nbsp;/var/log/journal
chwon&nbsp;:systemd-journal&nbsp;/var/log/journal
killall&nbsp;-USR1&nbsp;systemd-journald</pre><p>要检查上一次启动的日志文件，请在journalctl 中使用 -b 选项。无需任何参数，-b 选项即可将输出过滤为仅包含与该启动有关的消息，但是如果参数为负数，则此选项将过滤出上次启动。例如：</p><pre class="brush:bash;toolbar:false">journalctl&nbsp;-b&nbsp;-l&nbsp;-p&nbsp;err</pre><p>该命令将显示上次启动中被评为错误或更严重级别的所有消息。</p><h5>诊断和修复 systemd 启动问题</h5><p>如果在启动服务过程中出现问题，则有几个工具可供管理员用于协助调试和 / 或故障排除：</p><h6>早期调试 shell&nbsp;</h6><p>通过运行 systemctl enable debug-shell.service 启动序列早期将在 tty9 (Ctrl + Alt +f9 )上生成一个root shell 。该 shell 会自动作为 root 登录 ，这样管理员可以在系统仍在启动时使用一些其他高度工具。</p><h6>tips :<br /></h6><p>在完成调试后，请不要忘记禁用 debug-shell.service 服务，因为该服务会使未经身份验证的 root shell 向任何有本地控制台访问权限的人员开放。</p><h6>紧急情况和救援目标</h6><p>通过从启动器加载将 systemd.unit=rescue.target 或 systemd.unit=emergency.target 附加到内核命令行，系统将生成特殊的救援或紧急情况 shell ，而不是正常启动。这两个 shell 都需要提供 root 密码。 emergency 目标使 root 文件系统以只读方式挂载，而rescue.target 等待sysinit.target 先完成，这样更多的系统会进行初始化 （例如日志记录、文件系统等）。</p><p>这些 shell 可以用于修复妨碍系统正常启动的任何问题；例如，服务之间的依赖关系循环、或 /etc/fstab&nbsp; 中的错误条目。从这些 shell 退出后，系统会继续进行正常启动过程</p><h6>阻塞作业</h6><p>在启动过程中，systemd 会生成大量作业。如果其中某些作业无法完成，则它们会妨碍其他作业运行。要检查当前作业列表，管理员可以使用命令 systemctl list-jobs 。所有列出为 running 的作业都必须先完成，然后列为 waiting 的作业可以继续。</p><h4>修复在启动时出现的文件系统问题</h4><p>/etc/fstab 中的错误和损坏的文件系统可能会阻止系统启动。在大多数情况下，systemd 实际上会在超时后继续启动，或者降至需要提供 root 密码的紧急修复 shell&nbsp;</p><table><tbody><tr class="firstRow"><td width="448" valign="top">问题</td><td width="448" valign="top">结果</td></tr><tr><td width="448" valign="top">损坏文件系统</td><td width="448" valign="top">systemd 将会尝试 fsck ,如果问题太严重而无法自动修复，则系统会提示用户从紧急 shell 手动运行 shell&nbsp;</td></tr><tr><td width="448" valign="top">/etc/fstab 中引用的设备 /UUID 不存在</td><td width="448" valign="top">systemd 将等待一定的时间，等设备变得可用。如果设备未变得可用，则系统会在超时后用户降至紧急 shell 。</td></tr><tr><td width="448" valign="top">/etc/fstab 中的挂载点不存在</td><td width="448" valign="top">systemd 会创建挂载点（如果可能） ; 否则，它会降至紧急 shell&nbsp;</td></tr><tr><td width="448" valign="top">/etc/fstab 中指定的挂载点错误</td><td width="448" valign="top">系统将用户降至紧急 shell&nbsp;</td></tr></tbody></table><p>在所有情况下，管理员都可以使用 emergency.target 目标来诊断和修复问题，因为在显示紧急 shell 之前 ，不会挂载任何文件系统。</p><h6>注意：</h6><p>在文件系统问题中使用自动恢复 shell 时，请不要忘记在编辑 /etc/fstab 后发出 systemctl daemon-reload ，如果不重新加载，systemd 将继续使用旧版本。</p><h6>修复启动加载器问题<br /></h6><p>RHEL 7 中默认使用的启动加载是 grub2, GRand Unified Bootloader 的第二个主要版本</p><p>grub2 可以用来在 BIOS和 UEFI系统中进行启动，并且支持启动现代硬件上运行的几乎所有操作系统。</p><p>grub2 的主要配置文件是 /boot/grub2/grub.cfg ，但是管理员不应直接编辑文件，而是应用使用一组不同的配置文件和安装的内核列表，并借助名为 grub2-mkconfig 的工具生成配置。</p><p>grub2-mkconifg 会查看 /etc/default/grub 的选项（例如要使用的默认菜单超时及内核命令行），然后在 /etc/grub.d/ 中使用一组脚本来生成配置文件。</p><p>要永久更改启动加载器配置，管理员需要编辑前面列出的配置文件，然后运行以下命令：</p><p>grub2-mkconfig &gt; /boot/grub2/grub.cfg</p><p>在进行较大更改的情况下，管理员可能更喜欢不经过重定向即运行该命令，这样可以首先检查结果。</p><h6>重要指令</h6><p>要为损坏的 grub2 配置排除故障，管理员需要先了解 /boot/grub2/grub.cfg 的语法。实际可启动条目是在 menuentry 块中编码的。在这些块中，linux16 和 initrd16 行指向（随内核命令行）从磁盘加载的内核以及要加载的 initramfs 。在启动时进行交互编辑的过程中，Tab 实例可用于查找这些文件。</p><p>这些块中的 set root 行不指向 rhel 7 系统的root 文件系统，而是指向 grub2 应从加载内核及 initramfs 文件的文件系统。语法为 harddrive,partition ，其中 hd0 是系统中的第一个硬盘驱动器，hd1 是第二个硬盘驱动器，依此类推。指定为 msdos1 的分区是该驱动器上的第一个 MBR 分区，指定为 gpt1 分区的第一个GPT分区<br /></p><h6>重新安装启动加载器</h6><p>在启动加载器自身已损坏的情况下，可以使用 grub2-install 命令重新安装。在 BIOS系统中，应提供 MBR 中应安装 grub2 的磁盘作为参数。在 UEFI 系统中，当 EFI 系统分区挂载于 /boot/efi/上时，无需提供任何参数。</p><p><br /></p>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>505</wp:post_id>
		<wp:post_date><![CDATA[2018-10-16 11:38:24]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-10-16 03:38:24]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[rh134-%e7%ac%ac%e5%8d%81%e4%b8%89%e7%ab%a0-%e5%af%b9-red-hat-enterprise-linux-%e5%90%af%e5%8a%a8%e8%bf%87%e7%a8%8b%e8%bf%9b%e7%a8%8b%e6%8e%a7%e5%88%b6%e6%95%85%e9%9a%9c%e6%8e%92%e9%99%a4]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="rhel134"><![CDATA[RHEL134]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_page_template]]></wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_old_date]]></wp:meta_key>
			<wp:meta_value><![CDATA[2018-10-15]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>RH134 第十四章 使用 FIREWALLD 限制网络通信</title>
		<link>https://www.rhel.tk/2018/10/17/rh134-%e7%ac%ac%e5%8d%81%e5%9b%9b%e7%ab%a0-%e4%bd%bf%e7%94%a8-firewalld-%e9%99%90%e5%88%b6%e7%bd%91%e7%bb%9c%e9%80%9a%e4%bf%a1/</link>
		<pubDate>Wed, 17 Oct 2018 10:20:04 +0000</pubDate>
		<dc:creator><![CDATA[blogs]]></dc:creator>
		<guid isPermaLink="false">https://www.rhel.tk/?p=511</guid>
		<description></description>
		<content:encoded><![CDATA[<h5>Netfilter 和 firewalld 概念<br /></h5><p>Linux 内核包含一个强大的网络过滤子系统 netfilter.netfilter 子系统允许内核模块对遍历系统的每个数据进行检查。这表示在任何传入、传出或转发的网络数据包到达用户喷雾健康的组件之前，都可以通过编程方式检查 、修改、丢弃、或拒绝这些数据包。这是在 RHEL 7 计算机上构建防火墙的主要构建块。</p><h5>与 netfilter 交互</h5><p>尽管管理员理论上可以编写自己的内核模块与 netfilter 交互，但通常不会这样做。取而代之会使用其他程序来与 netfilter 交互。这些程序中，最常见和最知名的是iptables 。在先前的 RHEL&nbsp; 版本中， iptables 是与内核 netfilter 子系统交互的主要方法。</p><p>iptables 命令是一个低级工具，使用该工具正常管理防火墙可能具有挑战性。此外，它仅能调整 ipv4 防火墙规则。为保证更完成的防火墙覆盖率，需要使用其他实用程序，例如用于 ipv6 的ip6tables 和用于软件桥的ebtalbes 。</p><h5>firewalld 简介。</h5><p>RHEL 7 中引入了一种与 netfilter 交互的新方法：firewalld , firewalld 是一个可以配置和监控系统防火墙规则的系统守护进程。应用可以通过 DBus 消息系统与 firewalld 通信以请求打开端口，此功能可以禁用或锁定。该守护进程不仅涵盖ipv4、ipv6，还能涵盖 ebtables 设备。 firewalld 守护进程从 firewalld 软件包安装。此软件包属于Base 安装的一部分，但不属于minimal安装的一部分。</p><p>firewalld 将所有网络流量分为多个区域，从而简化防火墙管理。根据数据包源 ip 地址或传入网络接口等条件。流量将转入相应的防火墙规则。每个区域都可以具有自己的要打开和关闭的端口和服务列表。</p><h6>tips:</h6><p>对于笔记本电脑或经常更改网络的其他计算机，可以使用 NetworkManager 自动设备连接防火墙区域。（ZONE=home）可以使用适于特定连接的规则来自定义区域。</p><p>对于传入系统的每个数据包，将首先检查其源地址。如果该原地址关联到特定区域，则将分析该区域的规则。如果该源地址未关联某个区域，则将使用传入网络接口的区域。</p><p>如果出于某种原因，网络接口未与某个区域关联，则将使用默认区域。默认区域本身不是一个单独的区域；它是其他区域中的一个。默认情况下使用 public 区域，但系统管理员可以更改此默认值。</p><p>大多数区域会允许与特定端口和协议（“631/udp”）或预定义服务（&quot;ssh&quot;）的列表匹配的流量通过防火墙。如果流量不与允许的端口/协议或服务匹配，则通常会被拒绝。（trusted区域默认情况下允许所有流量，它是此规则的一个例外）。</p><h6>预定义区域</h6><table><tbody><tr class="firstRow"><th>区域名称<br /></th><th>默认配置</th></tr><tr><td valign="top">trusted</td><td valign="top">允许所有传入流量</td></tr><tr><td valign="top">home</td><td valign="top">除非与传出流量相关，或与 ssh、mdsn、ipp-client、samba-client 或 dhcpv6-client 预定义服务匹配，否则拒绝传入流量</td></tr><tr><td valign="top">internal</td><td valign="top">除非与传出流量相关，或与 ssh、mdsn、ipp-client、samba-client 或 dhcpv6-client 预定义服务匹配，否则拒绝传入流量（一开始与 home 区域相同）</td></tr><tr><td valign="top">work</td><td valign="top">除非与传出流量相关，或与 ssh、ipp-client 或 dhcpv6-client 预定义服务匹配，否则拒绝传入流量</td></tr><tr><td valign="top">public</td><td valign="top">除非与传出流量相关，或与 ssh 或 dhcpv6-client 预定义服务匹配，否则拒绝传入流量，新增加网络接口的默认区域</td></tr><tr><td valign="top">external</td><td valign="top">除非与传出流量相关，或与 ssh 预定义服务匹配，否则拒绝传入流量，通过此区域转发的 ipv4 传出流量将进行伪装，以使其看起来像是来自传出接口的ipv4地址</td></tr><tr><td valign="top">dmz</td><td valign="top">除非与传出流量相关，或与 ssh 预定义服务匹配，否则拒绝传入流量</td></tr><tr><td valign="top">block</td><td valign="top">除非与传出流量相关，否则拒绝传入流量</td></tr><tr><td valign="top">drop</td><td valign="top">除非与传出流量相关，否则拒绝传入流量（甚至不产生包含 ICMP 错误的响应）</td></tr></tbody></table><p>有关所有可用预定义区域及其预期用途的列表，参阅 firewalld.zones(5)手册页。<br /></p><h6>预定义服务<br /></h6><p>firewalld 还随附一些预定义服务，这些服务可用于方便地允许特定网络服务的流量通过防火墙，下表详细说明了防火墙区域默认中使用的预定义的配置。</p><table><tbody><tr class="firstRow"><th>服务名称</th><th>配置</th></tr><tr><td valign="top">ssh</td><td valign="top">本地ssh 服务器。到22/tcp的流量</td></tr><tr><td valign="top">dhcpv6-client</td><td valign="top">本地 DHCPv6客户端，到 fe80::/64 IPv6 网络中 546/udp 的流量</td></tr><tr><td valign="top">ipp-client</td><td valign="top">本地IPP 打印，到 631/udp的流量</td></tr><tr><td valign="top">samba-client</td><td valign="top">本地 windows 文件和打印共享客户端，到137/udp,和138/udp的流量</td></tr><tr><td valign="top">mdns</td><td valign="top">多播DNS(mDNS)本地链路名称解析。到5353/udp 指向 224.0.0.251 (IPv4)或 ff02::fb(IPv6)多播地址的流量</td></tr></tbody></table><h6>tips:</h6><p>还存在许多其他预定义服务。firewall-cmd --get-services 命令可以列出这些服务。可在 /usr/lib/firewalld/services 目录中找到用于定义 firewalld 软件包中所含预定义服务的配置文件，其格式由 firewalld.zone(5)定义。本章中不会进一步讨论这些文件。</p><h5>配置防火墙设置</h5><h6>三种主要方式与 firewalld 交互。</h6><p>1、直接编辑配置文件</p><p>2、使用 firewall-config 图形工具</p><p>3、从命令行使用 firewall-cmd&nbsp;</p><p><br /></p><h6>使用firewall-cmd 配置防火墙设置</h6><p>firewall-cmd 作为主firewalld 软件包的一部分安装。firewall-cmd 可以执行 firewall-config 能够执行的相同操作。</p><p>常用 firewall-cmd 命令及其说明（默认修改运行配置），当指定 --permanent （永久）选项时除外。</p><table><tbody><tr class="firstRow"><th>firewall-cmd 命令<br /></th><th>说明</th></tr><tr><td valign="top">--get-default-zone</td><td valign="top">查询当前默认区域</td></tr><tr><td valign="top">--set-default-zone=&lt;ZONE&gt;</td><td valign="top">设置当前默认区域</td></tr><tr><td valign="top">--get-zones</td><td valign="top">列出所有可用区域</td></tr><tr><td valign="top">--get-active-zones</td><td valign="top">列出当前正在使用的所有区域（具有关联的端口或者源）及其接口信息</td></tr><tr><td valign="top"><p>--add-source=&lt;CIDR&gt;[--zone=&lt;ZONE&gt;]</p></td><td valign="top">将来自 IP 地址或网络 /子网掩码 &lt;CIDR&gt; 的所有流量路由到指定区域，如果未提供 --zone= 选项，则将使用默认区域。</td></tr><tr><td valign="top">--remove-source=&lt;CIDR&gt;</td><td valign="top">从指定区域中删除用于路由来自 ip 地址或 网络/子掩码&lt;CIDR&gt;的所有流量的规则 。如果未提供 --zone= 选项，则将使用默认区域。</td></tr><tr><td valign="top">--add-interface=&lt;INTERFACE&gt;</td><td valign="top">将来自&lt;INTERFACE&gt;网卡的所有流量路由到指定区域。如果未提供 --zone=选项，则将使用默认区域。</td></tr><tr><td valign="top" colspan="1" rowspan="1">--change-interface=&lt;INTERFACE&gt;</td><td valign="top" colspan="1" rowspan="1">将接口与 &lt;ZONE&gt;而非其当前区域关联。如果未提供 --zone 选项，则将使用默认区域</td></tr><tr><td valign="top" colspan="1" rowspan="1">--list-all</td><td valign="top" colspan="1" rowspan="1">列出&lt;ZONE&gt;的所有已经配置接口、源、服务和端口。如果未提供 --zone 选项，则将使用默认区域</td></tr><tr><td valign="top" colspan="1" rowspan="1">--list-all-zoness<br /></td><td valign="top" colspan="1" rowspan="1">检索所有区域的所有信息。（接口、源、服务、端口）</td></tr><tr><td valign="top" colspan="1" rowspan="1"><p>--add-service=&lt;SERVICE&gt;</p></td><td valign="top" colspan="1" rowspan="1">允许到&lt;SERVICE&gt;的流量。如果未提供--zone 选项。则将使用默认区域</td></tr><tr><td valign="top">--add-port=&lt;PORT/PROTOCOL&gt;</td><td valign="top">允许到&lt;PORT/PROTOCOL&gt;端口的流量。如果未提供 --zone 则将使用默认区域</td></tr><tr><td valign="top" colspan="1" rowspan="1">--remove-service=&lt;SERVICE&gt;</td><td valign="top" colspan="1" rowspan="1">从区域的允许 列表中删除&lt;SERVICE&gt;.如果未提供 --zone 选项则将使用默认区域</td></tr><tr><td valign="top">--remove-port=&lt;PORT/PROTOCAL&gt;</td><td valign="top">从区域的允许列表中删除&lt;PORT/PROTOCOL&gt;端口。如果未提供 --zone 选项，则将使用默认区域</td></tr><tr><td valign="top">--reload</td><td valign="top">丢弃运行时配置并应用永久配置</td></tr></tbody></table><h6>firewall-cmd 示例：</h6><p>下例显示默认区域设备为 dmz ,来自192.168.0.0/24 网络的所有流量都被分配给 internal 区域。而 internal 区域上打开了用于mysql 的网络端口</p><pre class="brush:bash;toolbar:false">firewall-cmd&nbsp;--set-default-zone=dmz
firewall-cmd&nbsp;--set-source=192.168.0.0/24&nbsp;--zone=internal&nbsp;&nbsp;&nbsp;&nbsp;#临时生效
firewall-cmd&nbsp;--add-service=mysql&nbsp;--zone=internal&nbsp;&nbsp;&nbsp;&nbsp;#临时生效
firewall-cmd&nbsp;--permanent&nbsp;--set-source=192.168.0.0/24&nbsp;--zone=internal&nbsp;&nbsp;&nbsp;&nbsp;#永久配置
firewall-cmd&nbsp;--permanent&nbsp;--set-service=mysql&nbsp;--zone=internal&nbsp;&nbsp;&nbsp;&nbsp;#永久配置
firewall-cmd&nbsp;--reload&nbsp;&nbsp;&nbsp;&nbsp;#永久配置才需要</pre><h6>tips:<br /></h6><p>对于 firewalld 的基本语法不够的情况，系统管理员还可以添加富规则（一种更具表达力的语法）来编写更加复杂的规则，如果富规则语法也不够，系统管理员还可以直接配置规则，基本上是将与 firewalld 规则混合使用的原始 iptables 语法。</p><p><br /></p>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>511</wp:post_id>
		<wp:post_date><![CDATA[2018-10-17 18:20:04]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-10-17 10:20:04]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[rh134-%e7%ac%ac%e5%8d%81%e5%9b%9b%e7%ab%a0-%e4%bd%bf%e7%94%a8-firewalld-%e9%99%90%e5%88%b6%e7%bd%91%e7%bb%9c%e9%80%9a%e4%bf%a1]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="rhel134"><![CDATA[RHEL134]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_page_template]]></wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>RH134 第十五章 系统管理二总复习</title>
		<link>https://www.rhel.tk/2018/10/18/rh134-%e7%ac%ac%e5%8d%81%e4%ba%94%e7%ab%a0-%e7%b3%bb%e7%bb%9f%e7%ae%a1%e7%90%86%e4%ba%8c%e6%80%bb%e5%a4%8d%e4%b9%a0/</link>
		<pubDate>Thu, 18 Oct 2018 09:17:36 +0000</pubDate>
		<dc:creator><![CDATA[blogs]]></dc:creator>
		<guid isPermaLink="false">https://www.rhel.tk/?p=525</guid>
		<description></description>
		<content:encoded><![CDATA[<p>一、系统应借助以下设置业验证使用 LDAP 和 Kerberos&nbsp; 的用户身份：<br /></p><table><tbody><tr class="firstRow"><th>名称</th><th>值</th></tr><tr><td valign="top">LDAP 服务器</td><td valign="top">classroom.example.com</td></tr><tr><td valign="top">搜索基础</td><td valign="top">dc=example,dc=com</td></tr><tr><td valign="top">使用 TLS&nbsp;</td><td valign="top">&nbsp;是</td></tr><tr><td valign="top">TLS CA 证书</td><td valign="top">http://classroom.example.com/pub/example-ca.crt</td></tr><tr><td valign="top">Kerberos 域</td><td valign="top">&nbsp;EXAMPLE.COM</td></tr><tr><td valign="top">Kerberos KDC</td><td valign="top">classroom.example.com</td></tr><tr><td valign="top">Kerberos 管理服务器</td><td valign="top">classroom.example.com</td></tr></tbody></table><p>为了进行测试，可用用户ldapuserX ,密码为kerberos&nbsp;</p><p>1、安装 authconfig-gtk , sssd 软件包</p><pre class="brush:bash;toolbar:false">[student@desktop0&nbsp;Desktop]$&nbsp;sudo&nbsp;yum&nbsp;install&nbsp;-y&nbsp;authconfig-gtk&nbsp;sssd</pre><p>2、运行authconfig-gtk ,并输入提供的信息，请不要忘记取消选中使用 DNS 查找域的 KDC 选项<br /></p><pre class="brush:bash;toolbar:false">[student@desktop0&nbsp;Desktop]$&nbsp;sudo&nbsp;authconfig-gtk</pre><p><img src="/wp-content/uploads/image/20181018/1539846626591619.png" title="1539846626591619.png" alt="image.png" width="354" height="411" /></p><p>二、LDAP 用户的主目录应当在访问时自动挂载。这些主目录是由NFS 共享 classroom.example.com:/home/guests 提供的</p><p>1、安装autofs 软件包</p><pre class="brush:bash;toolbar:false">[student@desktop0&nbsp;Desktop]$&nbsp;sudo&nbsp;yum&nbsp;install&nbsp;autofs&nbsp;-y</pre><p>2、创建包含以下内容的新文件 /etc/auto.master.d/guests.autofs</p><pre class="brush:bash;toolbar:false">/home/guests&nbsp;/etc/auto.guests</pre><p>3、创建包含以下内容的新文件 /etc/auto.guests</p><pre class="brush:bash;toolbar:false">*&nbsp;-rw,sync&nbsp;classroom.example.com:/home/guests/&amp;</pre><p>4、启用并启动 autofs.service 服务</p><pre class="brush:bash;toolbar:false">[student@desktop0&nbsp;Desktop]$sudo&nbsp;systemctl&nbsp;enable&nbsp;autofs.service
[student@desktop0&nbsp;Desktop]$sudo&nbsp;systemctl&nbsp;start&nbsp;autofs.service</pre><p>三、server0 会导出 CIFS 共享，westeros 。该共享应当在启动时自动挂载到挂载点 /mnt/westeros 。要挂载该共享，您需要使用用户名 tyrion 密码 slapjoffreyslap 。该密码不应存储在非特权用户只可以读取的任何位置。</p><p>1、安装 cifs-utils 软件包</p><pre class="brush:bash;toolbar:false">[student@desktop0&nbsp;Desktop]$&nbsp;sudo&nbsp;yum&nbsp;install&nbsp;cifs-utils&nbsp;-y</pre><p>2、创建挂载点<br /></p><pre class="brush:bash;toolbar:false">[student@desktop0&nbsp;Desktop]$sudo&nbsp;mkdir&nbsp;-p&nbsp;/mnt/westeros</pre><p>3、创建包含以下内容的凭据文件，/root/tyrion.creds，然后将该文件的权限设置为：0600<br /></p><pre class="brush:bash;toolbar:false">username=tyrion
password=slapjoffryslap</pre><pre class="brush:bash;toolbar:false">[student@desktop0&nbsp;Desktop]$sudo&nbsp;chmod&nbsp;0600&nbsp;/root/tyrion.creds</pre><p>4、将以下行添加到 /etc/fstab：<br /></p><pre class="brush:bash;toolbar:false">//server0.example.com/westeros&nbsp;/mnt/westeros&nbsp;cifs&nbsp;creds=/root/tyrion.creds&nbsp;0&nbsp;0</pre><p>5、挂载所有文件系统，然后检查挂载的文件系统。<br /></p><pre class="brush:bash;toolbar:false">[student@desktop0&nbsp;Desktop]$sudo&nbsp;mount&nbsp;-a
[student@desktop0&nbsp;Desktop]$cat&nbsp;/mnt/westeros/README.txt</pre><p>四、server0 会导出 NFSv4 共享 /essos&nbsp; 。需要使用 Kerberos 身份验证、加密和完整性检查来在启动时将该共享以只读写形式挂载到 /mnt/essos 。</p><p>可以从 <a href="http://classroom.example.com/pub/keytabs/desktop0.keytab">http://classroom.example.com/pub/keytabs/desktop0.keytab</a>&nbsp;下载系统的keytab&nbsp;</p><p>1、创建挂载点</p><pre class="brush:bash;toolbar:false">[student@desktop0&nbsp;Desktop]$sudo&nbsp;mkdir&nbsp;-p&nbsp;/mnt/essos</pre><p>2、下载系统的 keytab&nbsp;<br /></p><pre class="brush:bash;toolbar:false">[student@desktop0&nbsp;Desktop]$sudo&nbsp;wget&nbsp;-O&nbsp;/etc/krb5.keytab&nbsp;http://classroom.example.com/pub/keytabs/desktop0.keytab</pre><p>3、将以下行添加到 /etc/fstab :<br /></p><pre class="brush:bash;toolbar:false">[student@desktop0&nbsp;Desktop]$server0.example.com:/essos&nbsp;/mnt/essos&nbsp;nfs&nbsp;sec=kerb5p,rw&nbsp;0&nbsp;0</pre><p>4、启动并启用 nfs-secure.service 服务<br /></p><pre class="brush:bash;toolbar:false">[student@desktop0&nbsp;Desktop]$sudo&nbsp;systemctl&nbsp;enable&nbsp;nfs-secure.service&nbsp;
[student@desktop0&nbsp;Desktop]$sudo&nbsp;systemctl&nbsp;start&nbsp;nfs-secure.service</pre><p>5、挂载所有文件系统</p><pre class="brush:bash;toolbar:false">[student@desktop0&nbsp;Desktop]$sudo&nbsp;mount&nbsp;-a</pre><p>五、在新的2 G 卷组stark 中配置新 512M 逻辑卷 arya 。<br /></p><p>新逻辑卷应使用 xfs 文件系统进行格式化，并永久挂载到 /mnt/underfoot&nbsp;</p><p>1、在第二块磁盘上创建 2G 的分区</p><p><img src="/wp-content/uploads/image/20181018/1539847801848346.png" title="1539847801848346.png" alt="image.png" /></p><p>2、将新分区变为物理卷</p><pre class="brush:bash;toolbar:false">[student@desktop0&nbsp;Desktop]$sudo&nbsp;pvcreate&nbsp;/dev/sdb1</pre><p>3、使用新物理卷构建新卷组<br /></p><pre class="brush:bash;toolbar:false">[student@desktop0&nbsp;Desktop]$sudo&nbsp;vgcreate&nbsp;stark&nbsp;/dev/sdb1</pre><p>4、在新卷组中创建 512M 的新逻辑卷<br /></p><pre class="brush:bash;toolbar:false">[student@desktop0&nbsp;Desktop]$sudo&nbsp;lvcreate&nbsp;-n&nbsp;arya&nbsp;-L&nbsp;512M&nbsp;stark</pre><p>5、使用 xfs 文件系统对新 LV 进行格式化<br /></p><pre class="brush:bash;toolbar:false">[student@desktop0&nbsp;Desktop]$&nbsp;sudo&nbsp;mkfs&nbsp;-t&nbsp;xfs&nbsp;/dev/mapper/stark-arya</pre><p>6、创建挂载点&nbsp;<br /></p><pre class="brush:bash;toolbar:false">[student@desktop0&nbsp;Desktop]$sudo&nbsp;mkdir&nbsp;-p&nbsp;/mnt/underfoot</pre><p>7、将以下行添加到 /etc/fstab&nbsp;<br /></p><p><span style="font-size: 14px"></span></p><pre class="brush:bash;toolbar:false">/dev/mapper/stark-arya&nbsp;/mnt/underfoot&nbsp;xfs&nbsp;defaults&nbsp;1&nbsp;2</pre><p><span style="font-size: 14px">8、挂载所有文件系统</span><br /></p><pre class="brush:bash;toolbar:false">[student@desktop0&nbsp;Desktop]$sudo&nbsp;mount&nbsp;-a</pre><p>六、系统应该配备新的 512 M 交换分区，并在启动时自动激活。<br /></p><p>1、第二块磁盘上创建 512 M 的新分区，然后将该分区类型设置为 82&nbsp;</p><p><img src="/wp-content/uploads/image/20181018/1539848579837356.png" title="1539848579837356.png" alt="image.png" /></p><p>2、将新分区格式化成交换分区<br /></p><pre class="brush:bash;toolbar:false">[student@desktop0&nbsp;Desktop]$sudo&nbsp;mkswap&nbsp;/dev/sdb2</pre><p>3、检索UUID 中的交换分区<br /></p><pre class="brush:bash;toolbar:false">[student@desktop0&nbsp;Desktop]$sudo&nbsp;blkid&nbsp;/dev/sdb2</pre><p>4、向/etc/fstab 添加以下行；确保使用上一步找到的UUID，假设为UUID=dfce28a9-015d-4908-8206-840920260310<br /></p><pre class="brush:bash;toolbar:false">UUID=dfce28a9-015d-4908-8206-840920260310&nbsp;&nbsp;swap&nbsp;swap&nbsp;defaults&nbsp;0&nbsp;0</pre><p>5、激活所有交换分区<br /></p><pre class="brush:bash;toolbar:false">[student@desktop0&nbsp;Desktop]$sudo&nbsp;swapon&nbsp;-a</pre><p>七：创建新组 kings ，以及四个属于该组的新用户： stannis，joffery,renly和robb。<br /></p><p>1、创建 kings 组</p><pre class="brush:bash;toolbar:false">[student@desktop0&nbsp;Desktop]$sudo&nbsp;groupadd&nbsp;kings</pre><p>2、创建四个用户，并将他们添加到kings 组&nbsp;<br /></p><pre class="brush:bash;toolbar:false">[student@desktop0&nbsp;Desktop]$for&nbsp;NEWUSER&nbsp;in&nbsp;stannis&nbsp;joffrey&nbsp;renly&nbsp;robb;&nbsp;do
&gt;sudo&nbsp;useradd&nbsp;-G&nbsp;kings&nbsp;${NEWUSER}
&gt;done</pre><p>八、创建新目录 /ironthrone&nbsp; 该目录由拥有权限 0700 的 root:root 所有。</p><p>配置该目录，以便 kings 组中的用户拥有该目录的读写权限，但用户 joffrey 除外，该用仅被授予读取特权。</p><p>这些限制还应当应用到 /ironthrone 目录下创建的所有新文件和目录。</p><p>1、创建权限正常的目录</p><pre class="brush:bash;toolbar:false">[student@desktop0&nbsp;Desktop]$sudo&nbsp;mkdir&nbsp;-m&nbsp;0700&nbsp;/ironthone</pre><p>2、 在 /ironthone 中添加 ACL ，从而向 kings 组中的用户授予读写特权。请不忘记添加执行权限，因为这是一个目录。<br /></p><pre class="brush:bash;toolbar:false">[student@desktop0&nbsp;Desktop]$sudo&nbsp;setfacl&nbsp;-m&nbsp;g:kings:rwX&nbsp;/ironthone</pre><p>3、为用户 joffrey 添加ACL ，使其拥有只读和执行权限<br /></p><pre class="brush:bash;toolbar:false">[student@desktop0&nbsp;Desktop]$sudo&nbsp;setfacl&nbsp;-m&nbsp;u:joffrey:r-x&nbsp;/ironthone</pre><p>4、也添加前两个 ACL 作为默认 ACL&nbsp;<br /></p><pre class="brush:bash;toolbar:false">[student@desktop0&nbsp;Desktop]$sudo&nbsp;setfacl&nbsp;-m&nbsp;d:g:kings:rwx&nbsp;/ironthone
[student@desktop0&nbsp;Desktop]$sudo&nbsp;setfacl&nbsp;-m&nbsp;d:u:joffrey:r-x&nbsp;/ironthone</pre><p>九、安装 httpd 和 mod_ssl 软件包，然后启用并启动 httpd.service 服务</p><p>1、安装 httpd 和 mod_ssl 软件包</p><pre class="brush:bash;toolbar:false">[student@desktop0&nbsp;Desktop]$sudo&nbsp;yum&nbsp;install&nbsp;httpd&nbsp;mod_ssl&nbsp;-y</pre><p>2、启动并启用 httpd.service 服务<br /></p><pre class="brush:bash;toolbar:false">[student@desktop0&nbsp;Desktop]$sudo&nbsp;systemctl&nbsp;enable&nbsp;httpd
[student@desktop0&nbsp;Desktop]$sudo&nbsp;systemctl&nbsp;start&nbsp;httpd</pre><p>十、在系统上所有行防火墙的默认区域打开端口12345/tcp&nbsp;</p><p>1、在防火墙默认区域永久配置中打开端口 12345/tcp&nbsp;</p><pre class="brush:bash;toolbar:false">[student@desktop0&nbsp;Desktop]$sudo&nbsp;firewall-cmd&nbsp;--permanent&nbsp;--add-port=12345/tcp</pre><p>2、重新加载防火墙以激活更改<br /></p><pre class="brush:bash;toolbar:false">[student@desktop0&nbsp;Desktop]$sudo&nbsp;firewall-cmd&nbsp;--reload</pre><p>十一、创建新目录 /docroot 。确保该目录的 SELinux 上下文设置为 Public_content_t ，并且该上下文在重新标记操作后继续生效<br /></p><p>1、创建/docroot 目录</p><pre class="brush:bash;toolbar:false">[student@desktop0&nbsp;Desktop]$sudo&nbsp;mkdir&nbsp;/docroot</pre><p>2、为 /docroot 目录及其所有子目录添加新的默认上下文<br /></p><pre class="brush:bash;toolbar:false">[student@desktop0&nbsp;Desktop]$sudo&nbsp;semanage&nbsp;fcontext&nbsp;-a&nbsp;-t&nbsp;public_content_t&nbsp;&#039;/docroot(/.*)?&#039;</pre><p>3、重新标记 /docroot 目录<br /></p><pre class="brush:bash;toolbar:false">&nbsp;[student@desktop0&nbsp;Desktop]$sudo&nbsp;restorecon&nbsp;-RvF&nbsp;/docroot</pre><p>十二、http://server0.example.com/logfile 包含最近项目的日志。下载该文件，然后将所有以 ERROR 或 FAIL 结尾的行提取到文件 /home/student/errors.txt ，所有行都应按日志文件中显示的顺序排列。<br /></p><p>1、下载文件</p><pre class="brush:bash;toolbar:false">[student@desktop0&nbsp;Desktop]$wget&nbsp;http://server0.example.com/logfile</pre><p>2、将以 ERROR 和 FAIL 结尾的第一行提取到文件 /home/student/errors.txt 中，同时保持行顺序不变<br /></p><pre class="brush:bash;toolbar:false">[student@desktop0&nbsp;Desktop]$grep&nbsp;-e&nbsp;&quot;ERROR$&quot;&nbsp;-e&nbsp;&quot;FAIL$&quot;&nbsp;logfile&nbsp;&gt;&nbsp;/home/student/errors.txt</pre><p>十三、系统中应该有一个用于存储临时文件 /run/veryveryvolatile 的新目录。每当运行 systemd-tmpfiles --clean 时，任何超过 5秒的文件都应该从该目录中删除。<br /></p><p>该目录应该拥有权限 1777 并由 root:root 所有。</p><p>1、创建包含以下内容的新文件 /etc/tmpfiles.d/veryveryvolatile.conf:</p><pre class="brush:bash;toolbar:false">d&nbsp;/run/veryveryvolatile&nbsp;1777&nbsp;root&nbsp;root&nbsp;5s</pre><p>2、使用 systemd-tmpfiles 创建目录。<br /></p><pre class="brush:bash;toolbar:false">[student@desktop0&nbsp;Desktop]$sudo&nbsp;systemd-tmpfiles&nbsp;--create</pre><p><br /></p><p><br /></p>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>525</wp:post_id>
		<wp:post_date><![CDATA[2018-10-18 17:17:36]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-10-18 09:17:36]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[rh134-%e7%ac%ac%e5%8d%81%e4%ba%94%e7%ab%a0-%e7%b3%bb%e7%bb%9f%e7%ae%a1%e7%90%86%e4%ba%8c%e6%80%bb%e5%a4%8d%e4%b9%a0]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="rhel134"><![CDATA[RHEL134]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_page_template]]></wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>test</title>
		<link>https://www.rhel.tk/2019/01/03/__trashed/</link>
		<pubDate>Thu, 03 Jan 2019 02:29:19 +0000</pubDate>
		<dc:creator><![CDATA[blogs]]></dc:creator>
		<guid isPermaLink="false">https://www.rhel.tk/?p=534</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>fdf</p>
<!-- /wp:paragraph -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>534</wp:post_id>
		<wp:post_date><![CDATA[2019-01-03 10:29:19]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-01-03 02:29:19]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[__trashed]]></wp:post_name>
		<wp:status><![CDATA[trash]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="uncategorized"><![CDATA[未分类]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_trash_meta_status]]></wp:meta_key>
			<wp:meta_value><![CDATA[draft]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_trash_meta_time]]></wp:meta_key>
			<wp:meta_value><![CDATA[1546482559]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_desired_post_slug]]></wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
	</item>
</channel>
</rss>
